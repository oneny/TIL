# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [13. 합병 정렬](#13-합병-정렬)
  - [Intermediate Sorting Algorithms](#intermediate-sorting-algorithms)
    - [Objectives](#Objectives)
    - [Why learn this?](#why-learn-this)
    - [Faster Sorts](#faster-sorts)
  - [Merge Sort 소개](#merge-sort-소개)
    - [Merge Sort](#merge-sort)
    - [How does it work?](#how-does-it-work)
    - [배열 합병(Merging Arrays)](#배열-합병merging-arrays)
    - [Merging Arrays](#merging-arrays)
    - [Merging Arrays Pseudocode](#mergesort-pseudocode)
    - [Big O of mergeSort](#big-o-of-mergesort)
- [14. 퀵 정렬](#14-퀵-정렬)
  - [How does it work?](#how-does-it-work)
  - [Pivot Helper](#pivot-helper)
  - [Picking a pivot](#picking-a-pivot)
  - [Pivot Pseudocode](#pivot-pseudocode)
  - [피벗 helper 함수 구형](#피벗-helper-함수-구형)
  - [Quicksort Pseudocode](#quicksort-pseudocode)
  - [퀵 정렬 스택 호출 소개](#퀵-정렬-스택-호출-소개)
  - [Big O of Quicksort](#big-o-of-quicksort)
- [15. 기수 정렬(Radix Sort)](#15-기수-정렬radix-sort)
  - [기수 정렬](#기수-정렬)
    - [기수 정렬 소개](#기수-정렬-소개)
    - [Radix Sort](#radix-sort)
    - [Radix Sort Helpers](#radix-sort-helpers)
    - [Radix Sort Pseudocode](#radix-sort-pseudocode)
    - [Radix Sort Implement](#radix-sort-implement)
    - [Big O of Radix Sort](#big-o-of-radix-sort)
- [16. 자료 구조 소개](#16-자료-구조-소개)
  - [자료 구조를 배워야 하는 이유](#자료-구조를-배워야-하는-이유)
    - [What do they do?](#what-do-they-do)
    - [Why so many?](#why-so-many)
    - [Why care?](#why-care)
  - [ES2015 클래스](#es2015-클래스)
    - [What is a class](#what-is-a-class)
    - [Instance Methods](#instance-methods)
    - [Class Methods](#class-methods)
    - [How we'll be using classes](#how-well-be-using-classes)
- [17. 단방향 연결 리스트(Singly Linked Lists)](#17-단방향-연결-리스트singly-linked-lists)
  - [Linked List](#linked-list)
    - [What is a linked list?](#what-is-a-linked-list)
    - [Singly Linked Lists Diagram](#singly-linked-lists-diagram)
    - [Comparisons with Arrays](#comparisons-with-arrays)
    - [노드 이해하기](#노드-이해하기)
    - [push 메서드](#push-메서드)
    - [pop 메서드](#pop-메서드)
    - [shift 메서드](#shift-메서드)
    - [unshift 메서드](#unshift-메서드)
    - [get 메서드](#get-메서드)
    - [set 메서드](#set-메서드)
    - [insert 메서드](#insert-메서드)
    - [remove 메서드](#remove-메서드)
    - [reverse 메서드](#reverse-메서드)
    - [Big O of Singly Linked Lists](#big-o-of-singly-linked-lists)
    - [Recap](#recap)
- [18. 이중 연결 리스트(Doubly Linked Lists)](#18-이중-연결-리스트doubly-linked-lists)
  - [Doubly Linked Lists](#doubly-linked-lists)
    - [Doubly Linked Lists Diagram](#doubly-linked-lists-diagram)
    - [Node와 Doubly Linked Lists 셋업하기](#node와-doubly-linked-lists-셋업하기)
    - [push 메서드](#push-eba994ec849ceb939c-1)
    - [pop 메서드](#pop-eba994ec849ceb939c-1)
    - [shift 메서드](#shift-eba994ec849ceb939c-1)
    - [unshift 메서드](#unshift-eba994ec849ceb939c-1)
    - [get 메서드](#get-eba994ec849ceb939c-1)
    - [set 메서드](#set-eba994ec849ceb939c-1)
    - [insert 메서드](#insert-eba994ec849ceb939c-1)
    - [remove 메서드](#remove-eba994ec849ceb939c-1)
    - [Big O of Doubly Linked Lists](#big-o-of-doubly-linked-lists)
    - [Recap](#recap-1)

# 13. 합병 정렬

## Intermediate Sorting Algorithms

- 작동 방식에 집중하며, 코드의 각 행이 수행하는 작업을 다시 설명할 수 있는 능력에 집중해야 한다.
  - 처음부터 전부 만들어 내는 데는 집중하지 않아도 괜찮다.
- 위 기본 정렬 알고리즘 보다 빠르지만 직접 작성하기에는 직접적이지 않을 수 있다.
  - 이는 까다롭고, 연구자들이 오랫동안 시도하고 시험하여 만든 알고리즘이기 때문에 바로 이해하기 어려울 수 있다.

### Objectives

- Understand the limitations of the sorting algorithms we've learned so far
  - 지금까지 배운 알고리즘(버블/선택/삽입 정렬)의 한계를 이해한다.
- Implement merge/quick/radix sort
  - 합병 정렬, 퀵 정렬, 지수 정렬을 구현한다.

### Why learn this?

- The sorting algoriths we've learned so far don't scale well
  - 지금까지 배운 정렬 알고리즘은 큰 규모에 맞지 않는다.
  - 20개짜리 항목 배열과 같은 작은 규모에서는 꽤 잘 작동하지만 10만 개의 요소로 작업할 경우라면 잘 적용되지 않는다.
- Try out bubble sort on an array of 100000 elements, it will take quite some time!

  - 버블 정렬을 실제로 시도한다면, 규모를 줄여 10만개 요소로 작업할 경우라도 시간이 꽤 걸린다.

  ```javascript
  function bubbleSort(arr) {
    let noSwaps;
    for (let i = arr.length; i > 0; i--) {
      noSwaps = true;
      for (let j = 0; j < i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          let temp = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = temp;
          noSwaps = false;
        }
      }
      if (noSwaps) break;
    }

    return arr;
  }
  const data = Array.apply(null, { length: 100000 }).map(
    Function.call,
    Math.random
  );
  ```

### Faster Sorts

- There is a family of sorting algorithms that can improve time complexity from O(n^2) to O(n log n)
  - 앞으로 배울 빠른 알고리즘 집합은 시간 복잡도를 O(n^2)에서 O(n log n)으로 향상시킬 수 있다.
  - O(log n)과 O(n)만큼 좋지는 않지만 그래도 꽤 괜찮은 편이다.
  - 따라서 앞으로 시간 복잡도를 개선하는 세 가지 알고리즘을 배울 예정!
- There's a tradeoff between efficiency and simplicity
  - 효율성과 단순성은 안타깝게도 상충된다.
- The more efficient algoriths are much less simple, and generally take longer to understand
  - 그래서 효율적인 알고리즘은 활실히 더 어렵고, 더 길며, 코드가 길지 않더라도 이해하기 더 오래 걸린다.
  - 보통 사람들이 생각하는 방식과는 다르다.
  - 그래서 이해하는데 시간이 좀 더 걸리지만, 그럴만한 가치가 있다.

## Merge Sort 소개

### Merge Sort

- It's a combination of two things - merging and sorting!
  - 합병과 정렬의 조합이다.
  - 분한, 정렬, 합병이 일어나기 때문에 세 가지 조합이라고 볼 수도 있다.
- Exploits the fact that arrays of 0 or 1 element are always sorted
  - 0개, 1개 요소 배열이 이미 정렬되어 있다는 점을 활용한다.
- Works by decomposing an array into smaller arrays of 0 or 1 elements, then building up a newly sorted array
  - 배열을 더 작은 배열로 나누는 방식이다. 더 큰 배열을 나누고 0이나 1 요소 배열이 될 때까지 더 작은 하위 배열로 정렬한다.
  - 따라서 8개 요소 배열을 가져오면 8개의 단일 요소 배열이 될 때까지 분할하고 다시 병합시킨다.

### How does it work?

```
[8, 3, 5, 4, 7, 6, 1, 2] -> split
[8, 3, 5, 4] [7, 6, 1, 2] -> 아직 1개나 0개 요소 배열이 아님 -> split
[8, 3] [5, 4] [7, 6] [1, 2]
[8] [3] [5] [4] [7] [6] [1] [2]
[3, 8] [4, 5] [6, 7] [1, 2] -> 합병시키면서 정렬
[3, 4, 5, 8] [1, 2, 6, 7]
[1, 2, 3, 4, 5, 6, 6, 8]
```

- 정렬된 배열 두 개를 합치는 것은 정렬되지 않은 배열을 합치는 것보다 쉽다.
  - 따라서 기본적으로 어느 숫자가 더 작은지 비교해서 작은 것이 먼저 오도록 해야 한다.
  - 정렬된 배열 두 개를 합병시키는 방법을 이해한다면 나머지는 이해하기 쉽다.
- 시각적으로 어떻게 동작하는지 확인하기
  - [VISUALGO](https://visualgo.net/en/sorting)

### 배열 합병(Merging Arrays)

- 배열이 정렬되어 있다고 가정하고 정렬된 배열 두 개의 조합을 반환하기만 하면 된다.

```
merge([1, 10, 50], [2, 14, 99, 100])
return [1, 2, 10, 14, 50, 99, 100]
```

- In order to implement merge sort, it's useful to first implement a function responsible for merging two sorted arrays.
  - 정렬된 두 배열 합병을 담당할 함수를 먼저 구현하는 것이 좋다
- Given two arrays which are sorted, this helper function should create a new array which is also sorted, and consists of all of the elements in the two input arrays
  - 정렬된 두 배열이 주어지면 이 헬퍼 함수는 마찬가지로 정렬된 새 배열을 만든다.
  - 입력 배열 두 개에 있는 모든 요소를 포함하는 것이 중요하다.
  - 크기가 다를 때는 어떻게 해야 할까?
- This function should run in O(n + m) time and O(n + m) space and should not modify the parameters passed to it.
  - 실제 합병 정렬에서 합치는 두 배열이 주로 크기가 똑같거나 요소 하나 차이가 난다.
  - 하지만 어떠한 이유로 요소 천 개가 있는 배열을 백 만개 요소의 배열과 합병할 경우가 있다면 O(n + m)이 된다.

### Merging Arrays Pseudocode

- Create an empty array, take a look at the smallest values in each input array
  - 입력 두 개를 취하는 함수를 정의하여 마지막에 반환할 빈 배열을 만든다.
  - 각 입력 배열에서 가장 작은 값부터 시작한다.
- While there are still values we haven't looked at ...
  - If the value in the first array is smaller than the value in the second array, push te value in the first array into our results and move on to the next value in the first array
  - If the value in the first array is larget than the value in the second array, push the value in the second array into our results and move on to the next value in the second array
  - Once we exhaust on array, push in all remaining v alues from the other array
    - 배열 하나를 완료되면 다른 배열의 남은 값을 모두 넣는다.

```javascript
function mergeArrays(arr1, arr2) {
  let result = [];
  let i = 0;
  let j = 0;

  // result에 arr1, arr2 요소 합친 개수만큼 있으면 종료
  while (result.length < arr1.length + arr2.length) {
    if (arr1[i] <= arr2[j]) {
      // arr1[i]가 arr2[j]보다 작거나 같으면 arr1[i] 요소 삽입
      result.push(arr1[i]);
      i++;
      if (arr1.length === i) result = result.concat(arr2.slice(j));
    } else {
      result.push(arr2[j]);
      j++;
      if (arr2.length === j) result = result.concat(arr1.slice(i));
    }
  }

  return result;
}
```

- concat과 slice를 사용했는데 좋은 코드인지 잘 모르겠다..

### 배열 합병 구현

```javascript
function merge(arr1, arr2) {
  let results = [];
  let i = 0;
  let j = 0;
  // 두 배열 중 하나라도 끝 인덱스에 다른 작업을 해야 한다.(남은 배열의 요소들을 삽입하는 작업)
  while (i < arr1.length && j < arr2.length) {
    if (arr2[j] > arr1[i]) {
      results.push(arr1[i]);
      i++;
    } else {
      results.push(arr2[j]);
      j++;
    }
  }

  while (i < arr1.length) {
    results.push(arr1[i]);
    i++;
  }

  while (j < arr2.length) {
    results.push(arr2[j]);
    j++;
  }

  return results;
}
```

### mergeSort Pseudocode

- 대부분의 합병 절렬 구현 시 `재귀(Recursion)`을 사용한다.

- Break up the array into halves until you have arrays that are empty or have one element.
  - 요소를 하나 갖거나 빈 배열을 가질 때까지 배열을 반쪽들로 나눈다.
  - 하나의 배열을 반으로 나누려면 어떻게 해야 할까? -> Array.prototype.slice() 추천
  - 다 나눠진 배열들로 무엇을 할까?
- Once you have smaller sorted arrays, merge those arrays with other sorted arrays until you are back at the full length of the array.
  - 이렇게 작은 배열이 준비되면 작성해 놓았던 합병 함수를 사용해 전체 배열 길이로 돌아갈 때까지 다시 합친다.
- Once the array has been merged back togerther, return the merged (and sorted!) array
  - 배열을 다시 합쳤으면 가장 마지막에 합병된 배열을 반환한다.

```javascript
function merge(arr1, arr2) {
  let results = [];
  let i = 0;
  let j = 0;
  // 두 배열 중 하나라도 끝 인덱스에 다른 작업을 해야 한다.(남은 배열의 요소들을 삽입하는 작업)
  while (i < arr1.length && j < arr2.length) {
    if (arr2[j] > arr1[i]) {
      results.push(arr1[i]);
      i++;
    } else {
      results.push(arr2[j]);
      j++;
    }
  }

  while (i < arr1.length) {
    results.push(arr1[i]);
    i++;
  }

  while (j < arr2.length) {
    results.push(arr2[j]);
    j++;
  }

  return results;
}

function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  let mid = Math.floor(arr.length / 2);
  let left = mergeSort(arr.slice(0, mid));
  let right = mergeSort(arr.slice(mid));
  console.log(left, right);

  return merge(left, right);
}

mergeSort([10, 24, 76, 73, 72, 1, 9]);
// 계속 분할...
// [24] [76] - 3단계  <- 2단계 left에 [10]이 할당되고 right으로 가서 3단계로 내려감
// [10] [24, 76] - 2단계 -> [10, 24, 76] 1단계 left에 할당
// [73] [72] - 3단계
// [1] [9] - 3단계
// [72, 73] [1, 9] - 2단계 -> [1, 9, 72, 73] 1단계 right에 할당
// [10, 24, 76] [1, 9, 72, 73] -> 1단계 -> 마지막 merge(left, right)를 호출해서 반환
// [1, 9, 10, 24, 72, ,73, 76] 반환
```

### Big O of mergeSort

| Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| --------------------- | ------------------------ | ---------------------- | ---------------- |
| O(n log n)            | O(n log n)               | O(n log n)             | O(n)             |

- 입력값이 무엇이든 이미 정렬되어 있든, 거꾸로 되어 있든, 모두 무작위든 상관없이 계속 나누고 나눈 다음에 합치고 또 합친다.

#### n log n인 이유과 도출된 방법

```
// O(log n) decompositions * O(n) comparisons per decomposition
[8] [3] [5] [4] [7] [6] [1] [2]
[3, 8] [4, 5] [6, 7] [1, 2]
[3, 4, 5, 8] [1, 2, 6, 7]
[1, 2, 3, 4, 5, 6, 7, 8]
```

- 요소 여덟 개가 있는 배열로 시작한다면, 합병 과정을 거친 마지막에 다음과 같이 보인다.
- 배열에 항목 여덟 개가 있다면, 단일 요소 배열이 되려면 몇 번을 나누어야 할까?
  - 이 경우에는 세 번이다.
- 만약 32개의 요소가 있는 배열이 있다면
  - 나누어 16개 요소 2개(1) -> 8개 항목 4개(2) -> 4개 항목 8개(3) -> 2개 항목 16개(4) -> 1개 항목 32개(5)
  - 총 5번 나누어 진다.
- 위 나누어지는 과정을 빅오로 보면 log n이다.
- 그럼 n log n은 무엇일까? 어디서 나타난 것일까?
  - 각 분할마다, 합병할 때 O(n) 비교를 통해 합병한다.
  - n의 길이가 늘어난다면, 합병 정렬이 아닌 합병 알고리즘 자체는 O(n)의 시간 복잡도를 갖게 된다.
- 즉 분할은 O(log n)의 시간 복잡도를 가지는 반면, 분할마다 합병 자체는 O(n)의 시간 복잡도를 가진다.

# 14. 퀵 정렬

- Like merge sort, exploits the fact that arrays of 0 or 1 element are always sorted
  - 합병 정렬 같은 경우, 0개, 1개 요소 가진 배열은 항상 정렬되어 있다는 사실을 이용한다.
- Works by selecting one element (called the "pivot") and finding the index where the pivot should end up in the sorted array
  - 피벗 포인트라 부르는 단일 요소를 선택하여 수행한다.(\* 어떤 배열에서 어떤 요소를 선택하든 문제가 되지 않음)
  - 피벗이 정렬된 배열에서 끝나야 하는 인덱스를 찾는다.
  - 예를 들어, 중앙에 있는 요소를 선택했을 경우, 할 일은 해당 요소의 숫자보다 작은 숫자를 왼쪽으로 정렬이 아닌 옮기는 것이다. 그리고 그 숫자보다 큰 숫자를 오른쪽으로 정렬이 아닌 옮긴다.
  - 이 때, 그 숫자 하나는 올바른 위치이다. 그 숫자 하나만! 다른 숫자들이 오른쪽이나 왼쪽에 있지만 정렬되어 있는지는 모른다.
- Once the pivot is positioned approprivately, quick sort can be applied on either side of the pivot.
  - 그러면 이 과정을 왼쪽과 오른쪽에 반복한다.

### How does it work?

```
[5, 2, 1, 8, 4, 7, 6, 3] -> 1번 인덱스 5를 기준으로 작은 수는 왼쪽, 큰 수는 오른쪽
[3, 2, 1, 4, "5", 7, 6, 8] -> 5만 적절한 위치(4번 인덱스)에 있다. 이 과정을 왼쪽과 오른쪽에서 재귀적으로 반복
[1, 2, "3", 4, "5", 7, 6, 8] -> 3을 기준으로 적절한 위치에 두고 왼쪽은 요소가 2개 이상이므로 재귀 실행
["1", 2, "3", 4, "5", 7, 6, 8] -> 이제 5 기준 오른쪽에서 7을 기준으로 정렬
["1", 2, "3", 4, "5", 6, "7", 8] -> 요소가 하나 남은 것들은 재귀호출하지 않아도 되므로 정렬 완료.
           5 -> 1번
     3           7   -> 2번
1      4     6     8 -> 3번(왼쪽에서만)
   2
```

### Pivot Helper

- In order to implement merge sort, it's useful to first implement a function responsible arranging elements in an array on either side of a pivot
- Given an array, this helper function should designate an element as the pivot
- It should then reaarange elements in the array so that all values less than the pivot are moved to the left of the pivot, and all values greater than the pivot are moved to the right of the pivot
  - 배열이 주어지면 요소를 피벗 포인트로 지정하여 배열 속 요소를 재배치하는 함수를 작성한다.
- The order of elements on either side of the pivot doesn't matter!
  - 말 그대로 양쪽의 순서는 중요하지 않다.
- The helper should do this <b>in place</b>, that is, it should not create a new array
  - 새 배열을 만들면 안 되고, 피벗 인덱스를 반환해야 한다.
- When complete, the helper should return the index of the pivot
  - helper 함수는 제 자리에서 모두 수행하므로 새 배열을 만들지 않는다.

### Picking a pivot

- The runtime of quick sort depends in part on how one selects the pivot
  - 퀵 정렬의 실행 시간은 피벗 선택 위치에 따라 달라질 수 있다.
- Ideally, the pivot should be chosen so that it's roughly the median value in the data set you're sorting
  - 이상적으로는 데이터 집합의 중간값이 되도록 선택해야 한다.
  - 가능하다면 완벽하게 선택할 수 있는 경우, 데이터 정령의 중간값을 선택해서 왼쪽과 오른쪽이 같도록 하는 것이 좋지만
  - 데이터가 무엇인지, 순서가 어떻게 되어 있는지 모른다면 쉽지 않다. 그래서 다른 전략 선택.
- For simplicity, we'll always choose the pivot to be the first element (we'll talk about consequences of this later)
  - 편의상 항상 첫 번째 요소를 피벗으로 선택할 것이다.
  - 그렇게 하면 나중에 얘기할 빅오에 어떤 영향을 미친다.

#### Pivot Helper Example

```js
let arr = [5, 2, 1, 8, 4, 7, 6, 3];

pivot(arr); // 4;

arr;

// any one of these is an acceptable mutation:
// [2, 1, 4, 3, 5, 8, 7, 6]
// [1, 4, 3, 2, 5, 7, 6, 8]
// [3, 2, 1, 4, 5, 7, 6, 8]
// [4, 1, 2, 3, 5, 6, 8, 7]
// there are other acceptable mutations too!
```

### Pivot Pseudocode

- It will help to accept three arguments: an array, a start index, and an end index (these can default to 0 and the array length minus 1, respectively)
  - 피벗 또는 파티션이라 불리는 함수를 작성한다.
  - 이 함수는 배열, 시작인덱스(start index), 끝인덱스(end index)라는 세 개의 인수를 받는다.
  - 그리고 기본값으로 시작인덱스는 0, 끝인덱스는 배열 길이 - 1 이다.
- Grab the pivot from the start of the array
  - 다음 배열 시작 부분에서 피벗을 선택한다.(평의상임. 다른 피벗을 기준을 선택해도 됨)
- Store the current pivot index in a variable (this will keep track of where the pivot should end up)
  - 그런 다음 현재의 피벗 인덱스를 변수로 저장한다.
  - 이렇게 하여 마지막에 피벗을 바꿀 위치를 계속 확인한다.
- Loop through the array from the start until the end
  - 시작부터 끝까지 배열에 루프를 수행한다.
  - If the pivot is greater than the current element, increment the pivot index variable and then swap the current element with the element at the pivot index
    - 살펴보는 요소보다 피벗이 클 경우 피벗 인덱스 변수를 증가시킨 다음 현재 요소를 피벗 인덱스의 요소와 바꾼다.
- Swap the starting element (i.e. the pivot) with the pivot index
- Return the pivot index
  - 그리고 맨 마지막에는 시작했던 피벗과 피벗 인덱스를 바꾼 다음 피벗 인덱스를 반환한다.

### 피벗 helper 함수 구형

```js
function pivot(arr, start = 0, end = arr.length - 1) {
  // ES5 버전의 스왑 함수
  // const swap = (arr, idx1, idx2) => {
  //   [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  // }

  function swap(arr, i, j) {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  let pivot = arr[start];
  let swapIdx = start; // 스왑 인덱스는 피벗이 맨 마지막에 어디로 옮길지 추적

  // 첫 번째 항목 뺴고 루프 수행
  for (let i = start + 1; i < arr.length; i++) {
    // 피벗 비교 (피벗이 해당 요소보다 클 경우 스왑!)
    if (pivot > arr[i]) {
      swapIdx++;
      swap(arr, swapIdx, i);
    }
  }
  swap(arr, start, swapIdx);

  return swapIdx;
}
// pivot([4, 8, 2, 1, 5, 7, 6, 3])
// 첫 번째 엘리먼트를 피벗으로 취하기 때문에 위치할 인덱스 3을 반환해야 한다.
// [4, 8, 2, 1, 5, 7, 6, 3] 첫 번쨰 루프
// [4, 2, 8, 1, 5, 7, 6, 3] 두 번쨰 루프, swapIdx = 1
// [4, 2, 1, 8, 5, 7, 6, 3] 세 번쨰 루프, swapIdx = 2
// [4, 2, 1, 3, 5, 7, 6, 8] 마지막 루프, swapIdx = 3
// 루프 끝나고 arr[swapIdx]와 arr[start] 스왑!
// [3, 2, 1, 4, 5, 7, 6, 8], swapIdx = 3
```

### Quicksort Pseudocode

- Call the pivot helper on the array
  - 전체 배열의 가장 앞에서 피벗 헬퍼를 호출한다.(인덱스를 반환하는 것이 중요)
  - 그리고 해당 피벗 포인트의 왼쪽과 오른쪽에서 다시 퀵 정렬을 호출
- When the helper returns to you the updated pivot index, recursively call the pivot helper on the subarray to the left of that index, and the subarray to the right of that index
  - 업데이트된 피벗 인덱스를 헬퍼가 반환하면 피벗 헬퍼를 재귀적으로 왼쪽과 오른쪽에 호출한다.
  - <b>중요한 점은 새로운 배열을 만들지 않는 것!</b> -> 모두 제자리(같은 배열)에서 일어난다.
  - 따라서 `base case`는 단순히 배열의 길이나 배열에 하나의 항목이 있는지 확인하는 것이 아니라 하위 배열에 항목 하나가 있는지 확인도록 작성해야 한다.
- Your base case occurs when you consider a subarray with less than 2 elements
  - 즉, 하위배열에 2개 미만의 요소가 있을 때 수행된다.

```js
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 하위 배열이 하나의 요소 길이에 도달했을 때를 base case로 둬야하는데
  // 이 때, 왼쪽과 오른쪽이 같다면 한 요소를 살펴보고 있다는 것이므로 left가 right보다 작을 때만 실행하도록 설정
  console.log(left, right);
  if (left < right) {
    // 가장 처음 진행할 때 전체 배열을 호출한 다음,
    // quickSort 재귀함수가 결국 이곳의 하위 배열을 다시 시작하기 때문에 하위 배열은 시작포인트, 끝포인트가 다른다.
    let pivotIndex = pivot(arr, left, right); // 피벗 인덱스, 배열에서 피벗을 호출하는 것과 같음
    // left
    console.log("pivot", pivotIndex);
    quickSort(arr, left, pivotIndex - 1);
    // right
    quickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

quickSort([4, 8, 2, 1, 5, 7, 6, 3]);
// [4, 8, 2, 1, 5, 7, 6, 3]
// [3, 2, 1, 4, 6, 9, 5]
//           4
//  3, 2, 1     6, 9, 5
//        3        6
//  2, 1        5     9
//     2
//  1
```

### 퀵 정렬 스택 호출 소개

```js
quickSort([4, 6, 9, 1, 2, 5]);

// 실행 순서
// quickSort([4, 6, 9, 1, 2, 5], 0, 5)
// pivot([4, 6, 9, 1, 2, 5], 0, 5) -> return 2(pivotIndex)
// 왼쪽부터 시작
// quickSort([2, 1, 4, 6, 9, 5], 0, 1)
// pivot([2, 1, 4, 6, 9, 5], 0, 1) -> return 1(pivotIndex)
// quickSort([1, 2, 4, 6, 9, 5], 0, 0) -> return 지금 arr
// quickSort([1, 2, 4, 6, 9, 5], 1, 1) -> return 지금 arr
// 이제부터 오른쪽
// quickSort([1, 2, 4, 6, 9, 5], 3, 5)
// pivot([1, 2, 4, 5, 6, 9], 3, 5) -> return 4(pivotIndex)
// quickSort([1, 2, 4, 5, 6, 9], 3, 3) -> return 지금 arr
// quickSort([1, 2, 4, 5, 6, 9], 5, 5) -> return 지금 arr
// 마지막 제일 위에 있는 quickSort 함수 호출에 대해서 return arr;

// pivot 빼고 Call Stack 형태

// quickSort([1, 2, 4, 6, 9, 5], 2, 1) -> return(2)
// quickSort([1, 2, 4, 6, 9, 5], 0, 0) -> return(1)
// quickSort([2, 1, 4, 6, 9, 5], 0, 1) -> return(3)
// quickSort([4, 6, 9, 1, 2, 5], 0, 5)

// quickSort([1, 2, 4, 5, 6, 9], 5, 5) -> return(2)
// quickSort([1, 2, 4, 5, 6, 9], 3, 3) -> return(1)
// quickSort([1, 2, 4, 5, 6, 9], 3, 3) -> return(3)
// quickSort([2, 1, 4, 6, 9, 5], 3, 5) -> return(4)
```

### Big O of Quicksort

| Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| --------------------- | ------------------------ | ---------------------- | ---------------- |
| O(n log n)            | O(n log n)               | O(n^2)                 | O(log n)         |

#### Best Case

```
[8, 5, 6, 1, 3, 7, 2, 4, 12, 13, 14, 11, 9, 15, 10]
                      8                               O(lon n) decompositions
[4, 5, 6, 1, 3, 7, 2]   [12, 13, 14, 11 , 9, 15, 10]    ||
          4                         12                  ||       /\
[2, 1, 3]   [6, 7, 5]   [10, 11, 9]    [14, 15, 13]     ||       ||
    2           6            10             14          \/       ||
 1     3     5     7     9       11     13      15            O(n) comparisons per decomposition
```

- 합병 정렬처럼, n이 늘어마녀 밑이 2인 log n의 분해가 수행되는 패턴을 보인다.
  - 32개 요소가 있으면 5번 분해, 64개 요소가 있다면 여섯 번 분해해야 한다.
  - 즉, log n의 비율로 늘어난다.
- 각각 분해하는 단계마다 O(n)번의 비교를 수행해야 한다.

#### Worse Case

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
-> 첫 번째 요소인 1에서 마지막 항목까지 비교, 나뉘는 것 없음
-> 두 번쨰 요소인 2에서 마지막 항목까지 비교, 나뉘는 것 없음
-> 즉, n번 나누고 n번 비교한다. O(n * n)
```

- 데이터가 이미 정렬되어 있을 경우 문제가 된다.

# 15. 기수 정렬(Radix Sort)

## 기수 정렬

### 기수 정렬 소개

- 비교 알고리즘이 아닌 정렬 알고리즘 유형이 있는데 데이터의 특별한 속성을 이용한다.
  - 정수 정렬 알고리즘이라는 정렬 그룹이 있는데 정수가 특별 속성에 해당
  - 직접적으로 비교하는 것이 아니다.
- 직접 비교하지 않는다는 말의 의미는 실제로 상대수사보다 큰지 작은지 비교를 하지 않고 다른 방식으로 데이터를 정렬하게 된다.

### Radix Sort

- Radix sort is a special sorting algorithm that works on lists of numbers
  - 비교를 수행하지 않는 특별한 정렬 알고리즘이고, 숫자로 작동한다.
  - 보통 사용할 때는 이진수를 이용한다.
- It never makes comparisons between elements!
  - 두 요소를 가지고 무엇이 더 크고 작은지 비교하지 않는다.
- It exploits the fact that information about the size of a number is encoded in the number of digits.
  - 그 대신, 숫자 크기에 대한 정보를 자릿수로 인코딩한다는 사실을 이용한다.
- More digits means a bibger number!
  - 이 말의 의미는 자릿수가 더 큰 수, 예를 들어 네 자리 수가 있다면 두 자리 수보다 더 크다는 것!
  - **두 수가 무엇인지는 중요하지 않다!**
- 비교 정렬에 비해 아주 빠르게 정렬할 수 있다.

### Radix Sort Helpers

- In order to implement radix sort, it's helpful to build a few helper functions first:

  - getDigit(num, place) - returns the digit in num at the given place value

    - 첫 번쨰로 할 일: 자릿수 알아내기(getDigit)

    ```js
    function getDigit(num, i) {
      return Math.floor(Math.abs(num) / Math.pow(10, i)) % 10;
    }

    getDigit(12345, 0); // 5
    getDigit(12345, 1); // 4
    getDigit(12345, 2); // 3
    getDigit(12345, 3); // 2
    getDigit(12345, 4); // 1
    getDigit(12345, 5); // 0
    ```

  - digitCount(num) - returns the number of digis in num
    - 두 번째 할 일: 전체 배열 안에서 자릿수가 가장 많은 수를 알아내는데 자릿수 계산(digitCount)를 사용
    ```js
    function digitCount(num) {
      if (num === 0) return 1; // 0에 로그 계산(log10)을 수행하면 -Infinity를 얻는다.
      return Math.floor(Math.log10(Math.abs(num))) + 1;
    }
    ```
  - mostDitgits(nums) - Given an array of numbers, returns the number of digits in the largest numbers in the list

    - 세 번째 할 일: 수 목록을 가져와서 가장 자릿수가 많은 수가 무엇인지, 자릿수 계산을 통해 알려준다.

    ```js
    function mostDigits(arr) {
      let maxDigits = 0;
      for (let i = 0; i < arr.length; i++) {
        maxDigits = Math.max(maxDigits, digitCount(arr[i]));
      }
      return maxDigits;
    }

    mostDigits([1234, 56, 7]); // 4
    mostDigits([1, 1, 11111, 1]); // 5
    mostDigits([12, 13, 45, 78]); // 2
    ```

  - 재귀나 복잡한 로직을 짤 필요없이 루프를 수행하여 나눈 다음 버킷에 집어넣고, 다시 묶은다음 n번 반복하면 된다.
    - n은 이 때 최대 자릿수!

### Radix Sort Pseudocode

- Define a function that accepts list of numbers(수 목록을 받는 함수 정의)
- Figure out how many digits the largest number has(가장 큰 수가 몇 자리인지 알아내야 한다.)
- Loop from k = 0 up to this largest number of digits(0부터 가장 큰 자릿수까지 루프)
- For each iteration of the loop:
  - Create buckets for each digit (0 to 9)
    - 진행할 때마다, 각 자릿수에 버킷을 만든다.(버킷: 빈 배열)
  - place each number in the corresponding bucket based on its kth digit
    - 그런 다음 루프를 수행할 때마다 각각의 수를 올바른 버킷에 넣는다. 이 때 kth를 따른다.
    - kth 자릿수: 루프 k가 무엇이든 0에서 시작하며 각 수를 올바른 위치, 올바른 버킷 슬롯에 0 자리를 사용하여 분류하고 다음으로는 첫째 짜리, 둘쨰 자리를 이용하는 것

### Radix Sort Implement

```js
function getDigits(num, i) {
  return Math.floor(Math.abs(num) / Math.pow(10, i)) % 10;
}

function digitCount(num) {
  return Math.floor(Math.log10(Math.abs(num))) + 1;
}

function mostDigits(nums) {
  let maxDigits = 0;
  for (let i = 0; i < nums.length; i++) {
    maxDigits = Math.max(maxDigits, digitCount(nums[i]));
  }

  return maxDigits;
}

function radixSort(nums) {
  let maxDigitCount = mostDigits(nums);

  for (let k = 0; k < maxDigitCount; k++) {
    let digitBuckets = Array.from({ length: 10 }, () => []); // 2차원 배열

    for (let i = 0; i < nums.length; i++) {
      let digit = getDigits(nums[i], k);
      digitBuckets[digit].push(nums[i]);
    }
    nums = [].concat(...digitBuckets); // 전개 연산자(spread operator)
  }

  return nums;
}

radixSort([23, 345, 5467, 12, 2345, 9852]);
```

### Big O of Radix Sort

| Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| --------------------- | ------------------------ | ---------------------- | ---------------- |
| O(nk)                 | O(nk)                    | O(nk)                  | O(n + k)         |

- 최상, 평군, 최악의 시간 복잡도: O(nk)
  - n은 정렬할 항목 수나 정수의 수(length of array)이고, k는 이러한 수의 길이(number of digits)이다.
  - 따라서 아주아주아주아주아주아주아주 자릿수가 길다면 이 점을 고려하는 것이 중요하다.
    - 무시할 수 있는 상수가 아니다. -> 2n, 3n 같은 느낌이 아니다!

# 16. 자료 구조 소개

## 자료 구조를 배워야 하는 이유

### What do they do?

- Data structures are collections of values, the relationships among them, and the functions or operations that can be applied to the data.
  - 그들 모두가 공통적으로 가지고 있는 특징은 **값들의 모음**이라는 것이다.
  - 데이터를 저장할 뿐 아니라 각각의 데이터들 간의 관계를 설정하는 특정한 방식에 의해 데이터를 삽입하기도 한다.
    - **특정한 패턴 또는 관계가 존재한다.**
  - Array 경우, 그 안에 많은 값들이 있으며, 그 값들 사이의 관계(순서) 역시 포함하고 있다.

### Why so many?

- Different data structures excel at different things. Some are highly specialized, while others (like arrays) are more generally used.
  - 특정 유형의 문제에 있어서 특정한 자료 구조가 효율적이라는 사실에 기인한다.
  - 따라서 일부 자료 구조는 매우 특화되어 있는 반면 배열, 객체와 같은 일부 자료 구조들은 일반적이다.
  - 그러나, PB(Red and Black) 트리, 비방향 그래프, 혹은 그와 유사한 자료 구조로 작업해야 할 경우에 이들 자료 구조가 일반 자료 구조들과 다르게 제공되지 않기 때문에 프로그래밍 언어로 직접 구현해야 한다.
    - 그리고 많은 자료구조들 중 하나를 언제 사용할 수 있을지 알고 있어야 한다.

### Why care?

- The more time you spend as a developer, the more likely you'll need to use one of these data structures
  - 개발자로서 많은 시간을 보낼 수록 이러한 고급 자료 구조 사용을 필요로 할 가능성이 그만큼 더 많아진다.
  - 배열만 가지고는 한계가 있기 때문에 더 이상 선형적이지 않고 더 복잡한 데이터를 다루며, 데이터를 저장하기 위한 다른 방법을 배워야 한다.
- Working with map/location data?
  - `Use a graph!`
- Need an ordered list with fast inserts/removals at the beginning and end?
  - 배열의 경우 시작점에 있어 삽입하거나 제거하는 것은 적절하지 않다.
  - `Use a linked list!`
- Web scraping nested HTML?
  - 네스티드(Nested - 구조 내부에 또 다른 구조가 포함되는) HTML을 걷어내는 웹 작업에는?
  - `Use a tree!`
- Need to write a scheduler(작업 우선 순위 결정 모듈)?
  - `Use a binary heap!` (or `Queues`)

## ES2015 클래스

### Objectives

- Explain what a class is (클래스가 무엇인지 살펴보기)
- Understand how JavaScript implements the **idea** of classes
  - 자바스크립트에서 클래스 개념을 어떻게 구현하는지 이해하기
- Define terms like abstraction, encapsulation and polymorphism
  - 추상화, 캡슐화 및 다형성 같은 용어 정의
- Use ES2015 classes to implement data structures
  - ES2015 클래스들을 통해 자료 구조들을 구현하기

### What is a class?

- A blueprint for creating objects with pre-defined properties and methods
  - 사전에 정의된 속성 및 메소들을 이용해 객체를 생성하기 위한 청사진
  - 기본적으로 자바스크립트는 진정한 객체 지향인 적은 없고, 단지 프로토타입 기반 상속자 혹은 프로토타이핑이라 불리는 무엇인가를 이용하는 것이다.
  - 수 많은 자료 구조들을 클래스로 구현해야 하기 때문에 알아야 한다.

### Instance Methods

```js
class Student {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.tardies = 0;
  }

  fullName() {
    return `Your full name is ${this.firstName} ${this.lastName}`;
  }
  markLate() {
    this.tardies++;
    if (this.tardies >= 3) return "YOU ARE EXPELLED!!!!!";
    return `${this.firstName} ${this.lastName} has been late ${this.tardies}`;
  }
}

let firstStudent = new Student("Colt", "Steele");
firstStudent.fullName();
```

### Class Methods

```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  static distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;

    return Math.hypot(dx, dy);
  }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);

Point.distance(p1, p2); // 7.0710...
```

### How we'll be using classes

```js
class DataStructure() {
  constructor() {
    // what default properties should it have?
  }
  someInstanceMethod() {
    // what should each object created from this class be able to do?
  }
}
```

- We will be using the **constructor** and **instance methods** quite a bit!
- We will **almost never** be using **static** methods

# 17. 단방향 연결 리스트(Singly Linked Lists)

### Objectives

- Define what a Singly Linked List is(단방향 연결 리스트가 무엇인지 정의)
- Compare and constrast Linked Lists with Arrays(연결 리스트와 배열을 비교하고 대조)
- Implement insertion, removal and traversal methods on Singly Linked Lists
  - 연결 리스트 클래스를 정의하고, 데이터의 삽입, 추출, 검색, 횡단(순서대로 따라가기), 제거 등을 위한 다수 메서드 구현

## Linked List

### What is a linked list?

- A data structure that contains a head, tail and length property.
- Linked Lists consist of nodes, and each node has a value and a pointer to another node or null
- 배열처럼 순서에 따라 문자열, 숫자 등 무엇이든 원하는 다수의 데이터를 저장하는 자료구조이다.
- 커다란 차이점
  - 배열의 경우, 각 데이터 엘리먼트들은 위치가 지정되고, 번호에 의해 인덱스가 부여된다.
  - 연결 리스트의 경우, 다음 데이터 엘리먼트를 가리키는 **인덱스 없이** 그냥 다수의 데이터 엘리먼트들로 구성된다.
    - 그리고 각각의 엘리먼트를 "노드"라고 부른다.
    - 따라서 연결 리스트들은 다수의 노드들로 구성되고, 각각의 노드는 문자열 혹은 숫자와 같은 하나의 데이터 엘리먼트를 저장한다.
    - 각 노드들은 다음 노드를 가리키는 정보 역시 저장하고 있어야 하며, 더 이상 다음 노드가 없을 경우 아무것도 없음을 의미하는 `null`을 저장하게 된다.
  - 연결 리스트의 세 가지 속성
    - `헤드`: 연결 리스트의 시작 노드를 가리킨다.
    - `테일`: 연결 리스트의 마지막 노드를 가리킨다. 중간에 있는 노드들은 일일히 추적하지 않는다.
    - `길이`: 작업을 용이하게 하기 위해서 길이라는 `속성`을 계속 유지한다.

### Singly Linked Lists Diagram

```
  HEAD    Length: 4     TAIL
    4 ---> 6 ---> 8 ---> 2 --->
      next   next   next   null
```

- 인덱스가 없는 것에 주목!
  - 이것이 `0`번째이고, 첫 번째, 두 번째 그리고 세번째 라는 식으로 이야기할 수 없다!
- 이 리스트에서 무엇인가를 접근하고 싶다면 첫 번째 노드부터 시작해야 한다.
- 연결 리스트는 단지 다음 노드들을 가리키고 있는 수많은 노드들이라고 보면 된다.

### Comparisons with Arrays

- **Lists**
  - Do not have indexes!
    - 각 항목과 일치하는 번호를 가지고 있지 않고, 단순히 "첫 노드"라는 의미하는 변수인 `헤드 포인터`를 가지고 있다.
  - Connected via nodes with a next pointer
  - Random access is not allowed
    - 각 노드는 `next` 포인터를 통해 연결되어 있으며, 이는 임의 접근이 허용되지 않는다는 것을 의미한다.
    - **임의 접근 허용X**: 열 번째 항목이 필요한 경우 바로 그 값을 얻을 수 없다는 것을 의미
    - 배열과 달리 **새로운 항목을 추가하거나 기존 항목을 제거할 경우 연결 리스트를 사용하면 매우 편리하다.**
- **Arrays**
  - Indexed in order!
  - Insertion and deletion can be expensive
  - Can quickly be accessed at a specific index
    - 처음이나 중간에 항목을 추가하면 뒤 인덱스들을 다시 지정해야 하는 것을 감수해야 하지만, 특정 인덱스 접근이 빠르다.

### 노드 이해하기

```js
// piece of data(node) - val or value
// reference to next node(다음 노드에 대한 참조 정보) - next

class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

var first = new Node("Hi");
first.next = new Node("there");
first.next.next = new Node("how");
first.next.next.next = new Node("are");
first.next.next.next.next = new Node("you");
```

### push 메서드

Adding a new **node** to the end of the Linked List!

- This functino should accept a value
- Create a new node using the value passed to the function
- If there is no head property on the list, set the head and tail to be the newly created node
- Otherwise set the next property on the tail to be the new node and set the tail property on the list to be the newly created node
  - 만일 리스트가 비어있지 않다면, 마지막 노드의 "next"를 새롭게 생성된 노드를 가리키도록 하고, 테일이 새롭게 생성된 노드를 가리키도록 설정
- Increment the length by one(길이를 추적하기 위해 새로운 노드가 하나 추가되었을 때 1을 더해준다.)
- Return the linked list(변경된 연결 리스트 반환)

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  push(val) {
    const newNode = new Node(val);
    if (!this.head) {
      // 헤드 및 테일 모두가 처음 들어온 새로운 노드를 가리키도록 설정
      this.head = newNode;
      this.tail = newNode;
    } else {
      // 두 번째 노드부터 테일을 이용해 리스트의 마지막에 새로운 노드를 추가하고, 테일을 맨 끝을 가리키도록 설정
      this.tail.next = newNode; // HELLO 노드의 next에 GOODBYE가 붙음
      this.tail = newNode; // 테일을 마지막 노드(GOODBYE)를 가리키도록 이동
    }
    this.length++;
    return this;
  }
}

var list = new SinglyLinkedList();
list.push("HELLO"); // value가 "HELLO"인 새로운 노드 생성(list의 HEAD, TAIL)
list.push("GOODBYE");
```

### pop 메서드

- Removing a **node** from the end of the Linked List!
  - 마지막 노드를 반환하는 것은 쉽지만 문제는 마지막 노드를 제거해야 한다는 것!
  - 또한, 마지막 노드를 제거하면서 새로운 마지막 노드를 가리키도록 설정해야 한다.
    - 역방향 포인터를 가지고 있지 않기 때문에 처음부터 리스트를 계속 따라가야만 가능하다.
    - 테일로부터 그 전 노드를 그냥 알아낼 수는 없다.

#### Popping pseudocode

- If there are no nodes in the list, return undefined
  - 리스트가 비어있는지 확인하려면 `head` 값이 `null`인지 혹은 길이가 `0`인지 확인
- Loop through the list until you reach the tail
- Set the next property of the 2nd to last node to be null
  - 마지막에서 2번째 노드의 `next` 프로퍼티의 값을 null로 설정
- Set the tail to be the 2nd to last node
  - `tail`의 값을 마지막에서 2번째 노드로 설정
- Decrement the length of the list by 1
  - 리스트의 길이를 하나 줄이고,
- Return the value of the node removed
  - 제거한 노드를 반환한다.

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  pop() {
    if (!this.head) return undefined; // 노드가 없는 경우
    let current = this.head;
    let newTail = current;
    while (current.next) {
      // current가 마지막 노드될 때까지 반복
      newTail = current;
      current = current.next;
    }
    this.tail = newTail; // '테일'에 마지막에서 두 번째 노드를 설정
    this.tail.next = null; // 그리고 그 노드를 마지막 노드로 설정
    this.length--;

    // 노드가 하나인 경우는 while 루프를 돌지 않기 때문에 해당 경우만 따로 설정
    if (this.length === 0) {
      this.head = null;
      this.tail = null;
    }

    return current; // 마지막 노드 반환
  }
}

var list = new SinglyLinkedList();
```

### shift 메서드

Removing a new node from the beginnig of the Linked List!

#### Shifting pseudocode

- If there are no nodes, return undefined
- Store the curent head property in a variable
- Set the head property to be the current head's next property
- Decrement the length by 1
- Return the value of the node removed

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  shift() {
    if (!this.head) return undefined;

    let currentHead = this.head;
    this.head = currentHead.next;
    this.length--;
    if (this.length === 0) this.tail = null;

    return currentHead;
  }
}
```

### unshift 메서드

Adding a new node to the beginning of the Linked List!

#### unshifting pseudocode

- This function should accept a value
  - 리스트의 시작위치에 추가하려는 노드를 인자로 받아들이는 함수 정의
- Create a new node using the value passed to the function
- If there is no head property on the list, set the head and tail to be the newly created node
- Otherwise set the newly created node's next property to be the current head property on the list
- Increment the length of the list by 1
- Return the linked list

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  unshift(val) {
    const newNode = new Node(val);

    if (!this.head) {
      // 노드가 없는 경우
      this.head = newNode;
      this.tail = newNode;
    } else {
      // 하나 이상인 경우
      newNode.next = this.head;
      this.head = newNode;
    }
    this.length++;

    return this;
  }
}
```

### get 메서드

Retrieving a **node** by it's position in the Linked List!

- 리스트는 인덱스를 가지고 있지 않아 맨 처음인 "0"부터 주어진 숫자만큼 `.next`를 반복해서 이동해 접근한다.
  - 배열과 비교할 떄 효과적이지 않다.
- 즉각적으로 접근할 수 있는 내장 인덱스를 가지는 배열과는 다르며, 항상 위치를 기준으로 무엇인가에 접근해야 한다면 배열을 사용하는 것이 좋다.

#### Get pseudocode

- This function should accept an index(숫자인 인덱스를 인자로 받아야 한다.)
- If the index is less than zero or greater than or equal to the length of the list, return null
- Loop through the list until you reach the index and return the node at that specific index
  - 루프를 통해 인덱스 위치에 이를때까지 반복해서 이동한 다음 특정 인덱스의 노드를 반환한다.

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}
class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  get(index) {
    if (index < 0 || index >= this.length) return null; // 노드 없음!

    let counter = 0;
    let current = this.head;
    while (counter !== index) {
      current = current.next;
      counter++;
    }

    return current;
  }
}
```

### set 메서드

- Changing the **value** of a node based on it's position in the Linked List
  - 위치 혹은 인덱스와 해당 인덱스에 위치한 노드의 값을 수정한다.

#### Set pseudocode

- This function should accept a value and an index
  - 업데이트할 값과 인덱스를 인자로 받아들이는 함수 작성
- Use **get** function to find the specific node
- If the node is found, set the value of that node to be the value passed to the function and return true

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}
class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  set(index, val) {
    const foundNode = this.get(index);
    if (foundNode) {
      foundNode.val = val;
      return true;
    }
    return false;
  }
}
```

### insert 메서드

Adding a node to the Linked List at a **specific** position

#### Insert Pseudocode

- If the index is less than zero or greater than the length, return false
- If the index is the same as the length, **push** a new node to the end of the list
- If the index is 0, **unshift** a new node to the start of the list
- Otherwise, using the **get** method, access the node at the **index - 1**
- Set the next property on that node to be the new node
- Set the next property on the new node to be the previous next
- Increment the length
- Return true

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}
class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  insert(index, val) {
    if (index < 0 || index > this.length) return false;
    if (index === this.length) return !!this.push(val);
    if (index === 0) return !!this.unshift(val); // true 반환하기 위해 !! 사용

    const newNode = new Node(val); // 새로운 노드 생성
    let prev = this.get(index - 1);
    let temp = prev.next;
    prev.next = newNode;
    newNode.next = temp;
    this.length++;
    return true;
  }
}
```

### remove 메서드

Removing a node from the Linked List at a **specific** position

#### Remove pseudocode

- If the index is less than zero or greater than the length, return undefined
- If the index is the same as the length - 1, **pop**
- If the index is 0, **shift**
- Otherwise, using the **get** method, access the node at the **index - 1**
- Set the next property on that node to be **the next of the next node**
- Decrement the length
- Return the value of the node removed

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}
class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  remove(index) {
    if (index < 0 || index >= this.length) return undefined;
    if (index === 0) return this.shift();
    if (index === this.length - 1) return this.pop();

    const previousNode = this.get(index - 1);
    const removed = previousNode.next;
    previousNode.next = removed.next;
    this.length--;
    return removed;
  }
}
```

### reverse 메서드

Reversing the Lined List **in place!**

#### Reverse preudocode

- Swap the head and tail
- Create a variable called next
- Create a variable called prev
- Create a variable called node and initialize it to the head property
- Loop through the list
- Set next to the next property on whatever node is
- Set the next property on the node to be whatever prev is
- Set prev to be the value of the node variable

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}
class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  reverse() {
    let node = this.head; // 기존 노드 형태를 node에 저장
    this.head = this.tail;
    this.tail = node; // "head"와 "tail" 바꿔주기
    let next;
    let prev = null; // prev 초기값이 null인 이유는 리스트의 끝, 즉 "tail"의 next가 null이기 때문

    for (let i = 0; i < this.length; i++) {
      next = node.next; // 아래 node 위치를 다음 노드로 넘어가기 위해 설정
      node.next = prev; // HEAD였던 노드는 TAIL이 되면서 null을 가지고
      prev = node; // 다음 노드에 next가 되기 위해 prev 값에 설정
      node = next; // 다음 노드로 넘어가자!
    }

    return this;
  }
}

//       [100, 201, 250, 350, 999] 형태의 리스트라면(배열은 아니지만)
//  prev node next
//       prev node next
//            prev node next
//                 prev node next
//                      prev node next -> this.length가 5이므로 루프 끝!
```

### Big O of Singly Linked Lists

- Insertion - O(1)
  - 배열의 경우 맨 앞에 element를 추가하려면 기존에 있던 엘리먼트의 모든 인덱스를 하나씩 이동시켜야 한다.
- Removal - It depends... O(1) or O(n)
  - 리스트의 맨 마지막에서 노드를 제거하는 것은 단방향 연결 리스트에서 head에서 출발해서 테일 앞에 있는 노드를 찾아야 하기 때문에 상당히 어려운 작업이다.
- Searching - O(n)
- Access - O(n)
  - 검색 작업이나 인덱스 접근 작업은 리스트가 길어질 수록 그에 비례해서 증가한다.
- 단방향 연결 리스트가 삽입과 삭제의 경우 배열에 비해 우수하다.
  - 따라서, 삽입 혹은 삭제 작업을 주로 해야 한다거나, 임의 접근 작업이 필요없다거나, 주어진 순서대로 데이터를 관리할 필요가 있는 경우, 배열 보다는 단방향 연결 리스트가 적절하다고 할 수 있다.

### Recap

- Singly Linked Lists are an excellent alternative to arrays when insertion and deletion at the beginning are frequently required
- Arrays contain a built in index whereas Linked Lists do not
  - 단방향 연결 리스트는 단지 다음 노드로 연결되는 참조 혹은 포인터를 갖는 노드들의 집합이다.
  - 단방향 연결 리스트에는 인덱스나 위치 정보가 없다.
    - 따라서 인덱스를 이용해 쉽게 노드에 접근할 수 없다.
- The idea of a list data structure that consists of nodes is the foundation for other data structures ike Stacks and Queues
  - 연결 리스트를 배워야 하는 이유: 스택과 큐와 같은 자료구조의 기반이 된다.

# 18. 이중 연결 리스트(Doubly Linked Lists)

### Objectives

- Construct a Doubly Linked List
- Compare and contrast Doubly and Singly Linked Lists
- Implement basic operations on a Doubly Linked List

## Doubly Linked Lists

### Doubly Linked Lists Diagram

```
     HEAD    Length: 4     TAIL
 null   prev   prev   prev
 <---   <---   <---   <---
      4      6      8      2
        --->   --->   --->   --->
        next   next   next   null
```

- Singly Linked Lists에서 추가로 뒤를 가리키는 포인터도 있다!
- 하지만 문제가 되는 것은 Singly Linked Lists에 비해 메모리가 많이 든다.
  - **More memory === More Flexibility**

### Node와 Doubly Linked Lists 셋업하기

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
}
```

- Node에 필요한 인스턴스 프로퍼티
  - val, next, prev
- DoublyLinkedList에 필요한 인스턴스 프로퍼티
  - head, tail, length

### push 메서드

Adding a node to the **end** of the Doubly Linked List

#### Pushing pseudocode

- Create a new node with the value passed to the function(아규먼트값을 가진 노드 생성)
- If the head property is null, set the head and tail to be the newly created one
- If not, set the next property on the tail to be that node
  - 현재 테일을 찾아서 테일의 next 프로퍼티를 새로 들어온 노드에 설정한다.
- Set the previous property on the newly created node to be the tail
  - 새로 만든 노드의 prev 프로퍼티를 예전 테일로 설정해준다.(예전 테일 <- 현재 테일)
- Set the tail to be the newly created node
  - 테일 프로퍼티를 이제 가장 끝에 있게 된 새로운 노드로 바꿔준다.
- Increment the length
- Return the Doubly Linked List

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  push(val) {
    const newNode = new Node(val);
    if (!this.head) {
      // = this.length === 0
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode; // 예전 테일 노드 -> 현재 테일될 노드
      newNode.prev = this.tail; // 예전 테일 노드 <- 현재 테일될 노드
      this.tail = newNode; // 새로운 노드를 현재 테일 노드로 설정
    }
    this.length++;

    return this;
  }
}
```

### pop 메서드

Removing a node from the **end** of the Doubly Linked List

#### Poping pseudocode

- If there is no head, return undefined
- Store the current tail in a variable to return later
- If the length is 1, set the head and tail to be null
- Update the tail to be the previous Node
  - 테일을 테일의 prev 값인 노드로 업데이트
- Set the newTail's next to null
  - 새로운 테일노드의 next 값을 null로 설정
- Decrement the length
- Return the value removed

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  pop() {
    if (!this.head) return undefined;

    const poppedNode = this.tail;
    if (this.length === 1) {
      // 노드가 하나인 경우
      this.head = null;
      this.tail = null;
    } else {
      // 노드가 둘 이상인 경우
      this.tail = poppedNode.prev; // 새로운 테일노드!
      this.tail.next = null; // 새로운 테일의 next 값을 null로
      poppedNode.prev = null; // pop된 반환되는 노드의 prev값을 지워주기
    }
    this.length--;

    return poppedNode;
  }
}
```

### shift 메서드

Removing a node from the **beginning** of the Doubly Linked List

#### Shifting pseudocode

- If length is 0, return undefined
- Store the current head property in a variable (we'll call it old head)
- If the length is one
  - set the head to be null
  - set the tail to be null
- Update the head to be the next of the old head
- Set the head's prev property to null
- Decrement the length
- Return old head

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  shift() {
    if (this.length === 0) return undefined;

    const oldHead = this.head;
    if (this.length === 1) {
      this.head = null;
      this.tail = null;
    } else {
      this.head = oldHead.next;
      this.head.prev = null; // else에 안넣으면 null.prev 오류 발생!
      oldHead.next = null;
    }
    this.length--;

    return oldHead;
  }
}
```

### unshift 메서드

Adding a node to the **beginning** of the Doubly Linked List

#### Unshifting pseudocode

- Create a new node with the value passed to the function
- If the length is 0
  - Set the head to be the new node
  - Set the tail to be the new node
- Otherwise
  - Set the prev property on the head of the list to be the new node
  - Set the next property on the new node to be the head property
  - Update the head to be the new node
  - 한 마디로, 새로 들어온 노드와 헤드 노드 관계 지어주고, 헤드 노드를 새로 들어온 노드로 업데이트하자!

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  unshift(val) {
    const newNode = new Node(val);
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.head.prev = newNode;
      newNode.next = this.head;
      this.head = newNode;
    }
    this.length++;

    return this;
  }
}
```

### get 메서드

Accessing a node in a Doubly Linked List by its position

#### Get pseudocode

- If the index is less than 0 or greater or equal to the length, return null
- If the index is less than or equal to half the length of the list
  - Loop through the list starting from the head and loop towards the middle
  - Return the node once it is found
- If the index is greater than half the length of the list
  - Loop through the list starting from the tail and loop towards the middle
  - Return the node once it is found

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  get(index) {
    if (index < 0 || index >= this.length) return null;

    let count, current;
    if (index <= Math.floor(this.length / 2)) {
      count = 0;
      current = this.head;
      while (count !== index) {
        current = current.next;
        count++;
      }
    } else {
      count = this.length - 1;
      current = this.tail;
      while (count !== index) {
        current = current.prev;
        count--;
      }
    }

    return current;
  }
}
```

### set 메서드

Replacing the value of a node to the in a Doubly Linked List

#### Set pseudocode

- Create a variable which is the result of the **get** method at the index passed to the function
  - If the **get** method returns a valid node, set the value of that node th be the value passed to the function
  - Return true
- Otherwise, return false

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  set(index, val) {
    const foundNode = this.get(index);
    if (foundNode) {
      foundNode.val = val;
      return true;
    }
    return false;
  }
}
```

### insert 메서드

Adding a node in a Doubly Linked List by a certain position

#### Insert pseudocode

- If the index is less than zero or greater than or equal to the length return false
- If the index is 0, **unshift**
- If the index is the same as the length, **push**
- Use the **get** method to access the index - 1
- Set the next and prev properties on the correct nodes to link everything together
- Increment the length
- Return true

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  insert(index, val) {
    if (index < 0 || index > this.length) return false;
    if (index === 0) return !!this.unshift(val);
    if (index === this.length) return !!this.push(val);

    const newNode = new Node(val);
    const beforeNode = this.get(index - 1); // 중간에 넣어야 하기 때문에 index - 1
    const afterNode = beforeNode.next; // 새로운 노드 뒤에 올 afterNode
    (beforeNode.next = newNode), (newNode.prev = beforeNode); // 새로운 노드와 beforeNode 관계
    (newNode.next = afterNode), (afterNode.prev = newNode); // 새로운 노드와 afterNode 관계
    this.length++;

    return true;
  }
}
```

### remove 메서드

Removing a node in a Doubly Linked List by a certain position

#### Remove pseudocode

- If the index is less than zero or greater than or equal to the length return undefined
- If the index is 0, **shift**
- If the index is the same as the length - 1, **pop**
- Use the **get** method to retrieve the item to be removed
- Update the next and prev properties to remove the found node from the list
- Set next and prev to null on the found node
- Decrement the length
- Return the removed node

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  remove(index) {
    if (index < 0 || index >= this.length) return undefined;
    if (index === 0) return this.shift();
    if (index === this.length - 1) return this.pop();

    const removedNode = this.get(index);
    const beforeNode = removedNode.prev;
    const afterNode = removedNode.next;
    beforeNode.next = afterNode; // removedNode.prev.next = removedNode.next;
    afterNode.prev = beforeNode; // removedNode.next.prev = removedNode.prev;
    removedNode.prev = null;
    removedNode.next = null;
    this.length--;

    return removedNode;
  }
}
```

### Big O of Doubly Linked Lists

- Insertion - O(1)
- Removal - O(1)
- Searching - O(n)
- Access - O(n)
- Technically searching is **O(n / 2)**, but that's **still O(n)**

### Recap

- Doubly Linked Lists are almost identical to Singly Linked Lists except there is an additional pointer to previous nodes
- Better than Singly Linked Lists for finding nodes and can be done in half the time!
- However, they do take up more memory considering the extra pointer
