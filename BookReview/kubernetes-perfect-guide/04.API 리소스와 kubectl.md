# 4장 API 리소스와 kubectl

# 4.1 이 책을 읽기 위한 준비

- 쿠버네티스 환경: Google Kubernetes Engine(GKE), 일부 kind(Kubernetes in Docker)를 사용
- 쿠버네티스 버전: 1.18.16-gke.2100(kind의 경우: 1.18.15)
- kubectl 버전: v.18.16

### 쿠버네티스 환경과 버전

<img width="1447" alt="01" src="https://github.com/user-attachments/assets/0810110f-24f4-45d0-be55-01069f2e6448">

## 4.1.1 kubectl 설치와 자동 완성 기능 설정

```bash
# 맥 운영체제의 경우
OS_TYPE=Darwin
# 리눅스의 경우
OS_TYPE=linux

# kubectl버전
VERSION=1.18.16

#kubectl 설치
curl -o https://storage.googleapis.com/kubernetes-release/release/v${VERSION}/bin/${OS_TYPE}/amd64/kubectl
chmod +x kubectl
sudo mv kubectl /usr/local/bin/kubectl
```

## 4.1.2 쿠버네티스(GKE) 클러스터 생성

```bash
# GKE에서 사용 가능한 쿠버네티스 버전 확인
gcloud container get-server-config --zone asia-northeast3-a
```

<img width="861" alt="02" src="https://github.com/user-attachments/assets/d5be628a-15f5-4fab-95fa-9aa62ea3a4a3">

```bash
# GKE클러스터 'k8s' 생성
gcloud container clusters create k8s \
--cluster-version 1.30.3-gke.1451000 \ # validMasterVersion에 있는 쿠버네티스 버전 지정
--zone asia-northeast3-a \ # 존 설정
--num-nodes 3 \ # 노드 수
--machine-type n1-standard-4 \ # 인스턴스 유형 지정
--enable-network-policy \ # 네트워크 정책 기능 활성화
--enable-vertical-pod-autoscaling # VerticalPodAutoscaler활성화

gcloud container clusters create k8s --cluster-version 1.30.3-gke.1451000  --zone asia-northeast3-a --num-nodes 3 --machine-type n1-standard-4 --enable-network-policy --enable-vertical-pod-autoscaling
```

GKE 클러스터에 대한 권한을 다시 가져오는 경우 다음 명령어를 실행한다.

```bash
# GKE클러스터 'k8s'에 접속하는 인증 정보를 다시 가져오는 방법
gcloud container clusters get-credentials k8s --zone asia-northeast3-a

# 알파 기능을 활성화한 클러스터 'k8s-alpha' 생성
# 알파 기능을 활성화한 클러스터는 30일 후에 삭제되는 점을 주의하자.
gcloud container clusters create k8s-alpha \
--cluster-version 1.30.3-gke.1451000 \ # validMasterVersion에 있는 쿠버네티스 버전 지정
--zone asia-northeast3-a \ # 존 설정
--num-nodes 3 \ # 노드 수
--machine-type n1-standard-4 \ # 인스턴스 유형 지정
--enable-network-policy \ # 네트워크 정책 기능 활성화
--enable-vertical-pod-autoscaling \ # VerticalPodAutoscaler활성화
--enable-kubernetes-alpha \ # 쿠버네티스 알파 기능의 활성화
--no-enable-autorepair --no-enable-autoupgrade # 알파 기능을 활성화하기 때문에 일부 기능은 비활성화
```

구글 계정 ‘SOMEUSER@gmail.com’이 관리자 권한으로 쿠버네티스 클러스터를 관리할 수 있도록 다음 명령어를 실행해 두자. 구글 계정은 관리자 권한으로 관리하고 싶은 계정을 지정해야 한다. 자세한 내용은 13장 RBAC 관련 부분에서 설명한다.

```bash
# 사용자에게 모든 리소스의 접속 권한을 부여
kubectl create clusterrolebinding user-cluster-admin-binding \
--clusterrole=cluster-admin \
--user=SOMEUSER@gmail.com
```

GKE를 포함한 GCP에는 기본으로 300달러의 크레딧을 제공하는 무료 등급이 있다. 처음에는 무료 등급을 사용하여 테스트를 진행해도 좋다. 쿠버네티스 노드에 사용되는 GCE는 비교적 종량에 대한 과금 단가가 비싸기 때문에 사용 후 불필요한 클러스터는 삭제해 두는 것이 좋다.

```bash
# GKE클러스터 'k8s' 삭제
gcloud container clusters delete k8s --zone asia-northeast3-a
```

# 4.2 쿠버네티스 기초

<img width="931" alt="03" src="https://github.com/user-attachments/assets/64419cd2-02bd-4f3c-8115-f1be51b76b91">

쿠버네티스는 쿠버네티스 마스터와 쿠버네티스 노드로 구성되어 있다. 쿠버네티스 마스터는 API 엔드포인트 제공, 컨테이너 스케줄링, 컨테이너 스케일링 등을 담당하는 노드다. 그리고 쿠버네티스 노드는 이른바 도커 호스트에 해당하며 실제 컨테이너를 기동시키는 노드이다.

쿠버네티스 클러스터를 관리하려면 CLI 도구인 kubectl과 YAML 형식이나 JSON 형식으로 작성된  매니페스트 파일을 사용하여 쿠버네티스 마스터에 ‘리소스’를 등록해야 한다. 매니페스트 파일은 가독성을 고려하여 YAML 형식으로 작성하는 것이 일반적이며 확장자(.yaml, .yml, .json)로 구분된다.

kubtctl은 매니페스트 파일 정보를 바탕으로 쿠버네티스 마스터가 가진 API에 요청을 보내어 쿠버네티스를 관리한다.

쿠버네티스 API는 일반적으로 RESTful API로 구현되어 있다. 따라서 kubectl을 사용하지 않고 각종 프로그램 언어의 RESTful API 라이브러리나 curl 등의 명령어 도구를 사용하여 직접 API를 호출함으로써 쿠버네티스를 관리할 수도 있다.

### kubectl

kubectl은 Kubernetes 클러스터를 제어하기 위한 커맨드 라인 인터페이스 도구로 kubectl을 사용하면 쿠버네티스 클러스터 내의 다양한 리소스들을 생성, 삭제 수정 및 관리할 수 있다. kubectl은 쿠버네티스 API 서버와 통신하여 쿠버네티스 객체(오브젝트)를 생성하고 관리한다. 예를 들어, kubectl을 사용하여 파드, 디플로이먼트, 서비스 등의 쿠버네티스 객체를 생성하고 관리할 수 있다.

또한, kubectl은 쿠버네티스 클러스터의 상태를 확인하고, 로그를 검색하고, 디버깅 및 문제 해결에 유용한 정보를 제공하는 등 다양한 기능을 제공한다.

# 4.3 쿠버네티스와 리소스

쿠버네티스를 관리하기 위해 등록하는 ‘리소스’는 컨테이너의 실행과 로드 밸런서 생성 등 많은 종류가 있다. 리소스는 크게 다섯 가지 카테고리로 분로된다. 쿠버네티스는 이러한 리소스 등록을 비동기로 처리할 수 있다.

- 워크로드 API 카테고리
    - 컨테이너 실행에 관련된 리소스
- 서비스 API 카테고리
    - 컨테이너를 외부에 공개하는 엔드포인트를 제공하는 리소스
- 컨피그 & 스토리지 API 카테고리
    - 설정/기밀 정보/영구 볼륨 등에 관련된 리소스
- 클러스터 API 카테고리
    - 보안이나 쿼터 등에 관련된 리소스
- 메타데이터 API 카테고리
    - 클러스터 내부의 다른 리소스를 관리하기 위한 리소스

## 4.3.1 워크로드 API 카테고리

워크로드(Workload) API 카테고리는 클러스터 위에서 컨테이너를 기동하기 위해 사용되는 리소스다. 내부적으로 사용되는 것을 제외하고 사용자가 직접 관리할 수 있는 것으로 총 여덟 가지 종류의 워크로드 리소스가 있다.

- 파드(Pod)
- 레플리케이션 컨트롤러(ReplicationController)
- 레플리카셋(ReplicaSet)
- 디플로이먼트(Deployment)
- 데몬셋(DaemonSet)
- 스테이트풀셋(StatefulSet)
- 잡(Job)
- 크론잡(CronJob)

## 4.3.2 서비스 API 카테고리

서비스 API 카테고리는 커넽이버 서비스 디스커버리와 클러스터 외부에서도 접속이 가능한 엔드포인트 등을 제공하는 리소스다. 내부적으로 사용되는 것을 제외하고 사용자가 직접 관리할 수 있는 리소스로 서비스와 인그레시ㅡ(Ingress)라는 두 종류의 서비스 API 카테고리가 있다. 서비스에는 엔드포인트 제공 방식이 다른 여러 타입이 준비되어 있다.

- 서비스
    - ClusterIP
    - ExternalIP(ClusterIP의 한 종류)
    - NodePort
    - LoadBalancer
    - Headless(None)
    - ExternalName
    - None-Selector
- 인그레스

## 4.3.3 컨피그 & 스토리지 API 카테고리

세 번째, 컨피그 & 스토리지(Config & Storage) API 카테고리는 설정과 기밀 데이터를 컨테이너에 담거나 영구 볼륨을 제공하는 리소스다. 시크릿과 컨피그맵은 모두 키-밸류 형태의 데이터 구조로 되어 있고, 저장할 데이터가 기밀 데이터인지 일반적인 설정 정보인지에 따라 구분된다. 영구 볼륨 클레임은 컨테이너에서 영구 볼륨을 요청할 때 사용한다.

- 시크릿(Secret)
- 컨피그맵(ConfigMap)
- 영구 볼륨 클레임(PersistentVolumeClaim)

## 4.3.4 클러스터 API 카테고리

클러스터(Cluster) API 카테고리는 클러스터 자체 동작을 정의하는 리소스다. 보안 관련 설정이나 정책, 클러스터 관리성을 향상시키는 기능을 위한 리소스 등 여러 리소스가 있다.

- 노드(Node)
- 네임스페이스(Namespace)
- 영구 볼륨(PersistentVolume)
- 리소스 쿼터(ResourceQuota)
- 서비스 어카운트(ServiceAccount)
- 롤(Role)
- 클러스터 롤(ClusterRole)
- 롤바인딩(RoleBinding)
- 클러스터롤바인딩(ClusterRoleBinding)
- 네트워크 정책(NetworkPolicy)

## 4.3.5 메타데이터 API 카테고리

메타데이터(Metadata) API 카테고리는 클러스터 내부의 다른 리소스 동작을 제어하기 위한 리소스다. 예를 들어, 파드를 오토 스케일링시키기 위해 사용하는 HorizontalPodAutoscaler(HPA)는 디플로이먼트 리소스를 조작해 레플리카 수를 변경함으로써 오토 스케일링을 구현한다.

- LimitRange
- HorizontalPodAutoscaler(HPA)
- PodDisruptionBudget(PDB)
- 커스텀 리소스 데피니션(CustomResourceDefinition)

# 4.4 네임스페이스로 가상적인 클러스터 분리

쿠버네티스에는 네임스페이스(Namespace)라고 불리는 가상적인 쿠버네티스 클러스터 분리 기능이 있다. **하나의 쿠버네티스 클러스터를 여러 팀에서 사용하거나 서비스 환경/스테이징 환경/개발 환경으로 구분하는 경우** 사용할 수 있다.

기본 설정에서는 다음 네 가지 네임스페이스가 생성된다.

- kube-system
    - 쿠버네티스 클러스터 대시보드 같은 시스템 구성 요소와 애드온이 배포하기 위해 생성되는 네임스페이스
- kube-public
    - 모든 사용자가 공통으로 사용하는 설정값 등을 저장하기 위해 컨피그맵 등을 배치하는 네임스페이스
- kube-node-lease
    - 노드 하트비트 정보가 저장하기 위한 Lease 리소스가 저장되는 전용 네임스페이스
    - 해당 네임스페이스는 클러스터 관리자 이외에는 그다지 신경쓰지 않아도 된다.
- default
    - 기본 네임스페이스로 사용자가 임의의 리소스를 등록하는 데 사용할 수 있다.

관리형 서비스나 구축 도구로 구축된 경우 대부분의 쿠버네티스 클러스터는 RBAC(Role-Based Access Control)가 기본값으로 활성화되어 있다. 네임스페이스만으로는 높은 분리성을 확보하기 어렵지만 RBAC나 네트워크 정책을 사용하면 분리성을 높일 수 있다.

네임스페이스 분리 범위에 대해서는 권한 분리 관점에서 마이크로서비스를 개발하는 팀마다 분리하는 것이 좋다. 또 서비스 환경/스테이징 환경/개발 환경을 네임스페이스로 분리하는 시스템도 있지만, 네임스페이스가 아닌 클러스터별로 나눠야 하는 것이 좋은데 그 이유는 아래와 같다.

- 클러스터 업그레이드 시 동시에 모든 환경에서 장애가 발생할 가능성이 있다.
- 네임스페이스 명명 규칙이 prd-nsl/stg-nsl처럼 되면 매니페스트 재사용성이 현저하게 저하된다. 클러스터를 분리하면 각 환경에서 같은 네임스페이스 이름을 사용할 수 있기 때문에 완전히 같은 매니페스트를 재사용할 수 있다.
- 서비스 이름 해석 시 SERVICE.prd-nsl.svc.cluster.local 등의 다른 목적지에 통신을 해야 한다.

# 4.5 커맨드 라인 인터페이스(CLI) 도구 kubectl

쿠버네티스에서 클러스터 조작은 모두 쿠버네티스 마스터의 API를 통해 이루어진다. 직접 API에 요청을 보내거나 클라이언트 라이브러리를 사용하여 클러스터를 조작할 수도 있지만, 수동으로 조작하는 경우에는 CLI 도구인 ‘kubectl’을 사용하는 것이 일반적인다.

## 4.5.1 인증 정보와 컨텍스트(config)

kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요하다. kubectl은 kubeconfig(기본 위치는 ~/.kube/config)에 쓰여 있는 정보를 사용하여 접속한다. kubeconfig도 매니페스트와 동일한 형식으로 작성된다.

```yaml
apiVersion: v1
kind: Config
preferences: {}
clusters: # 접속 대상 클러스터
	- name: sample-cluster
		cluster:
			server: https://localhost:6443
users: # 인증 정보
	- name: sample-user
		user:
			client-certificate-data: A93SDksk22Rds...
			client-key-data: A93SDksk22Rds...
contexts: # 접속 대상과 인증 정보 조합
	- name: sample-context
		context:
			cluster: sample-cluster
			namespace: default
			user: sample-user
current-context: sample-context
```

<img width="1432" alt="04" src="https://github.com/user-attachments/assets/d2cf8ded-1790-416b-8c0f-0142386ca11b">

kubeconfig에서 구체적으로 설정이 이루어지는 부분은 clusters, users, contexts 세 가지다. 이 세 가지 항목은 모두 배열로 되어 있어 여러 대상을 등록할 수 있다.

- clusters: 접속 대상 클러스터 정보 정의
- users: 인증 정보 정의
    - 사용자 인증에는 X.509 클라이언트 인증서, 토큰, 패스워드, 웹훅 등 다양한 방식을 사용할 수 있다.
- contexts: cluster와 user, 네임스페이스를 지정한 것을 정의

```bash
# 클러스터(prd-cluster) 정의를 추가, 변경
kubectl config set-cluster prd-cluster --server=https://localhost:6443

# 인증 정보 정의를 추가, 변경
kubectl config set-credentials admin-user \
--client-certificate=./sample.crt \
--client-key=./sample.key \
--embed-certs=true

# 컨텍스트 정의(클러스터/인증 정보/네이미스페이스 정의)를 추가, 변경
kubectl config set-context prd-admin \
--cluster=prd-cluster \
--user=admin-user \
--namesapce=default
```

kubeconfig 설정을 변경하려면 직접 편집하는 방법 외에 kubectl 명령어를 사용할 수 있다. kubectl 명령어로 설정을 변경한 경우 kubeconfig 내용은 자동으로 변경된다.

```bash
# 컨텍스트 목록 표시
kubectl config get-contexts

# 컨텍스트 전환
kubectl config use-context prd-admin

# 현재 컨텍스트 표시
kubectl config current-context

# 명령어 실행마다 컨텍스트 지정 가능
kubectl --context prd-admin get pod
```

kubectl은 컨텍스트(current-context)를 전황하여 여러 환경을 여러 권한으로 조작할 수 있도록 설계되어 있다.

## 4.5.2 kubects/kubens를 사용한 전환

```bash
# 컨텍스트 전환
# kubectl config use-context docker-desktop과 동일
kubectx docker-desktop

# 바로 전 컨텍스트로 전환
kubectx -

# 다시 컨텍스트 전환
kubectx docker-desktop

# 컨텍스트 ㅅ학제
kubectx -d prd-admin

# 네임스페이스 전환
# kubectl config set-context docker-desktop --namesapce=default와 동일
kubens default
```

컨텍스트나 네임스페이스를 전환할 때 kubectl 명령어를 사용하는 것이 불편하다면 오픈소스 소프트웨어인 kubectx/kubens를 사용하는 것을 검토하자.

## 4.5.3 매니페스트와 리소스 생성/삭제 생신

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: sample-pod
spec:
  containers:
  - name: nginx-container
    image: nginx:1.16
    ports:
    - containerPort: 80
```

kubectl을 사용하여 실제 매니페스트를 기반으로 컨테이너를 기동해보자. 여기서는 하나의 컨테이너를 가진 파드를 sample-pod라는 이름으로 생성해보겠다.

```bash
# 1. 파드 생성, 리소스가 있을 경우에 에러 발생
kubectl create -f sample-pod.yaml

# 2. 파드 목록 표시
kubectl get pods

# 3. (매니페스트 파일로) 파드 삭제, 리소스가 존재하지 않을 경우 에러 발생
kubectl delete -f sample-pod.yaml

# 4. (매니페스트 파일이 아닌) 특정 리소스만 삭제
kubectl delete pod sample-pod

# 5. 특정 리소스 종류를 모두 삭제
kubectl delete pod --all

# 6. 리소스 삭제(삭제 완료 대기)
# kubectl 명령어 실행은 바로 완료되지만, 쿠버네티스에 의한 실제 리소스 처리는 비동기로 실행되어
# 처리가 바로 완료되지 않기 때문에 --wait 옵션을 사용하면 처리 완료를 기다렸다가 명령어 실행을 종료할 수 있다.
kubectl delete -f sample-pod.yaml --wait

# 7. 리소스 즉시 강제 삭제
# --grace-period: 정지까지 유예 기간 옵션
# --force: 강제 삭제 옵션
kubectl delete -f sample-pod.yaml --grace-period 0 --force

# 8. 리소스 업데이트
# sample-pod 생성
kubectl create -f sample-pod.yaml

# sample-pod.yaml 파일을 sample-pod.yaml.old로 백업
cp -av sample-pod.yaml{,.old}

# 일부 수정한 sample-pod.yaml 변경 사항
diff sample-pod.yaml.old sample-pod.yaml
8c8
< image: nignx:1.16
---
> image: nginx:1.17

# 변경 사항이 있을 경우, 리소스가 존재하지 않을 경우에는 생성
kubectl apply -f sample-pod.yaml

# sample-pod에서 사용 중인 이미지 확인
kubectl get pod sample-pod -o jsonpath="{.spec.containers[?(@.name == 'nginx-container')].image}"
```

## 4.5.4 리소스 생성에도 kubectl apply를 사용해야 하는 이유

1. 생성에는 kubectl create를 사용하고 업데이트 때는 kubectl apply를 사용해야 한다는 구분이 불필요하기 때문이다. 스크립트나 CI/CD 등에 포함될 것을 생각하면 조건 분기는 하지 않는 것이 좋다.
2. kubectl create와 kubectl apply를 섞어서 사용하면 kubectl apply를 실행할 때 변경 사항을 검출하지 못할 경우가 있기 때문이다. kubectl apply로 적용된 변경 사항은 이전에 적용한 매니페스트, 현재 클러스터에 등록된 리소스 상태, 이번에 적용할 매니페스트 이렇게 세 종류에서 산출된다.
이번에 추가되거나 변경될 필드는 현재 리소스 상태와 이번에 적용할 매니페스트를 비교하여 산출된다.
반면에 삭제된 필드는 이전에 적용한 매니페스트와 이번에 적용할 매니페스트를 기준으로 산출한다.
따라서 리소스 생성은 kubectl create가 아닌 항상 kubectl apply를 사용할 것을 추천한다.
    
<img width="1464" alt="05" src="https://github.com/user-attachments/assets/265db43a-33f9-489b-a558-12c9f4273efe">

## 4.5.5 Server-side apply

쿠버네티스에서는 사용자가 사용하는 kubectl 외에 다양한 시스템 구성 요소가 리소스 필드를 자동으로 수정할 수 있다. 현재 변경 사항의 산출은 클라이언트 측(kubectl)에서 계산하여 패치 요청을 보내기 때문에 여러 사용자나 구성 요소가 동시에 같은 필드를 변경하는 경우 경합 현상이 발생할 수 있다. 이 문제를 해결하기 위해 필드를 변경한 구성 요소를 기록하는 기능과 서버 측에서 변경 사항을 계산하는 기능이 도입되었다.

```bash
# 앞서 변경한 sample-pod.yaml 파일을 기존의 내용으로 복원
cp -av sample-pod.yaml{.old,}

# Server-side apply를 활성화하여 매니페스트 생성
kubectl apply -f sample-pod.yaml --server-side

# 이미지 변경
kubectl set image pod sample-pod nginx-container=nginx:1.17

# Server-side apply를 활성화하여 매니페스트 적용
kubectl apply -f sample-pod.yaml --server-side

# 충돌(conflict)를 무시하고 강제로 매니페스트 적용
kubectl apply -f sample-pod.yaml --server-side --force-conflict
```

클라이언트 측에서 server-side apply를 활성화하려면 --server-side 옵션을 사용한다. Server-side apply는 충돌 감지만 하기 때문에 실제 충돌이 발생할 때는 별도로 충돌 내용을 해결해야만 한다.

Server-side apply 구조는 충돌 감지와 변경 사항 감지를 위한 필드를 관리하는 것으로 구현된다. 필드를 관리하는 구성 요소를 manager라고 부르며, metadata.managedFields에 manager와 manager가 관리하는 필드가 저장된다.

## 4.5.6 파드 재기동

디플로이먼트 등의 리소스와 연결되어 있는 모든 파드를 재기동할 수 있다(rollout restart). 파드 기동 시 처리를 재실행하고 싶을 때나 시크릿 리소스에서 참조되는 환경 변수를 변경하고 싶을 때 사용하면 좋다. 그러나 리소스와 연결되어 있지 않은 단독 파드에는 사용할 수 있다.

```bash
# 리소스 생성
kubectl apply -f sample-deployment.yaml
kubectl apply -f sample-pod.yaml

# Deployment리소스의 모든 파드 재기동
kubectl rollout restart deployment sample-deployment

# 파드는 재기동 안 됨
kubectl rollout restart pdo sample-pod
```

## 4.5.7 generateName으로 임의의 이름을 가진 리소스 생성

```yaml
apiVersion: v1
kind: Pod
metadata:
  generateName: sample-generatename-
spec:
  containers:
  - name: nginx-container
    image: nginx:1.6
```

<img width="1115" alt="06" src="https://github.com/user-attachments/assets/b8543349-6c76-492a-9812-1d8ea82c30d9">

kubectl apply 명령어를 사용하는 것이 바람직하지만, kubectl create를 사용하여 난수가 있는 이름의 리소스를 생성할 수 있다. [metadata.name](http://metadata.name) 대신 metadata.generateName을 지정하고 리소스를 생성하면 그 이름에 접두사를 붙여 이름이 자동으로 생성된다.

<img width="1075" alt="07" src="https://github.com/user-attachments/assets/a8b43479-6454-4498-be66-3c5810393da9">

metadata.generateName은 kubectl apply에서 사용할 수 없으므로 주의하자.

## 4.5.8 리소스 상태 체크와 대기(wait)

```yaml
# 먼저 위처럼 파드를 세 개 생성
kubectl create -f sample-generatename.yaml
kubectl create -f sample-pod.yaml

# sample-pod가 정상적으로 기동할 때(Ready 상태가 될 때)까지 대기
kubectl wait --for=condition=Ready pod/sample-pod

# 대상 리소스 지정에는 매니페스트 파일을 사용할 수도 있다.
# 그러나 하나의 매니페스트 파일에 여러 리소스가 작성된 경우에는 모든 리소스가 지정한느 상태가 될 때까지 대기한다.
# 특정 리소스만 대상으로 하고 싶은 경우에는 나중에 설명하는 레이블을 사용하여 --selector /-l 옵션으로 제어해야 한다.
kubectl wait --for=condition=Ready -f sample-pod.yaml

# 모든 파드가 스케줄링될 때(PodScheduled 상태가 될 때)까지 대기
kubectl wait --for=condition=PodScheduled pod --all

# 모든 파드가 삭제될 때까지 파드마다 최대 5초씩 대기한다. 아직 파드를 삭제하지 않으므로 타임아웃한다.
kubectl wait --for=delete pod --all --timeout=5s

# 모든 파드를 삭제한 후 곱다로 kubectl wait를 실행
kubectl delete pod --all --wait=false
# 모든 파드가 삭제될 때까지 대기
kubectl wait --for=delete pod --all
```

<img width="1375" alt="08" src="https://github.com/user-attachments/assets/46c6f537-b98a-4412-ad8c-8e53f5400384">

<img width="1404" alt="09" src="https://github.com/user-attachments/assets/c173ce96-c4a2-4f4a-8081-56db5e063dd4">

kubectl 명령어를 연속적으로 실행하여 리소스를 조작할 때는 다음 명령어를 실행하기 전에 그때까지 작업한 리소스가 의도한 상태가 된 후 다음 명령어를 실행해야 하는 경우가 있다. 이때 사용할 수 있는 것이 `kubectl wait` 명령어이다.

실행하면 --for 옵션에 지정한 상태까지 되기까지 kubectl 명령어가 최대 --timeout 옵션에 지정하는 시간(기본값 30초)까지 종료하지 않고 대기한다.

## 4.5.9 매니페스트 파일 설계

### 하나의 매니페스트 파일에 여러 리소스를 정의

매니페스트 파일은 여러 리소스를 한 개의 매니페스트 파일에 정의할 수 있다. 따라서 어떤 서비스에서 사용할 여러 종류의 리소스를 한 개의 매니페스트 파일로 통합할 수도 있다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order1-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: sample-app
  template:
    metadata:
      labels:
        app: sample-app
    spec:
      containers:
      - name: nginx-container
        image: nginx:1.16
---
apiVersion: av1
kind: Servoce
metadata:
  name: order2-deployment
spec:
  type: LoadBalancer
  ports:
  - name: "http-port"
    protocal: "TCP"
    port: 8080
    targetPort: 80
  selector:
    app: sample-app
```

일반적인 사용 사례로는 ‘파드를 기동한느 워크로드 API 카테고리의 리소스’와 ‘외부에 공개하는 서비스 API 카테고리의 리소스’를 매니페스트에 통합하여 작성하는 방법을 생각해볼 수 있다. 그러나 공통으로 사용하는 설정 파일(컨피그맵 리소스)이나 패스워드(시크릿 리소스) 등은 여러 리소스에서 사용되는 경우가 있다. 이렇게 공통으로 사용되는 리소스는 별도 매니페스트로 분리하는 것이 좋다.

<img width="1372" alt="10" src="https://github.com/user-attachments/assets/7c9854b6-a496-48d5-a450-6e36f73a872c">

```bash
# 여러 리소스가 정의된 매니페스트 적용
kubectl apply -f sample-multi-resource-manifest.yaml
```

매니페스트 파일 내의 일부 리소스 정의 부분에 문법 에러 등으로 문제가 발생한 경우, 이후에 정의된 리소스는 적용되지 않는다는 점에 주의해야 한다. 예를 들어 sample-multi-resource-manifest.yaml에 order-deployment 정의가 문제있을 경우 order2-service는 적용되지 않는다.

### 여러 매이페스트 파일을 동시에 적용

```bash
# 디렉터리 내부 확인
ls -R ./dir

# 디렉터리(디렉터리 아래에 있는 모든 YAML 파일)를 지정하여 리소스 생성
kubectl apply -f ./dir

# 지정한 디렉터리 내의 파일을 재귀적으로 적용
kubectl apply -f ./dir -R
```

`kubectl apply -f ./ -R`과 같이 -R 옵션을 사용하면 재귀적으로 디렉터리 안에 존재하는 매니페스트 파일을 적용할 수 있다. 파일명순으로 매니페스트 파일이 적용되기 때문에 순서를 제어하고 싶을 때는 파일명 앞에 연번의 인덱스 번호 등을 지정하여 사용하면 된다.

### 매니페스트 파일 설계 방침

매니 페스트 파일 설계는 규모나 요구 사항에 따라 적절한 방법을 선택할 수 있는 패턴들이 있다.

**시스템 전체를 한 개의 디렉터리로 통합하는 패턴**

<img width="994" alt="11" src="https://github.com/user-attachments/assets/0a571019-e08b-4ba2-ab88-df298367f66e">

아주 규모가 크지 않을 경우에는 시스템 전체를 구성하기 위한 모든 마이크로서비스의 매니페스트 파일을 하나의 디렉터리로 통합하여 사용면 좋다. 한 개의 매니페스트 파일을 적용하면 특정 마이크로서비스를 업데이트할 수 있고, 디렉터리를 지정하여 전체 마이크로서비스, 즉 시스템 전체를 업데이트할 수도 있다.

**시스템 전체를 특정 서브 시스템으로 분리하는 패턴**

<img width="986" alt="12" src="https://github.com/user-attachments/assets/82a6d287-3e2c-48c0-9a7d-e9635a06e143">

한 개의 디렉터리에 파일 통합이 어려울 정도로 거대한 시스템인 경우, 분리가 가능하다면 서브 시스템이나 부서별로 디렉터리를 나눠서 사용하는 것도 하나의 방법이다. 또한, 내부 정책에 따라 그룹핑이 필요한 경우 나눠서 관리해도 좋다.

**마이크로서비스별로 디렉터리를 나누는 패턴**

<img width="1209" alt="13" src="https://github.com/user-attachments/assets/ad3254dc-f321-48a2-85a9-4a7a5c8011e8">

각각의 마이크로서비스는 한 개의 매니페스트 파일로 모든 리소스를 관리해도 좋지만, 마이크로서비스마다 디렉터리로 구분하여 리소스 종류별로 파일을 생성할 수도 있다. 이 방법은 가독성이 높아진다는 장점이 있지만, 적용 순서 제어가 어렵다는 단점도 있다.

## 4.5.10 어노테이션과 레이블

쿠버네티스에는 각 리소스에 대해 어노테이션과 레이블이라는 메타데이터를 부여할 수 있다. 둘 다 쿠버네티스가 리소스를 관리할 때 사용한다는 점에서 비슷하지만 용도가 다르다.

- **어노테이션**: 시스템 구성 요소로 사용하는 메타데이터
- **레이블**: 리소스 관리에 사용하는 메타데이터

어노테이션과 레이블은 `[접두사]/키:값`으로 구성된다. 접두사 부분은 옵션으로, 지정하는 경우 DNS 서브 도메인 형식이어야 한다. 어노테이션과 레이블의 제약은 아래와 같다.

- 접두사: 253문자로 `[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*`
- 키 이름: 63문자로 `([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]`
- 값: 63문자로 `([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]?`

### 어노테이션

```yaml
apiVersion: v1
kind: Pod
metadata:
	name: sample-annotation
	annotations:
		annotation1: val1
		annotation2: "200"
spec:
	containers:
	- name: nginx-container
		image: nginx:1.16
```

어노테이션(annotation)은 위 yaml 파일처럼 metadata.annotations로 설정할 수 있는 메타데이터다. 쉽게 설명하자면, 어노테이션은 리소스에 대한 `메모` 같은 것으로 어떤 처리를 하는 시스템 구성 요소가 없을 경우에는 아무 일도 일어나지 않는다. 리소스에 의미를 가지지 않는 메모를 하고 싶을 경우에도 사용할 수 있고 값에 수치를 사용하는 경우는 큰따옴표(””)로 묶어야 한다.

```bash
kubectl apply -f sample-annotations.yaml

# 어노테이션 부여
kubectl annotate pods sample-annotations annotation3=val3

# 어노테이션 부여(덮어쓰기 허용)
kubectl annotate pods sample-annotations annotation3=val3-new --overwrite

# 어노테이션 확인
kubectl annotate pod sample-annotations -o json | jq .metadata.annotations

# 어노테이션 삭제
kubectl annotate pods sample-annotations annotation3-
```

어노테이션은 주로 다음 세 가지 용도로 사용된다.

- 시스템 구성 요소를 위한 데이터 저장
- 모든 환경에서 사용할 수 없는 설정
- 정식으로 통합되기 전의 기능을 설정

**시스템 구성 요소를 위한 데이터 저장**

<img width="1564" alt="14" src="https://github.com/user-attachments/assets/5b8f5ba8-fe54-47e9-9530-4af92be5769e">

위 사진처럼 [kubectl.kubernetes.io/last-applied-configuration도](http://kubectl.kubernetes.io/last-applied-configuration도) 어노테이션 중 하나다. **이 어노테이션은 이전에 적용한 매니페스트의 내용이 저장되어 있고 시스템 구성 요소가 리소스를 업데이트할 때 이 정보를 사용하여 업데이트한다**. 

이런 유형의 어노테이션은 매니페스트에 기술하고 리소스에 어노테이션을 부여하는 것이 아니라 시스템 구서 ㅇ요소가 자동으로 부여한다. 그 밖에도 파드의 버전 관리를 하는 Deployment 리소스에서는 버전 관리를 deployment.kubernetes.io/revision 어노테이션에 저장하거나 리소스를 업데이트할 때 실행한 kubectl 명령어의 상세 내용이 kubernetes.io/change-cause 어노테이션에 저장되기도 한다.

**모든 환경에서 사용할 수 없는 설정**

쿠버네티스는 GKE/AKS/EKS 등의 여러 환경에서 사용할 수 있다. 이런 환경 고유의 확장 기능이 구현되면, 그 설정에는 어노테이션을 사용하는 경우가 많다. 예를 들어, 쿠버네티스 클러스터의 파드에 대해 클러스터 외부에서 접속할 수 있도록 외부 로드 밸런서 등과 연계하는 서비스 리소스가 좋은 예다. 서비스 리소스를 생성하면 GKE에서는 Google Cloud Load Balancing(GCLB), EKS에서는 AWS Classic Load Balancer(CLB) 또는 Network Load Balancer(NLB)와 연계한다.

대부분의 경우 로드 밸런서와 연계하는 서비스 리소스는 외부에서 접속할 수 있도록 글로벌 IP 주소가 부여된 글로벌 엔드포인트가 생성된다. 그러나 GKE와 EKS는 어노테이션을 부여하면 로컬 IP 주소를 사용한 인터널 엔드포인트 생성도 가능하다.

**정식으로 통합되기 전의 기능을 설정**

최근에는 쿠버네티스 생태계가 많이 성숙한 덕분에 거의 보이지 않지만, 쿠버네티스에 공식적으로 통합되기 전의 실험적인 기능과 평가 중인 새로운 기능 설정을 어노테이션으로 사용하는 경우도 있다. 뒤에서 설명할 스토리지클래스(StorageClass)나 초기화 컨테이너(Init Container) 등의 설정도 이전에는 어노테이션으로 설정해야만 했다.

### 레이블

레이블(label)은 `metadata.labels`에 설정할 수 있는 메타데이터다. 쉽게 설명하면 **레이블은 리소스를 구분하기 위한 정보** 같은 것이다.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: sample-label
  labels:
    label1: val1
    label2: val2
spec:
  containers:
    - name: nginx-container
      image: nginx:1.16
```

```yaml
# kubectl로 레이블 직접 부여
kubectl label pods sample-label label3=val3

# 레이블 부여(덮어쓰기 허용)
kubectl label pods sample-label label3=val3-new --overwrite

# 레이블 확인
kubectl get pod sample-label -o json | jq .metadata.labels

# 레이블 삭제
kubectl label pods sample-label label3-
```

컨테이너는 하나의 프로세스와 거의 같은 아주 작은 리소스다. 또한, 파드도 여러 컨테이너로 이루어진 작은 리소스다. 쿠버네티스는 파드와 같이 작은 리소스를 대량으로 처리할 뿐만 아니라 다양한 리소스를 처리한다.

레이블은 이러한 수많은 리소스에 대해 동일한 레이블로 그룹핑하여 처리하거나 어떤 처리에 대한 조건으로 사용되기 때문에 리소스를 효율적으로 관리할 수 있는 구조를 가지고 있다.

레이블은 크게 다음과 같은 두 가지 용도로 사용된다.

- 개발자가 사용하는 레이블
- 시스템이 사용하는 레이블

**개발자가 사용하는 레이블**

<img width="1297" alt="15" src="https://github.com/user-attachments/assets/fac12675-dff8-4ea8-baee-d28f576a4952">

개발자가 많은 리소스를 효율적으로 관리하는데 레이블은 정말 유용하게 사용된다. 위 그림처럼 리소스에 부여된 레이블을 사용하여 대상 리소스를 필터링함으로써 운영할 수 있다.

```yaml
# label1=val1과 label2 레이블을 가진 파드를 표시
kubectl get pods -l label1=val1,label2

# 파드와 label1 레이블 표시
kubectl get pods -L label1

# label1 레이블을 가진 파드와 label2 레이블을 표시
kubectl get pods -l label1 -L label2

# --show-labels 옵션을 사용하여 모든 레이블을 표시
kubectl get pods --show-labels
```

**시스템이 사용하는 레이블**

<img width="1189" alt="16" src="https://github.com/user-attachments/assets/a167098d-83f1-4c53-90f8-88287744fe37">

레이블 자체는 단순한 키-밸류 값이지만, 실수로 레이블을 지정하면 레이블 값이 충돌하여 예상하지 못한 문제가 발생할 수도 있다. 위 그림처럼 `app: A`, `app: B`, `app: C`, `env: prd`, `env: stg`라는 총 다섯 가지 레이블이 지정된 파드가 일부 기동하고 있다고 가정하다.

파드 수를 유지하는 리소스(ReplicaSet)에서 레이블에 부여된 파드 수를 계산하여 레플리카 수를 관리하기 때문에 대상 파드 수가 레플리카 수의 설정보다 많은 경우 파드 중 하나를 삭제할 수 있기 때문에 이미 기동 중인 파드가 정지하는 문제가 발생할 수도 있다.

마찬가지로 외부의 요청을 로드 밸런서로 받은 후에 파드로 전송하는 서비스 리소스(LoadBalancer)에서는 이 레이블을 기준으로 목적지 파드를 결정한다. 리소스에 대해 레이블을 여러 개 지정할 수 있기 때문에 위 그림처럼 유연하게 조건을 설정할 수 있다. `env: stg` 레이블을 가지고 `app: B` 또는 `app: C` 레이블을 가진 파드에 트래픽을 전송할 수 있다. 이 경우에도 실수로 레이블을 지정하게 되면 다른 파드에 트래픽이 전송되어 문제가 발생할 수 있다.

위 내용을 참고하여 처음부터 레이블을 지정할 정책을 정하고, 다음과 같이 몇 가지 레이블을 지정해 두는 것이 좋다.

- 프로젝트
- 애플리케이션 종류
- 애플리케이션 버전
- 환경

또한, 쿠버네티스에서는 다양한 에코시스템에서 공통화하기 위해 키 이름으로 레이블을 지정할 것을 권장하고 있다. 쿠버네티스의 에코시스템을 구성하는 OSS에서도 이 방법에 따라 레이블이 지정되는 경우가 증가하고 있으므로 레이블 지정에 참고하는 것이 좋다.

- `app.kubernetes.io/name`
    - 애플리케이션 이름
- `app.kubernetes.io/version`
    - 애플리케이션 버전
- `app.kubernetes.io/component`
    - 애플리케이션 내 구성 요소
- `app.kubernetes.io/part-of`
    - 애플리케이션이 전체적으로 구성하는 시스템 이름
- `app.kuberenetes.io/instance`
    - 애플리케이션이나 시스템을 식별하는 인스턴스명
- `app.kubernetes.io/managed-by`
    - 이 애플리케이션을 관리하는 데 사용되는 도구

## 4.5.1 Prune을 사용한 리소스 삭제: -prune 옵션

<img width="1033" alt="17" src="https://github.com/user-attachments/assets/91fd1eb2-8021-4659-8d14-07ee31d8c69f">

쿠버네티스를 실제 운용할 때 수동으로 `kubectl` 명령어를 실행하는 일은 거의 없다. 수동으로 운영하는 것은 휴먼 에러가 발생하기 쉽고, 사람이 파악하고 관리할 수 있는 리소스 수에 한계가 있기 때문에 권장하지 않는다. 해결책의 하나로 매니페스트를 깃(Git) 저장소에 관리하고 변경이 있을 때만 `kubectl apply` 명령어를 사용하여 자동으로 매니페스트를 적용시키는 방법 등을 들 수 있다. 그러나 매니페스트에서 삭제된 리소스를 삭제하는 데 필요한 `kubectl delete` 명령어를 자동으로 실행하려면 매니페스트에서 삭제된 리소스를 감지할 수 있는 구조를 만들어야 한다.

<img width="750" alt="18" src="https://github.com/user-attachments/assets/c541f252-88ff-4263-a2d5-d342f8376648">

여기서 필요한 것이 `kubectl apply` 명령어에서 사용 가능한 `--prune` 옵션이다. `kubectl apply` 명령어를 실행할 때 매니페스트에서 삭제된 리소스를 감지하여 자동으로 삭제하는 기능을 구현할 수 있다. 그래서 CI/CD 파이프라인에서는 업데이트된 매니페스트에 대해 `kubectl apply --prune` 명령어를 계속 실행하는 것만으로 매니페스트에서 삭제된 리소스도 자동으로 삭제할 수 있다. 그러나 `--prune` 옵션은 쿠버네티스 v1.18 시점에서 아직 알파 상태이며, 향후 후속 업데이트에 따라 사양이 변경되어 호환되지 않을 수 있으므로 주의가 필요하다.

**--prune 옵션을 사용한 매니페스트(prune-sample/sample-pod1/2.yaml)**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: sample-pod1
  labels:
    system: a
spec:
  containers:
    - name: nginx-container
      image: nginx:1.16
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: sample-pod2
  labels:
    system: a
spec:
  containers:
    - name: nginx-container
      image: nginx:1.16
```

```yaml
# 초기 생성
kubectl apply -f ./prune-sample --prune -l system=a

# 파일 삭제
rm prune-sample/sample-pod1.yaml

# sample-pod1.yaml이 삭제된 상태에서 다시 같은 명령어로 업데이트
kubectl apply -f ./prune-sample --prune -l system=a
```

<img width="1810" alt="19" src="https://github.com/user-attachments/assets/38eac45f-a6ef-498a-ac07-9ae04fdb035b">

위처럼 명령어를 실행하면 한쪽 매니페스트 파일이 삭제된 상태에서 `kubectl apply --prune`을 실행했을 때 그 매니페스트 파일에 기술되었던 리소스만 삭제된 것을 확인할 수 있다.

Prune은 삭제된 매니페스트 파일에 기술된 리소스를 삭제하는 것처럼 보이지만, 실제로는 레이블과 일치하는 전체 리소스의 목록에서 kubectl apply로 읽어들인 매니페스트 안에 ‘포함되지 않는 리소스’를 모두 삭제하는 구조로 동작한다. 레이블을 별도로 지정하지 않는 `--all` 옵션도 있지만, 이 옵션을 사용할 때 클러스터에 배포된 모든 리소스의 매니페스트를 읽어들이지 못한 리소스가 모두 삭제되기 때문에 주의해야 한다. 경우에 따라 클러스터의 거의 모든 리소스가 삭제될 수 있기 때문에 매우 위험하다. 따라서 기본적으로 레이블을 지정하여 Prune을 사용하는 것이 좋다. 정확하게는 Prune의 대상이 되는 리소스 조건으로 어노테이션에 [`kubectl.kubernetes.io/last-applied-configuration`이](http://kubectl.kubernetes.io/last-applied-configuration이) 포함되어 있어야 한다.

## 4.5.12 편집기로 편집: edit

```yaml
# 환경 변수 EDITOR에 vim을 일시적으로 정의(~/.bashrc 등에 추가하면 영구적으로 사용 가능)
export EDITOR=vim

# 파드 정의 편집(환경 변수 EDITOR에 정의된 편집기 실행)
kubectl edit pod sample-pod
```

kubectl edit 명령어를 사용하면 편집기상에서 변경 작업을 할 수 있다. 편집에 사용되는 편집기는 환경 변수 EDITOR 또는 KUBE_EDITOR로 지정할 수 있다. 지정하지 않을 경우 vi(윈도우 환경의 경우 notepad)가 사용된다.

## 4.5.13 리소스 일부 정보 업데이트: set

매니페스트 파일을 업데이트하지 않고 일부 설정값(또는 이 설정값을 가진 특정 리소스)만 `kubectl set` 명령어를 사용하여 간단히 동작 상태를 변경할 수 있따. 변경 가능한 설정값은 다음과 같다.

- env
- image
- resources
- selector
- serviceaccount
- subject

```yaml
# sample-pod 내 nginx-container 컨테이너의 컨테이너 이미지 확인
kubectl describe pod sample-pod

# 컨테이너 이미지 변경
kubectl set image pod sample-pod nginx-container=nginx:1.16

# sample-pod 내 nginx-container 컨테이너의 컨테이너 이미지 확인
# 변경된 것을 확인할 수 있다.
kubectl describe pod sample-pod
```

`kubectl set` 명령어로 직접 설정을 변경하더라도 가지고 있는 매니페스트 파일은 업데이트되지 않는다. 매니페스트 파일 내용과 서버상의 리소스 상태가 일치하지 않기 때문에 이 기능을 남용하지 않는 것이 좋다.

## 4.6.14 로컬 매니페스트와 쿠버네티스 등록 정보 비교 출력: diff

```yaml
# 컨테이너 이미지를 nginx:1.17로 변경
kubectl set image pod sample-pod nginx-container=nginx:1.17

# 클러스터 등록 정보와 매니페스트의 차이점 확인
kubectl diff -f sample-pod.yaml

# 상태 코드 확인
$ echo $?
```

<img width="1597" alt="20" src="https://github.com/user-attachments/assets/59de3fec-44f0-4d5c-94ca-6d90ea47f709">

쿠버네티스에서는 매니페스트를 적용(apply)할 때, ‘실제로 쿠버네티스 클러스터에 등록된 정보’와 ‘로컬에 있는 매니페스트’ 내용의 차이가 있는지 알 수 없다면 매니페스트를 적용하기가 힘들 수 있다. 예를 들어, 매니페스트를 변경하고 적용할 때 예상치 못한 변경이 없는지 등 적용 직전에 알고 싶은 내용이 많다.

위 예제는 `kubectl set` 명령어로 매니페스트를 수정하지 않고 클러스터에 등록된 설정을 변경한 후 실제 매니페스트 내용과의 차이를 출력한다. `kubectl diff` 명령어의 종료 코드는 ‘실제 클러스터에 등록된 정보’와 로컬에 있는 매니페스트 파일’간에 차이가 있으면 `을 반환하고, 차이가 없으면 0을 반환한다.

## 4.5.15 사용 가능한 리소스 종류의 목록 가져오기: api-resources

```yaml
# 모든 리소스 종류 표시(일부 발췌)
kubectl api-resources
```

<img width="1033" alt="21" src="https://github.com/user-attachments/assets/804822b5-ca79-40b5-b74f-9c68bee7eeb4">

쿠버네티스에는 파드나 서비스 등의 다양한 리소스 종류가 있다. `kubectl api-resources` 명령어로 사용 가능한 리소스 목록을 가져올 수 있다.

```yaml
# 네임스페이스에 속하는 리소스
kubectl api-resources --namespaced=true

# 네임스페이스에 속하지 않는 리소스
kubectl api-resources --namesapced=false
```

쿠버네티스에서 취급하는 리소스는 네임스페이스 수준의 리소스와 네임스페이스에 속하지 않는 클러스터 수준의 리소스, 두 종류가 있다. 예를 들어, 노드 리소스나 영구 볼륨 리소스는 클러스터 수준의 리소스로 등록되어 있으며 모든 네임스페이스에서 공유하여 사용할 수 있다. 반면에 파드 리소스나 영구 볼륨 클레임 리소스는 네임스페이스 수준의 리소스로 등록되어 있다.

## 4.5.16 리소스 정보 가져오기: get

`kubectl get` 명령어를 사용하면 리소스 목록을 가져올 수 있다. `get` 명령어는 인수에 `리소스 종류`, `리소스명(옵션)`을 지정한다. 리소스명이 저징되어 있을 경우에는 그 이름의 특정 리소스 정보만 가져온다.

```yaml
# 파드 목록 표시
kubectl get pods

# 특정 파드 정보만 표시
kubectl get pods sample-pod

# laber1=val1과 label2 레이블을 가진 파드를 표시
kubectl get pods -l label=val1, label2 --show-labels

# 파드 목록 표시(더 상세히 표시)
kubectl get pods -o wide

# YAML 형식으로 파드의 상세 정보 목록 출력
kubectl get pods -o yaml

# YAML 형식으로 특정 파드의 상세 정보 출력
kubectl get pods -o yaml sample-pod

# Custom Columns(모든 파드의 파드명과 기동 중인 호스트 IP 주소를 표시)
kubectl get pods -o custom-columns="NAME:{.metadata.name},NodeIP:{.status.hostIP}"
# NAME         NodeIP
# sample-pod   123.456.78.9

# JSON Path(sample-pod의 파드명 표시)
kubectl get pods sample-pod -o jsonpath="{.metadata.name}"

# ?(@.field == ") 형식으로 지정하여 배열에 특정 조건에 맞는 요소로 필터링
# .spec.containers[].name이 nginx-container에 일치하는 요소의 .spec.containers[].image를 출력
kubectl get pods sample-pod -o jsonpath="{.spec.containers[?(@.name =='nginx-container')].image}"

# Go Template(모든 파드의 이름과 파드 안에서 기동 중인 각 컨테이너 이미지를 표시)
kubectl get pods go-template="{{range .items}}{{.metadata.name}}: {{range .spec.containers}}{{.image}}{{end}} {{end}}"

# 노드 목록 표시
kubectl get nodes

# 생성된 거의 모든 종류의 리소스를 표시
kubectl get all

# 모든 리소스 목록을 가져옴(kubectl get configmaps, endpoints, events, limitranges, pod...가 실행됨)
kubectl get $(kubectl api-resources --namespaced=true --verbs=list -o name | tr '\n'
',' | sed -e 's|,$||g')

# --watch 옵션을 사용하여 리소스 상태의 변화가 있을 때 계속 결과를 출력할 수 있다.
kubectl get pods --watch

# --output-watch-events 옵션과 함께 사용하면 해당 리소스가 API처럼 어떤 처리가 되었는지
# 이벤트 정보(ADDED/MODIFIED/DELETED)를 함께 표시할 수 있다.
kubectl get pods --watch --output-watch-events
```

파드에 지정된 레이블을 기준으로 목록을 필터링할 수도 있다. `-l` 옵션은 필터링할 레이블을 지정하고, `--show-labels` 옵션은 지정한 레이블을 표시한다.

`--output(-o)` 옵션을 사용하면 JSON/YAML/Custom Columns/JSON Path/Go Template 등과 같은 다양한 형식으로 출력할 수도 있다.

## 4.5.17 리소스 상세 정보 가져오기: describe

```yaml
# 파드 상세 정보 표시
kubectl describe pod sample-pod

# 노드 상세 정보 표시
kubectl describe node minikube
```

`kubectl describe` 명령어를 사용하면 리소스의 상세 정보를 알 수 있다. 해당 명령어에 파드를 지정하면 Event 항목 아래에 볼륨 셋업이나 이미지 다운로드 상태 등 컨테이너 라이프사이클에 대한 정보가 표시된다.

그 외에도 노드를 지정한 경우 리소스 사용 현황이나 여유 리소스, 기동 중인 파드 리소스 사용량이 표시된다.

## 4.5.18 실제 리소스 사용량 확인: top

```yaml
# 노드 리소스 사용량 확인
kubectl top node

# 파드별 리소스 사용량 확인
kubectl -n kube-system top pod

# 파드 리스트 표시
kubectl -n kube-system get pods

# 컨테이너별 리소스 사용량 확인
kubectl -n kube-system top pod --containers
```

`kubectl describe` 명령어로 확인할 수 있는 리소스 사용량은 쿠버네티스가 파드에 확보한 값을 나타낸다. 실제 파드 내부의 컨테이너가 사용하고 있는 리소스 사용량은 `kubectl top` 명령어를 사용하여 확인할 수 있다. 리소스 사용량은 노드와 파드 단위로 확인한다.

## 4.5.19 컨테이너에서 명령어 실행: exec

```yaml
# 파드 내부의 컨테이너에서 /bin/ls 실행
kubectl exec -it sample-pod -- /bin/ls

# 여러 컨테이너에 존재하는 파드의 특정 컨테이너에서 /bin/ls 실행
kubectl exec -it sample-pod -c nginx-container -- /bin/ls

# 파드 내부의 컨테이너에서 /bin/bash 실행(종료하려면 exit 실행)
kubectl exec -it sample-pod -- /bin/bash

# 파이프 등 특정 문자가 포함된 경우 /bin/bash에 인수를 전달하는 형태로 전달
kubectl exec -it sample-pod -- /bin/bash -c "ls --all --classify | grep lib"
```

파드 내부의 컨테이너에서 특정 명령어를 실행하려면 kubectl exec 명령어를 사용한다. 이 명령어를 사용하여 `/bin/bash` 등의 셸을 실행함으로써 마치 컨테이너에 로그인한 것과 같은 상태를 만들 수 있다.

이 방법으로 가상 터미널을 생성(`-t`)하고, 표준 입출력을 패스스루(`-i`)하면서 `/bin/sh`를 기동하면 마치 컨테이너에 SSH로 로그인한 것과 같은 상태가 된다.

## 4.5.20 파드에 디버깅용 임시 컨테이너 추가: debug

```yaml
# sample-pod에 임의의 명령어로 디버깅용 컨테이너를 기동하여 접속
kubectl debug sample-pod --image=amsy810/tools:v2.0 -it -- bash

# sample-pod에 디버깅용 컨테이너를 기동하고 kubectl exec로 임의의 명령어 실행
kubectl debug sample-pod --image=amsy810/tools:v2.0 --container debug-container
kubectl exec -it sample-pod -c debug-container -- bash
```

컨테이너 이미지로 경량의 Distroless나 Scratch 이미지 등을 사용하는 경우 디버깅용 도구 등이 전혀 들어 있지 않기 때문에, 문제가 발생했을 때 `kubectl exec` 명령어를 사용하여 컨테이너 안으로 들어가도 디버깅을 수행하기가 어려울 수 있어 `kubectl debug` 명령어를 사용할 수 있다.

이 명령어는 파드에 추가 임시 컨테이너(Ephemeral Container)를 기동하고 그 컨테이너를 사용하여 디버깅이나 트러블 슈팅을 수행한다. `kubectl debug` 명령어로 사용되는 임시 컨테이너는 어디까지나 디버깅이나 트러블 슈팅 용도의 임시 컨테이너다. 따라서 자동 재기동/헬스 체크/라이프사이클/포트 설정 같은 일부 기능을 사용할 수 없다.

## 4.5.21 로컬 머신에서 파드로 포트 포워딩: port-forward

<img width="1186" alt="22" src="https://github.com/user-attachments/assets/66965e51-29ef-4949-bc71-6f7edd92b7b3">

디버깅 용도 등으로 JMX 클라이언트에서 컨테이너에서 실행 중인 자바 애플리케이션 서버에 접속하거나, 데이터베이스 클라이언트에서 컨테이너에서 기동 중인 MySQL 서버에 접속해야 할 경우가 있다. 그런 경우 `kubectl`을 실행하는 로컬 머신에서 특정 파드로 트래픽을 전송하는 `kubectl port-forward` 명령어를 사용할 수 있다.

```yaml
# localhost:8888에서 파드의 80/TCP 포트로 전송
kubectl port-forward sample-pod 8888:80

# 다른 터미널에서 접속 확인
curl -I localhost:8888

# 파드명이 아닌 디플로이먼트 리소스나 서비스 리소스에 연결된 파드에도 포트 포워딩 가능
kubectl port-forward deployment/sample-deployment 8888:80
kubectl port-forward service/sample-service 8888:80
```

## 4.6.22 컨테이너 로그 확인: logs

```yaml
# 파드 내의 컨테이너 로그 출력
kubectl logs sample-pod

# 여러 컨테이너가 존재하는 파드에서 특정 컨테이너 로그 출력
kubectl logs sample-pod -c nginx-container

# 실시간 로그 출력
kubectl logs -f sample-pod

# 최근 1시간 이내, 10건의 로그를 타임스탬프와 함께 출력
kubectl logs --since=1h --tail=10 --timestamps=true sample-pod

# app=sample-app 레이블을 가진 모든 파드의 로그 출력
kubectl logs --selector app=sample-app
```

기본적으로 컨테이너에서 기동하는 애플리케이션은 표준 출력과 표준 에러 출력으로 로그를 출력하는 것이 가장 좋단. 왜냐하면 표준 출력과 표준 에러 출력으로 출력된 컨테이너(애플리케이션) 로그는 `kubectl logs` 명령어를 사용하여 확인할 수 있기 때문이다. 여러 컨테이너가 있을 경우에는 하나의 컨테이너 로그만 출력할 수 있다. 또한 리눅스의 `tail -f` 명령어처럼 업데이트되는 내용이 실시간으로 표시되거나 타임스탬프 표시, 특정 기간 지정 등도 옵션으로 지정할 수 있다.

## 4.5.23 스턴을 사용한 로그 확인

오픈 소스 스턴을 사용하면 로그를 더욱 편리하게 출력할 수 있다. `kubectl logs` 명령어에서도 `--selector` 옵션을 사용하여 여러 파드의 로그를 확인할 수 있지만, 스턴을 이용하면 파드별로 로그를 색으로 구분하여 시각화해주며 하나의 콘솔에서 시계열로 표시할 수 있다.

스턴은 `kubectl logs`로 할 수 있는 모든 작업이 가능하고, 그 외에도 다음과 같이 편리한 기능을 제공한다.

- 각 컨테이너 로그를 시계열로 표시
- 타임스탬프 표시(`--timestamps` 옵션)
- 특정 레이블로 지정한 파드 로그만 표시(`--selector` 옵션)
- 예외 처리할 로그를 정규 표현식으로 지정 가능(`--exclude` 옵션)

## 4.5.24 컨테이너와 로컬 머신 간의 파일 복사: cp

```yaml
# sample-pod의 /etc/hostname 파일을 로컬 머신에 복사
kubectl cp sample-pod:etc/hostname ./hostname

# 가져온 로컬 파일을 컨테이너로 복사
kubectl cp hostname sample-pod:/tmp/newfile

# 컨테이너의 /tmp 확인
kubectl exec -it sample-pod -- ls /tmp
```

컨테이너와 로컬 머신 간 파일 복사는 `kubectl cp` 명령어를 사용한다. 컨테이너에서 로컬 머신, 로컬 머신에서 컨테이너, 양방향으로 파일 복사가 가능하다.

## 4.5.25 kubectl 플러그인과 패키지 관리자: plugin/krew

```yaml
# 플러그인 목록 표시
kubectl plugin list

# 플러그인 설치
kubectl krew install tree rolesum sort-manifests open-svc view-serviceaccount-kubeconfig
```

## 4.5.26 kubectl에서 디버깅

kubectl은 쿠버네티스 마스터의 API와 통신하여 클러스터를 관리한다. 따라서 어떤 에러가 발생했을 때는 API 통신이나 kubectl 설정에 문제가 있는 경우가 대부분이다. kubectl 명령어를 실행할 때 `-v` 옵션으로 로그 레벨을 지정하면 명령어 실행 내용을 좀 더 상세히 볼 수 있다. 리소스 등을 생성했으 때 HTTP Request/Response 내용을 표시하는 경우 `-v=6` 이상의 로그 레벨로 출력하면 된다.

```yaml
kubectl -v=6 get pod

# HTTP PATCH상황을 확인
kubectl -v=8 apply -f sample-pod.yaml\
```

## 4.5.27 kubectl의 기타 팁

### alias 생성

```yaml
# kubectl 명령어를 k로 사용할 수 있도록 alias 설정
alias k='kubectl'

# 약어를 사용하여 파드 정보 조회
k get po
```

### kube-ps1

kube-ps1은 bash나 zsh의 프롬프트에 현재 작업 중인 쿠버네티스 클러스터와 네임스페이스를 표시한다.

### 파드가 기동하지 않는 경우의 디버깅

쿠버네티스 환경에서 파드가 기동하지 않는 경우에는 디버깅할 떄 주로 다음 세 가지 방법이 사용된다.

- `kubectl logs` 명령어를 사용하여 컨테이너가 출력하는 로그를 확인하는 방법이다. 이 방법은 주로 애플리케이션에 문제가 있을 때 유용하다.
- `kubectl describe` 명령어로 표시되는 Events 항목을 확인하는 방법이다. 이 방법은 주로 쿠버네티스 설정이나 리소스 설정에 문제가 있을 때 유용하다. 명령어를 실행하면 에러 메시지를 확인할 수 있어 다음과 같은 원인을 판별할 수 있다.
    - 리소스 부족으로 스케줄링이 불가능
    - 스케줄링 정책에 해당하는 노드가 존재하지 않음
    - 볼륨 마운트 실패
- `kubectl run` 명령어를 사용하여 실제 컨테이너 셸로 확인하는 방법이다. 이는 주로 컨테이너 환경이나 애플리케이션에 문제가 있을 때 유용하다. 기동한 애플리케이션이 정지되면 파드도 정지되어 `kubectl exec` 명령어로 셸을 실행할 수 없다. 그런 경우 애플리케이션의 `ENTRYPOINT`를 덮어 씌워 일시적으로 컨테이너를 기동시켜 확인할 수 있다.
    
    ```yaml
    # 일시적으로 nginx 이미지로 웹 서버가 아닌 셸을 기동(종료 후 파드는 삭제된다)
    kubectl run --image=nginx:1.16 --restart=Never --rm -it sample-debug --command -- /bin/sh
    sh-4.1 # (이후에 컨테이너 내부에서 임의의 명령어로 디버깅)
    ```