# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [빅오 표기법 (Big O Notation)](#01-빅오-표기법-big-o-notation)

  - [Big O의 필요성](#big-o의-필요성)
  - [빅오 개념](#빅오-개념)
    - [빅오 표현식의 단순화](#빅오-표현식의-단순화)
    - [빅오 명심해야할 점](#빅오-명심해야할-점)
    - [빅오 단순화 그래프](#빅오-단순화-그래프)
  - [공간 복잡도](#공간-복잡도)
    - [시간 복잡도](#시간-복잡도)
    - [공간 복잡도](#공간-복잡도-개념)
    - [Space Complexity in JS](#space-complexity-in-js)
    - [공간 복잡도 예시](#공간-복잡도-예시)
  - [로그와 섹션 요약](#로그와-섹션-요약)
    - [로그](#로그)
    - [요약](#요약)

- [02. 객체의 빅오](#02-객체의-빅오big-o)
- [객체의 빅오(Big O)](#객체의-빅오big-o)
  - [When to use Objects](#when-to-use-objects)
  - [Big O of Objects](#big-o-of-objects)
  - [Big O of Object Methods](#big-o-of-object-methods)
- [배열의 빅오(Big O)](#배열의-빅오big-o)
  - [When to use Arrays](#when-to-use-arrays)
  - [Big O of Arrays](#big-o-of-arrays)
  - [Big O of Array Operations](#big-o-of-array-operations)
- [03. 문제 해결 접근법](#03-문제-해결-접근법)
  - [알고리즘](#알고리즘)
    - [What is an algorithm?](#what-is-an-algorithm)
    - [Why do I need to knoe this?](#why-do-i-need-to-know-this)
    - [How do you improve?](#how-do-you-improve)
    - [Problem Solving](#problem-solving)
  - [1단계: 문제의 이해(Understanding the Problem](#1단계-문제의-이해understanding-the-problem)
    - [How to understand the Problem](#how-to-understand-the-problem)
    - [Example](#example)
  - [2단계: 구체적 예제들(Exploring Concrete Examples)](#2단계-구체적-예제들exploring-concrete-examples)
    - [Explore Concrete Examples](#explore-concrete-examples)
    - [Steps to Explore Examples](#steps-to-explore-examples)
    - [Example](#example-1)
  - [3단계: 세부 분석(Breaking It Down)](#3단계-세부-분석breaking-it-down)
    - [Break It Down](#break-it-down)
    - [Example](#example-2)
  - [4단계: 해결 또는 단순화](#4단계-해결-또는-단순화)
    - [Solve the Problem. If you can't do, Solve a Simpler Problem.](#solve-the-problem-if-you-cant-do-solve-a-simpler-problem)
    - [Simplify](#simplify)
    - [Example](#example-3)
  - [5단계: 되돌아 보기와 리팩터(Refactor)](#5단계-되돌아-보기와-리팩터refactor)
    - [Refactoring Questions](#refactoring-questions)
    - [Example](#example-4)
    - [다시 리팩토링](#다시-리팩토링)
- [04. 문제 해결 패턴](#04-문제-해결-패턴)
  - [빈도수 세기(Frequency Counters)](#빈도수-세기frequency-counters)
    - [Frequency Counters](#frequency-counters)
    - [Example](#example-5)
    - [a Native Solution](#a-native-solution)
    - [Refactor](#refactor)
  - [빈도수 세기: 애너그램 도전 과제](#빈도수-세기-애너그램-도전-과제)
    - [Anagrams](#anagrams)
    - [내가 푼 해결책](#내가-푼-해결책)
    - [애너그램 과제 솔루션](#애너그램-과제-솔루션)
  - [다중 포인터 패턴](#다중-포인터-패턴)
    - [Multiple Pointers](#multiple-pointers)
    - [Example](#example-6)
    - [Native Solution](#native-solution)
    - [Refactor](#refactor-1)
  - [다중 포인터: 고유값을 세는 도전 과제](#다중-포인터-고유값을-세는-도전-과제)
    - [countUniqueValues](#countuniquevalues)
    - [내가 푼 해결법](#내가-푼-해결법)
    - [고유값 세기 솔루션](#고유값-세기-솔루션)
  - [기준점 간 이동 배열 패턴](#기준점-간-이동-배열-패턴)
    - [슬라이딩 윈도우(Sliding Window)](#슬라이딩-윈도우sliding-window)
    - [Example](#example-7)
    - [Native Solution](#native-solution-1)
    - [Refactor](#refactor-2)
  - [분할과 정복 패턴](#분할과-정복-패턴)
  - [Divide and Conquer](#divide-and-conquer)
  - [Example](#example-8)
  - [Native Solution](#native-solution-2)
  - [Refactor](#refactor-3)
- [05. 100% 선택적 도전과제](#05-100-선택적-도전-과제)
  - [Frequency Counter - sameFrequency](#frequency-counter---samefrequency)
  - [Frequency Counter / Multiple Pointers - areThereDuplicates](#frequency-counter--multiple-pointers---arethereduplicates)
  - [Multiple Pointers - average Pair](#multiple-pointers---average-pair)
  - [Multiple Pointers - isSubsequence](#multiple-pointers---issubsequence)
  - [Sliding Window - maxSubarraySum](#sliding-window---maxsubarraysum)
  - [Sliding Window - minSubArrayLen](#sliding-window--minsubarraylen)
  - [Sliding Window - findLongestSubstring](#sliding-window---findlongestsubstring)

# 01. 빅오 표기법 (Big O Notation)

### Objectives

- 빅오 표기법(Big O Notation)의 필요성
- 빅오 표기법 정의
- 빅오 표기법을 간단하게 표현하는 방법
- "시간 복잡도"와 "공간 복잡도" 정의
- 빅오 표기법을 사용해서 여러가지 알고리즘 평가
- 로그(Logarithm) 정의

## Big O의 필요성

- 여러가지 코드를 일반적으로 서로 비교하고 성능을 평가하는 방법
- 자신이 만든 해결책, 알고리즘이 만족스럽다고 하더라도 다른 해결책과 비교하고 성능이 어떤지 이해하는 것이 도움됨
- 에러만을 찾는 것이 아니라, 코드가 작동하지만 더 오랜 시간이 걸리거나, 브라우저에서 함수를 실행할 때 자신이 만든 비효율적인 코드를 이해하고 있어야 함

### 코드 시간 재기

- 1에서부터 특정한 N 갑소가 사이에 있는 모든 숫자들을 더하는 함수를 쓰고 싶다고 생각
  - ex) 1 + 2 + 3, 6

#### 가장 생각하기 쉬운 해결법

```javascript
function addUpToFirst(n) {
  let total = 0;
  for (let i = 0; i <= n; i++) {
    total += i;
  }

  return total;
}
```

#### 다른 해결법

```javascript
function addUpToSecond(n) {
  return (n * (n + 1)) / 2;
}
```

- 루프를 사용하지 않고 수학 공식에 가까운 해결법

### 더 나은 코드는?

- 여기서 **더 나은**이란 무슨 의미?
  - 어떤 코드가 더 빠르다는 것을 의미?
  - 메모리를 얼마나 사용하는지를 의미?
  - 코드를 얼마나 쉽게 읽을 수 있는지를 의미?
  - 우선 속도에 초점을 맞춰서 비교할 예정
- 물론, 좋은 코드를 쓴다는 것은 **_많은 메모리 양을 사용하지 않는 효율적인 코드를 쓰면서 읽기 쉬운 점 두 가지를 잘 조율하는 것!_**

### timer function를 사용한 속도 비교

```javascript
function addUpToFirst(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) total += 1;
  return total;
}
let t1 = performance.now();
addUpTo(100000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`);
```

```javascript
function addUpToSecond(n) {
  return (n * (n + 1)) / 2;
}
let t1 = performance.now();
addUpTo(100000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`);
```

#### 똑같은 데이터를 다루지만 2번 코드가 훨씬 더 짧은 시간 안에 해냈다는 것을 확인할 수 있음

- 이렇게 수동으로 타이밍을 구하고 서로 비교하는 것이 가장 좋은 방법은 아님
  - 기기 사양에 따라 다를 수 있고, 그 기계 무엇이 실행되고 있는지에 따라서 다를 수도 있음
  - 똑같은 기계가 다른 시간을 기록할 수도 있음
  - 빠른 알고리즘에서는 정말 짧은 시간 안에 모든 것이 처리된다는 것
  - 이런 경우에 속도 측정 정확도가 충분하지 않을 수 있음

### 연산 갯수 세기

#### 시간을 사용하지 않는다면 무엇을 사용할까?

- 코드가 실행될 때 걸리는 정확한 시간을 초로 측정하는 것 보다는 **_컴퓨터가 처리해야 하는 연산 개수_**를 세면 된다.
- 어떤 컴퓨터를 사용하든 그 갯수는 변하지 않기 때문이다.

#### 연산 개수 세기

```javascript
function addUpToSecond(n) {
  return (n * (n + 1)) / 2;
}
```

- 1 곱셈(multiplcation), 1 덧셈(addition), 1 나눗셈(division)
  - n이 어떤 값을 갖고 있든 연산은 3번만 이루어진다는 것을 알 수 있다.

```javascript
function addUpToFirst(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) total += i;
  return total;
}
```

- +가 연산으로 루프 안에 있기 때문에 위와는 조금 다르다. n이 5라면 연산이 5번, 1억이라면 1억번 이루어진다.
  - **_즉, n 개수의 연산인 것!_**
- 그 외의 연산으로 for 문 안의 ++, +=에서 =, i <= n 등 추가적인 연산이 있다.
- 연산의 총 개수는 5n + 2이지만 그것보다 중요한 것은 **_전체적인 추세를 보는 것!_**
  - 즉, n이 커질수록 연산의 개수도 비례적으로 늘어난다는 전체적인 그림을 볼 수 있어야 한다.

## 빅오 개념

- 대략적으로 숫자를 세는 것에 붙인 공식적인 표현
- 정식으로 입력된 내용이 늘어날수록 알고리즘에 실행시간이 어떻게 변하는지 설명하는 공식적인 방식
- 즉, 빅오는 어떤 함수의 **_입력값이 늘어나는 것_** 과 **함수 실행 시간** 이 변하는 관계를 의미한다.
  - 단, 오로지 **_전반적인 추세_** 에 주목하는 것이 중요!
- We say that an algorithm is O(f(n)) if the number of simple operations the computer has to do is eventually less than a constant times f(n), as n increases
  - 컴퓨터가 해야 하는 간단한 연산의 수가 n이 증가함에 따라 f(n)의 상수보다 적다면 그 알고리즘을 O(f(n))으로 표현한다.
  - f(n) could be linear (f(n) = n) => n의 값이 커질수록 실행 시간도 같이 늘어나는 선형의 형태
  - f(n) could be quadratic (f(n) = n^) => n의 값이 커질수록 실행 시간이 n의 제곱인 형태
  - f(n) could be constant (f(n) = 1) => n의 값이 커져도 실행 시간에 아무 영향도 받지 않는 상수의 형태
  - f(n) could be something entirely different! => 완전히 다른 관계를 가질 수도 있음!
- 빅오를 얘기했을 때는 실행시간이 갖을 수 있는 최대치!

#### 빅오를 통한 addUpTo 비교

<p  align="center">
  <img src="../addUpTo.png" width="50%" height="50%">
</p>

- addUpToFirst => O(n), n의 값이 커질수록 실행 시간이 1:1 비율로 늘어남
- addUpToSecond => O(1), n의 값이 커져도 아무런 변화가 없음

#### countUpAndDown

```
function countUpAndDown(n) {
	console.log("Going up!");
	for (let i = 0; i < n; i++) { // O(n)
		console.log(i);
	}
	console.log("At the top!\nGoing down...");
	for (let j = n - 1; j >= 0; j--) { // O(n)
		console.log(j);
	}
	console.log("Back down. Bye!");
}
```

- 빅오를 O(2n)이라고 생각할 수 있지만 그것 보다는 O(n)이라는 큰 그림만 신경써야 한다!

#### 이중 중첩 루프

```javascript
function printAllPairs(n) {
  for (var i = 0; i < n; i++) {
    // O(n)
    for (var j = 0; j < n; j++) {
      // O(n)
      console.log(i, j);
    }
  }
}
```

- O(n)으로 단순화되는 O(2n)이 아니라 중첩되어 있기 때문에 O(n^)이다.
  - 즉, n이 커질수록 실행 시간이 n제곱의 값으로 늘어난다는 것!
  - ex) n=2일 때 연산 개수가 4라면, n=3일 때 연산 개수는 9가 된다.

### 빅오 표현식의 단순화

- 상수, 작은 연산에 신경쓰지 않아도 된다. => **_큰 그림, 추세를 보는 것이 더 중요!_**
- O(2n), O(n + 100), O(1000n + 50) => O(n)
  - 연산 개수가 늘어남에 따라 실행 시간도 linear 형태로 늘어나는 형태임
- O(500) => O(1)
  - 연산 개수가 어떤 상황에도 500개이므로 실행 시간에 영향을 미치지 않아 그래프가 constant 형태임
- O(13n^), O(N^2 + 5n + 8) => O(n^)
  - 연산의 개수가 늘어남에 따라 실행 시간이 n^만큼 늘어나는 quadratic 형태임

### 빅오 명심해야할 점

- 빅오의 복잡도를 분석할 때는 매우 복잡해짐
- 따라서 항상 맞지는 않지만 쉽게 적용할 수 있는 규칙이 있다.
  - **_산수는 상수라는 것_** (덧셈, 뺄셈, 곱셈, 나눗셈 포함)
    - 컴퓨터가 2+2를 처리하는 시간과 100만 + 2를 처리하는 시간은 비슷
  - **_변수 배정도 상수_**
    - 컴퓨터가 변수에 값을 배전하는데 걸리는 시간은 비슷하다.
  - **\_인덱스를 사용해서 배열 엘리먼트를 접근하는 것도 상수\_\_**
    - 배열에서 첫 번째 엘리먼트든, 10번째 엘리먼트를 찾던 똑같은 시간이 걸린다.
  - **_루프가 있다면 복잡도가 루프의 길이 곱하기_**
    - 리스트에 있는 데이터를 루프로 처리할 때 0에서 n까지 간다면, 루프가 반복되는 횟수가 늘어난다.
    - 만약 중첩 루프가 있다면, n제곱 실행 시간이 된다.

### 빅오 단순화 그래프

<img src="https://miro.medium.com/max/1400/1*WXfVqSBSsQBLKnPMM4rRKA.png" width="50%">

## 공간 복잡도

### 시간 복잡도

- 입력값의 크기에 따라 알고리즘들이 얼마나 빠르게 실행하는지 분석하는 것을 **시간 복잡도** 라고 한다.

### 공간 복잡도 개념

- 입력값이 커질수록 알고리즘이 얼마나 많은 공간을 차지하는지에 대한 값
- 공간, 사용되는 메모리에 주목!
- **보조 공간 복잡도(auxiliary space complexity)**
  - 당연히 n이 커질수록 입력 자체가 커지는데 그 부분을 무시해서 공간 복잡도를 공부할 예정
  - 즉, 입력되는 것을 제외하고 알고리즘 자체가 필요로 하는 공간을 의미, **_중요한 것은 알고리즘 자체!_**
  - 입력이 차지하는 공간응 관심없고, 알고리즘 자체가 어떤 영향을 주는지 자세히 봐야 한다.
  - 따라서, 공간 복잡도라고 다음 말할 때 사실상 보조 공간 복잡도를 말하는 것 유의!

### Space Complexity in JS

- **Most primitives (booleans, number, undefined, null) are constant space**
  - 불리안, 숫자, undefined, null은 자바스크립트에서 모두 불변 공간
  - 그렇기 때문에 입력의 크기와는 상관업이 1이든 100000000이든 모두 같은 공간을 차지
- **String require O(n) space (where n is the string length)**
  - 문자열은 O(n) 공간이 필요하다.
  - n이 문자열의 길이라면 50자인 문자열은 길이가 1자인 문자열보다 50배 많은 공간을 차지
- **Reference types are generally O(n), where n is the length (for arrays) or the number of keys (for objects)**
  - reference 타입, 배열과 객체도 대부분 O(n)으로 생각
  - n은 배열의 길이이거나 객체의 키 개수일 수 있다.
  - 배열의 길이가 4인 배열이 배열의 길이가 2인 배열보다 2배 더 많은 공간을 차지

### 공간 복잡도 예시

```javascript
function sum(arr) {
  let total = 0;
  for (let i = 0; i < arr.length; i++) total += arr[i];
  return total;
}
```

- sum 함수는 배열을 아규먼트로 받아서 그 배열 안에 있는 모든 엘리먼트를 합쳐 total 변수를 리턴한다.

#### 시간이 아닌 공간을 차지하는 것들이 무엇일까?

- 배열의 길이와는 상관없이 total 변수
- 루프 안의 let i = 0 변수
- 시간이 걸릴 뿐 공간이 할당되어 있는 변수는 두 개가 끝!
- 그렇기 때문에 배열의 크기와는 상관없이, n이 커져도 입력의 크기가 차지하는 공간과는 아무 상관없다!
  - **따라서 결국 상수 공간으로 있다는 것 => O(1)**

```javascript
function double(arr) {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) newArr.push(2 * arr[i]);
  return newArr;
}
```

#### 공간이 차지하는 것들은 무엇?

- 새로운 빈 newArr 배열에 매개변수로 받은 배열을 루프로 접근해서 2배로 곱한 후 newArr에 푸쉬하고 루프가 끝나면 리턴
- 배열의 크기는 입력된 배열의 크기와 비례해서 커지게 된다. => **O(n) 공간을 차지**

## 로그와 섹션 요약

### 로그 설명 이유

- 어떤 알고리즘들은 O(1), O(n), O(n^)처럼 빅오가 간단하지 않은 경우가 있다.
- 빅오 표기들 중에 더 어렵거나 덜 흔한 수학 개념들이 포함되어 있다.
- 그 중 자주 나오는 개념이 **로그!**
  - 어떤 **탐색 알고리즘(searching algorithms)** 들은 로그 시간 복잡도를 갖고 있다.
  - **효율적인 정렬 알고리즘(sorting algorithms)** 들도 로그와 관련되어 있다.
  - **재귀(recursion)** 도 가끔 로그 공간 복잡도와 관련되어 있다.

### 로그

- 로그함수는 **지수함수의 역함** 이다.
- 나눗셈과 곱셈이 짝인 것처럼 로그함수와 지수함수가 짝이다.
- 알고리즘이 log n 시간 복잡도를 갖고 있다면, 처음에는 조금 가파를지라도 서서히 경사가 작아진다
  따라서, 알고리즘이 log n 시간 복잡도를 갖고 있다면 좋다는 의미!

## 요약

#### To analyze the performance of an algorithm, we use Big O Notation

- 알고리즘의 성능을 분석하기 위해서는 빅오 표기법을 사용한다.

#### Big O Notation can give us a high level understanding of the time or space complexity of an algorithm

- 빅오를 통해서 시간과 공간 복잡도에 대해 이해를 높일 수 있다.

#### Big O Notation doesn't care about precision, only about general trends(linear? quadratic? constant?)

- 입력의 크기가 늘어남에 따라 전체적인 추세를 볼 줄 알아야 한다.

#### This time or space complexity (as measured by Big O) depends only on the algorithm, not the hardware used to run the algorithm.

- 빅오로 측정되는 알고리즘의 시간과 공간 복잡도는 하드웨어의 영향을 받지 않는다.
- 빅오는 실행될 연산의 개수를 따지기 때문에 이에 의존한다.

#### Big O Notation is everywhere, so get lots of practice!

- 빅오 표기법은 세상 모든 곳에서 사용된다.

# 02. 객체의 빅오(Big O)

### Objectives

- **_Understand how objects and arrays work, through the lens of Big O_**
  - 빅오의 시점에서 오브젝트와 빼열이 어떻게 작동하는지 이해하기
  - 배열의, 오브젝트의 내장된 메소드와 루프들은 얼마나 성능이 좋고, 생각보다 느린 메서드인지 살펴보기
- **_Explain why adding elements to the beginning of an array is costly_**
  - 왜 배열 앞에 데이터를 추가하는 것이 안좋은지 설명하기
  - 추가로 더 좋은 방법이 있는지 대안을 보고 배열을 처리하는 시간을 비교해보기
- **_더 복잡한 알고리즘에 들어가기 전에 빅오 표기법을 통해 배열, 오브젝트의 메서드들을 이해하기_**

## 객체의 빅오(Big O)

### When to use Objects

- When you don't need order
  - 객체는 정렬되어 있을 필요가 없을 때 잘작동한다.
- When you need fast access / insertion and removal
  - 빠른 접근 및 입력과 제거를 원할 때 좋다.

### Big O of Objects

```javascript
let instructor = {
  firstName: "oneny",
  isInstructor: true,
  favoriteNumbers: [1, 2, 3, 4].
};
```

- Insertion(입력) => O(1), 상수
- Removal(제거) => O(1), 상수
- Searching(탐색) => O(N), 선형
  - 탐색은 단순히 key를 찾는 것이 아니라 true값이 위 객체에서 어디에 저장되어 있는지 알기 위해서 탐색하는 것!
  - 따라서 속성들이 많아질수록 그만큼 걸리는 시간도 늘어난다.
- Access(접근) => O(1), 상수

### Big O of Object Methods

- Object.keys - O(n)
- Object.values - O(n)
- Object.entries - O(n)
  - 위 세 메서드는 속성들의 개수가 늘어나면 각 속성에 접근해서 배열에 추가해야 하는 시간이 늘어나므로 O(n) 선형 형태이다.
- hasOwnProperty - O(1)
  - instructor.hasOwnProperty("firstName") 실행하려면 firstName이라는 속성의 유무 결과만 전달함
  - **즉, 정렬되어 있지 않지만 firstName 키가 있고 그 값을 원하면 상수 시간으로 정보를 접근할 수도 있다.**

## 배열의 빅오(Big O)

### Array(Ordered List)

- 배열에 가장 중요한 점은 정렬되어 있다는 것 => **_데이터가 정렬되어 있는 기준이 있다!_**
  - 한 뭉치로 있는 객체와는 다르다.
  - 따라서 정렬되어 있는 것이 필요하다면 유용하지만, 연산을 하는 시간이 더 걸릴 수도 있다.

### When to use Arrays

```javascript
let names = ["Michael", "Melissa", "Andrea"];
let values = [true, {}, [], 2. "awesome"];
```

- When you need order
  - 배열은 대부분 정렬되어 있는 데이터를 위해서 사용한다.
  - 정렬되어 있는 것이 필요하더라도, 싱글 링크 리스트와 더블 링크 리스트처럼 코드 안에 정렬된 구조가 있는 데이터도 있다.
  - 선형 리스트 구조로 엘리먼트마다 특정 위치에 있고 순서대로 연결되어 있다.
  - 즉, 정렬되어 있는 것이 필요없다면 배열은 사용하지 않는 것이 좋다.
- When you need access / insertion and removal (sort of ...)
  - 섞여있는 데이터를 저장하고 싶을 때 배열을 사용해도 되겠지만 성능을 희생해야 할 수도 있다.
    - 성능을 최적화하고 싶다면 다른 선택을 사용 가능 시 다른 선택권으로 하는 것이 좋다.
  - 특히 입력과 제거를 할 때 복잡해질 수 있지만 배열 안 데이터에 접근하는 것은 매우 빠르다.

### Big O of Arrays

- Searching - O(N)
- Access - O(1)
  - 배열이 얼마나 긴지는 중요하지 않고 인덱스를 통해 해당 데이터에 바로 접근이 가능하다.
- Insertion - It depends ...
  - 엘리먼트마다 붙어있는 인덱스가 있고 엘리먼트를 추가하고 싶다면
    - 엘리먼트 끝에 푸쉬하는 경우에는 객체처럼 O(1) 상수 시간이 걸리지만,
    - 배열 앞에 추가할 때 배열에 있는 인덱스들을 다시 재정해야 되는 등의 이유로 O(N) 선형 시간이 된다.
- Removal - It depends ...
  - 입력과 같은 문제로 배열 앞에 제거할 때 인덱스들을 다시 재지정해야 되므로 O(N) 선형 시간이 된다.
  - 이것이 push와 pop하는 작업이 shift와 unshift 작업보다 빠른 이유이다.
- **따라서 배열 앞에 추가하고 제거하는 것을 필요한 경우가 아니라면 피하는 것이 좋다.**

### Big O of Array Operations

- push - O(1)
- pop - O(1)
- shift - O(N)
- unshift - O(N)
- concat - O(N)
  - O(M + N) => O(N) (\* N: 앞에 붙일 엘리먼트들, M: 뒤에 붙일 엘리먼트들)
- slice - O(N)
  - 배열 엘리먼트 10개를 복사하는 것과 1000개를 복사하는 것을 비교할 때 후자가 더 걸린다.
- splice - O(N)
  - 배열을 중간에 추가하거나 교체하면 인덱스를 재지정해야 하므로 O(N) 선형 시간이다.
- sort - O(N \* log N)
  - 가장 좋지 않음
- forEach/map/filter/reduce/etc. - O(N)
  - 엘리먼트마다 한 작업을 실행하므로 O(N)으로 표현

# 03. 문제 해결 접근법

### Objectives

- **Define what an algorithm is**
  - 간단히 알고리즘이 무엇인지 정의하지
- **Devise a plan to solve algorithms**
  - 알고리즘을 해결하기 위한 계획 세우기
- **Compare and contrast problem solving patterns including frequency counters, two pointer problems and divide and conquer**
  - 빈도 카운터, 투 포인터, 분할정복 등을 포함하는 문제 해결 패턴들을 비교 및 대조하기

## 알고리즘

### What is an algorithm?

- A **process** of **set of steps** to accomplish a certain task
  - 특정 작업을 달성하기 위한 과정이나 일련의 단계를 의미
- 이처럼 알고리즘은 문제를 해결하기 위해 수행해야 하는 일련의 수학적 단계라 할 수 있다.
  - **핵심은 어떤 작업을 달성하기 위한 일련의 단계**

### Why do I need to know this?

- Almost everything that you do in programming involves some kind of algorithm!
- It's the foundation for being a successful problem solving and developer.
- 프로그래밍에서 수행하는 거의 모든 작업(그것이 기본적이든 복잡한 애플리케이션을 구춘하든)에는 일종의 알고리즘이 포함되므로 문제를 해결할 방법을 마련할 수 있도록 결정해야 한다.

### How do you improve?

- Devise a plan fro solving problems
  - 문제 해결을 위한 계획을 수립하기
  - 문제에 접근하는 방법, 문제를 세분화하기 위한 전략이라고 할 수 있다.
- Master common problem solving patterns
  - 일반적인 문제 해결 패턴을 파악하기
  - 많은 알고리즘들 중 일부 범주를 식별할 수 있는 경우에는 몇 가지 단계를 통해 얻을 수 있는 알고리즘이나 과제를 해결하는데 도움이 될 조합법을 확보할 수 있다.

### Problem Solving

1. **Understand the Problem** (문제 이해하기)
2. **Explore Concrete Examples** (구체적인 예제들 살펴보기)
3. **Break It Down** (문제를 세분화하기)
4. **Solve/Simplify** (문제를 해결하고 단순화하기)
5. **Look Back and Refactor** (문제를 복습하고 재구성하기)

## 1단계: 문제의 이해(Understanding the Problem)

### How to understand the Problem

- 가장 우선적으로 해야 할 일
- **Can I restate the problem in my own words?**
  - 과제를 수행하면서 무언가를 구축하려고 하지만 접근 방법을 잘 모르는 경우, **문제를 자신의 방식대로 다시 생각할 수 있는지** 에 대해 생각해야 한다.
- **What are in inputs that go into the problem?**
  - **문제가 어떤 입력값을 담고 있는가를 이해하는 것** 은 정말 중요한 과정이다.

* **What are the outputs that should come from the solution to the problem**
  - 어떤 출력값이 나와야 할까?
  - 문제 해결책으로부터 나와야 할 결과가 무엇인지, 어떤 형태인지를 생각해야 한다.
* **Can the outputs be determined from the inputs? In other words, do I have enough information to solve the problem?**
  - 입력값이 출력값을 결정할 수 있을까?
  - 문제를 해결할 충분한 정보가 주어졌는가 하는 것을 살펴보아야 한다.
* **How should I label the important pieces of data that are a part of the problem?**
  - 문제의 일부인 데이터의 중요한 부분에서 어떻게 라벨을 지정할 수 있을까?
  - 이 문제에서 정말 중요한 것이 무엇인지를 살펴보아야 한다는 의미이다.

### Example

- Write a function which takes two numbers and returns their sum.
- 예시 문제로 문제를 이해하는 방법을 살펴보기
  - 숫자를 더하거나 덧셈을 수행하는 함수를 작성하면 된다.(implement addition)
  - But, 그저 두 숫자를 더하기만 하는 것은 현명하지 않다.
    - 대부분의 언어는 숫자 크기에 상한이 있기 때문이다.
    - 자바스크립트의 경우는 상한을 넘어가면 연산을 포기하고 Infinity를 반환한다.
    - 정수(int)? 부동소수점(float)? 즉, 입력값을 정의해야 한다.
- 입력값으로부터 도출될 결과값도 위 과정처럼 정의해야 한다.
- 문제를 해결하기에 충분한 정보를 가지고 있는지에 대한 질문으로 대부분 경우 대답은 yes지만 누군가 한 숫자만 입력하는 경우와 같은 충분한 설명은 없을 수 있다.
- 문제의 일부인 중요한 데이터의 라벨을 어떻게 지정할지에 대한 질문으로 무엇이 중요한가에 대해 생각부터 하는 것이 중요하다.

## 2단계: 구체적 예제들(Exploring Concrete Examples)

### Explore Concrete Examples

- Coming up with examples can help you understand the problem better
  - 예시를 떠올리는 것이 문제를 잘이해하는데 도움이 된다.
- Examples also provide sanity checks that your eventual solution works how it should
  - 예시는 온전성 검사를 제공하므로 최종 해결책을 입력했다면 제대로 작동하는지 검사를 수행할 수 있다.
  - 예시를 알고 있다면 입력값과 반한되어야 할 출력값도 알 수 있기 때문이다.
  - 따라서 에시를 적용하면서 더 많은 정보를 습득할 수 있다.

### Steps to Explore Examples

1. **Start with Simple Examples**

- 문제를 맞딱트리면 우선 해야 할 일은 간단한 예시로 시작하는 것이다.

2. **Progress to More Complex Examples**

- 가장 쉬운 사용 사례와 같은 에시들로부터 더 복잡한 예시들로 진행한다.

3. **Explore Examples with Empty Inputs**

- 빈 입력값이 있는 예제를 살펴보는 것은 특히 유효하지 않은 입력값이 주어진 면접 상황에서 어떻게 해결해야 할지 해결 능력을 갖출 수 있도록 해준다.

4. **Explore Examples with Invalid Inputs**

- 사용자가 유효하지 않은 값을 입력하면 어떻게 될지를 생각하는 것은 실제 작업 환경에서 더 유용하다 할 수 있다.

### Example

> Write a function which takes in a string and returns counts of each character in the string.(문자열을 취하고 각 문자의 수를 반환하는 함수를 작성)

- 예시를 통한 문제 바라보기

```javascript
charCount("aaaa"); // {a: 4} (1번)
charCount("hello"); // {h:1, e:1, l:2, o:1} (2번)

// 더 고려해야 할 상황(경계 조건)
charCount("aaaa"); // {a: 4, b: 0, c: 0, ... }처럼 전달되지 않은 문자는 0으로 표시해야 할지(4번)
charCount("my phone number is 12353"); // 공백도 고려해야 하는지(4번)
// 다른 문자들과 달리 달러 기호, 밑줄, 중요한 숫자들은 어떻게 해야 할지(4번)
// 대문자와 소문자 모두 저장했을 때 대소문자를 무시해야 하는지(4번)
charCount() charCount("") // 무엇을 반환할지(3번) => 빈 객체({}) or null of false or undefined or error?
```

## 3단계: 세부 분석(Breaking It Down)

### Break It Down

- 문제를 세부 분석하겠다는 것은 문제에 대한 단계들을 실제로 수행하면서 작성한다는 것
- Explicitly write out the steps you need to take
  - 문제에 대해 자신이 밟아야 할 단계들을 명확하게 작성해보는 것이 좋다.
  - 아주 세세히 적을 필요없고 해결책의 기본적인 구성 요소만 작성하면 된다.
  - 코드를 대충 떠오르는대로 작성하는 것이 아닌 실제 입력하기 전에 한 번 생각해 볼 수 있게 해준다.
    - 단계의 틀을 잡고 집중할 수 있도록 도울 뿐만 아니라 이해되지 않는 부분들을 파악하게 해준다.

### Example

> Write a function which takes in a string and returns counts of each character in the string.(문자열을 취하고 각 문자의 수를 반환하는 함수를 작성)

- 한 장이나 화이트보드에 몇 가지 예시를 작성하면서 함수의 구조를 잡아 간다.
- 주석을 작성해두면 문제를 끝내지 못하더라도 문제를 해결하는 방향이나 기본적 개념을 알고 있다고
  어필할 수 있는 수단이 된다.

```javascript
charCount("aaaa");
/* {
	a: 4
} */

charCount("hello");
/* {
	h: 1,
	e: 1,
	l: 2,
	o: 1
} */

charCount("Your PIN number is 1234!");
/* {
	1: 1, 2: 1, 3: 1, 4: 1, b: 1, e: 1, i: 2,
	m: 1, n: 2, o: 1, p: 1, r: 2, s: 1, u: 1, y: 1
} */

function charCount(str) {
  // do something
  // return an object with keys taht are lowercase alphanumeric characters in ther string;
  // values sholud be the counts for those characters
}

function charCount(str) {
  // make object to return at end
  // loop over string, for each caracter...
  // if the char is a number/letter AND is a key in object, add one to count
  // if the char is a number/letter AND not in object, add it to the object and set value to 1
  // if character is something else (space, period, etc.) don't do anything
  // return object at end
}
```

## 4단계: 해결 또는 단순화

### Solve the Problem. If you can't do, Solve a Simpler Problem.

- 문제를 해결할 수 있다면 해결하고 해결할 수 없다면 더 단순한 문제를 해결해라!
  - 다른 모든 것에 집중하기 위해 시간이 많이 소요되는 부분을 무시하라는 말
  - 코드를 작성하기도 전에 문제를 죄다 한 곳에 몰아 모든 문제를 해결하려 하면 문제의 어려운 부분에 가로막혀 진도를 나가지 못하는 경우가 생길 수 있다.
- 보통 문제를 단순화하는 과정에서 실제 해결책을 깊이 이해하고 문제의 어려운 부분을 파악하면 해결되기도 한다.

### Simplify

- 단순화하는 방법
- Find the core difficulty in what you're trying to do
- Temporarily ignore that difficulty
- Write a simplified solution
- Then incorporate that difficulty back in
  - 수행하려는 작업에서 혼란에 빠트리는 가장 어려운 부분을 찾게 된다면
  - 잠깐동안 어려운 부분을 무시하고
  - 단순한 해결책을 작성한 다음
  - 다시 어려운 부분을 가능하다면 다시 통합시켜야 한다.
- 그 과정 중 단순한 해결책을 작성하는 부분에서 어려운 부분이 어떻게 동작하는지 이해하게 된다.

### Example

```javascript
function charCount(str) {
  // make object to return at end
  var result = {};
  // loop over string, for each caracter...
  for (var i = 0; i < str.length; i++) {
    var char = str[i];
    if (result[char] > 0) {
      // 0보다 크다믄 것은 이미 객체가 있다는 의미
      // if the char is a number/letter AND is a key in object, add one to count
      result[char]++;
    } else {
      // if the char is a number/letter AND not in object, add it to the object and set value to 1
      result[char] = 1;
    }
  }
  // if character is something else (space, period, etc.) don't do anything
  // return object at end
  return result;
}
```

- 실행 결과: charCount("Hi there!") => {H: 1, i: 1, " ": 1, t: 1, h: 1, e: 2, r: 1}
  - 이제 공백이나 소문자/대문자 문제 등을 해결해주면 된다.
  - **_문자열 전체를 소문자로 바꾸느냐 아니면 한 번에 한 문자씩 바꾸느냐_** 를 고려해야 한다.

## 5단계: 되돌아 보기와 리팩터(Refactor)

### Refactoring Questions

- 더 향상된 개발자가 되는데 있어 가장 중요한 단계
- 해결책을 완성했다면 자부심을 가져도 괜찮지만 되돌아 보면서 다음 사항들을 스스로에게 물어보는 것이 좋다.
- Can you check the result?
- Can you derive(도출) the result differently?
- Can you understand it at a glance(한 눈에)?
- Can you use the result or method for some other problem?
- Can you improve the performance of your solution?
- Can you think of other ways to refactor?
- How have other people solved this problem?
- 자신이 놓친 다른 접근법이 있는지 자신의 해결책에서 성능을 향상시킬 수 있는 부분이 있는지 확인하자.

### Example

```javascript
function charCount(str) {
  var obj = {};
  for (var i = 0; i < str.length; i++) {
    var char = str[i].toLowerCase();
    if (/[a-z0-9]/.test(char)) {
      // 문자가 영숫자인지 여부를 검사하는 정규식 추가
      if (obj[char] > 0) {
        obj[char]++;
      } else {
        obj[char] = 1;
      }
    }
  }

  return obj;
}
```

- 문자가 영숫자인지 여부를 검사하는 정규식을 추가하면서 밑줄, 대시, 마침표, 쉼표 등을 제거하도록 설정할 수 있다.

### 다시 리팩토링

```javascript
function charCount(str) {
  var obj = {};
  for (var char of str) {
    char = char.toLowerCase();
    if (/[a-z0-9]/.test(char)) { // 문자가 영숫자인지 여부를 검사하는 정규식 추가
      obj[char] = ++obj[char] || 1;
    }
  }

  return obj;
}
// 정규표현식을 모른다면 아래 함수를 호출해서 사용할 수도 있다.
function isAlphaNumeric(char) {
  var code = char.charCodeAt(0);
  if (!(code > 46 && code < 58) && // numeric (0-9)
      !(code > 64 && code < 91>) && // upper alpha (A-Z)
      !(code > 96 && code < 123)) { // lower alpha (a-z)
    return false;
  }
  return true;
}

function charCount(str) {
  var obj = {};
  for (var char of str) {
    if (isAlphaNumeric(char)) { // 문자가 영숫자인지 여부를 검사하는 정규식 추가
      char = char.toLowerCase();
      obj[char] = ++obj[char] || 1;
    }
  }

  return obj;
}
```

- for 루프 대신 for-of 루프를 사용함으로써 가독성을 높일 수 있다.
  - i 인덱스에서 str[i] 를 거치는 과정을 줄일 수 있다.
- 또 위의 간단한 if-else 구문을 한 줄로 줄일 수 있다.
- 만약, /[a-z0-9]/ 정규표현식으로 모른다면 isAlphaNumeric 함수를 호출해서 사용할 수도 있다.
  - 실제로 정규표현식이 아닌 작업이 실제로 더 빠르다.
- 그리고 영숫자가 아닌 임의의 문자가 많이 포함된 char를 먼저 거르고, toLowerCase하는 것이 보기 좋다.

# 04. 문제 해결 패턴

## 빈도수 세기(Frequency Counters)

### Frequency Counters

> This pattern uses objects or sets to collect values/frequencies of values.
> This can often avoid the need for nested loops or O(N^2) operations with arrays / strings.

- 보통 자바스크립트의 객체를 사용해서 다양한 값과 빈도를 수집하기 때문에 빈도수 세기라고 불린다.

* 이 패턴은 알고리즘과 과제에 있는 여러 데이터와 입력값이 서로 비슷한 값으로 구성되어 있는지, 서로 간의 아나그램인지, 값이 다른 값에 포함되는지 여부를 비교하거나, 데이터를 입력값이나 두 개 이상의 빈도 혹은 특정하게 발생하는 빈도와 비교할 떄 유용하다.

### Example

Write a function called same, which accepts two arrays. The function sholud return true if every value in the array has it's corresponding value squared in the second array. The frequency of values must be the same.

- 2 개의 배열을 허용하는 same 함수 작성하세요. 배열의 모든 값이 두 번째 배열에 해당하는 제곱값을 가지면 참을 반환해야 합니다.

```javascript
same([1, 2, 3], [4, 1, 9]); // true
same([1, 2, 3], [1, 9]); // false
same([1, 2, 1], [4, 4, 9]); // false (must be same frequency)
```

### a Native Solution

중첩된 루프를 사용한 단순한 해결책(Time Complexity - N^2)

```javascript
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0; i < arr1.length; i++) {
    let correctIndex = arr2.indexOf(arr[i] ** 2);
    if (correctIndex === -1) {
      return false;
    }
    arr2.splice(correctIndex, 1);
  }

  return true;
}
```

- indexOf의 기능은 전체 배열을 반복하거나 중첩된 루프인 전체 배열을 잠재적으로 반복하는 것이다.
  - 따라서, n이 배열의 길이를 늘리면 이 값이 이와 같이 증가하여 2차 관계로 중첩된 루프가 된다.

### Refactor

빈도 카운터 패턴이 사용된 코드(Time Complexity - O(n))

```javascript
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let frequencyCounter1 = {};
  let frequencyCounter2 = {};
  for (let val of arr1) {
    frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
  }
  for (let val of arr2) {
    frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
  }
  for (let key in frequencyCounter1) {
    if (!(key ** 2 in frequencyCounter2)) {
      return false;
    }
    if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {
      return false;
    }
  }
  return true;
}
```

- 첫 번째 배열에 루프를 적용하여 두 번째 배열의 하위 루프에서 각 값을 확인하는 대신 각 배열에 한 번씩 개별적으로 루프를 적용할 수 있다.
  - 즉, 두 개의 개별 루프(O(2n))가 두 개의 중첩된 루프(O(n^2))보다 훨씬 낫다!
- 해당 분석을 문자열이나 배열에서 생성된 다른 객체의 형태로 신속하게 비교할 수 있다.
  - 두 개의 배열을 객체로 세분화하여 각 배열의 요소들을 분류한 다음 각 배열을 비교하면 코드의 성능을 향상시킬 수 있다.
  - 이처럼 빈도 카운터의 개념은 보통 객체를 사용한다.

## 빈도수 세기: 애너그램 도전 과제

### Anagrams

Given two strings, write a function to determine if the second string is an anagram of the first. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema, formed from iceman.

- 유효한 아나그램인지를 작성하는 것과 관련된 문제
  - 두 개의 문자열을 취하며 두 문자열이 서로의 아나그램이면 참을 반환

```javascript
validAnagram("", ""); // true
validAnagram("aaz", "zza"); // false
validAnagram("anagram", "nagaram"); // true
validAnagram("rat", "car"); // false
validAnagram("awesome", "awesom"); // false
validAnagram("qwerty", "qeywrt"); // true
validAnagram("texttwisttime", "timetwisttext"); // true
```

### 내가 푼 해결책

```javascript
function validAnagram(str1, str2) {
  // add whatever parameters you deem necessary - good luck!
  if (str1.length !== str2.length) return false;

  const obj1 = {};
  const obj2 = {};
  for (let e of str1) {
    obj1[e] = (obj1[e] || 0) + 1;
  }
  for (let e of str2) {
    obj2[e] = (obj2[e] || 0) + 1;
  }
  for (let key in obj1) {
    if (!(key in obj2)) return false;
    if (obj1[key] !== obj2[key]) return false;
  }
  return true;
}
```

### 애너그램 과제 솔루션

```javascript
function validAnagram(first, second) {
  if (first.length !== second.length) return false;

  const lookup = {};
  for (let i = 0; i < first.length; i++) {
    let letter = first[i];
    // if letter exists, increment, otherwise set to 1
    lookup[letter] ? (lookup[letter] += 1) : (lookup[letter] = 1);
  }

  for (let i = 0; i < second.length; i++) {
    let letter = second[i];
    // can't find letter or letter is zero then it's not an anagram
    if (!lookup[letter]) return false;
    else lookup[letter] -= 1;
  }

  return true;
}
```

## 다중 포인터 패턴

### Multiple Pointers

Creating pointers or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition
Very efficient for solving problems with minimal space complexity as well

- 이 패턴의 개념은 인덱스나 위치에 해당하는 포인터나 값을 만든 다음 특정 조건에 따라 중간 지점에서부터 시작 지점이나 끝 지점이나 양쪽 지점을 향해 이동시키는 것이다.

### Example

Write a function called sumZero which accepts a sorted array of integers. The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist.

```javascript
sumZero([-3, -2, -1, 0, 1, 2, 3]); // [-3, 3]
sumZero([-2, 0, 1, 3]); // undefined
sumZero([1, 2, 3]); // undefined
```

### Native Solution

Time Complexity - O(n^2), Space Complexity - O(1)

```javascript
function sumZero(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] + arr[j] === 0) {
        return [arr[i], arr[j]];
      }
    }
  }
}
```

- O(n^2)의 시간 복잡도가 사용된 간단한 해결책

### Refactor

Time Complexity - O(n), Space Complexity - O(1)

```javascript
function sumZero(arr) {
  let left = 0;
  let right = arr.length - 1;
  while (left < right) {
    let sum = arr[left] + arr[right];
    if (sum === 0) {
      return [arr[left], arr[right]];
    } else if (sum > 0) {
      right--;
    } else {
      left++;
    }
  }
}
```

- 하나는 왼쪽에서 인덱스 0번째부터 시작하고, 하나는 마지막 인덱스에서 시작한다.

## 다중 포인터: 고유값을 세는 도전 과제

### countUniqueValues

Implement a function called countUniqueValues, which accepts a sorted array, and counts the unique values in the array. There can be negative numbers in the array, but it will always be sorted.

```javascript
countUniqueValues([1, 1, 1, 1, 1, 2]); // 2
countUniqueValues([1, 2, 3, 4, 4, 4, 7, 7, 12, 12, 13]); // 7
countUniqueValues([-2, -1, -1, 0, 1]); // 4
```

### 내가 푼 해결법

```javascript
function countUniqueValues(arr) {
  let result = {};
  for (let num of arr) {
    result[num] = (result[num] || 0) + 1;
  }
  return Object.keys(result).length;
}

function countUniqueValues(arr) {
  if (arr.length === 0) return 0;

  let index = 0;
  for (let num of arr) {
    if (arr[index] !== num) {
      arr[++index] = num;
    }
  }

  return index + 1;
}
```

### 고유값 세기 솔루션

```javascript
function countUniqueValues(arr) {
  if (arr.length === 0) return 0;
  let i = 0;
  for (let j = 1; j < arr.length; j++) {
    if (arr[i] !== arr[j]) {
      i++;
      arr[i] = arr[j];
    }
  }

  return i + 1;
}
```

## 기준점 간 이동 배열 패턴

### 슬라이딩 윈도우(Sliding Window)

This pattern involves creating a window which can either be an array or number from one position to another.  
Depending on a certain condition, the window either increases or closes (and a new window is created)  
Very useful for keeping track of a subset of data in an array/string etc.

- 배열이나 문자열과 같은 일련의 데이터를 입력하거나 특정 방식으로 연속적인 해당 데이터의 하위 집합을 찾는 경우에 유용하다.
  - 규모가 큰 데이터셋에서 데이터의 하위 집합을 추적하는 문제에 있어서 유용

### Example

Write a function called maxSubaaraySum which accepts an array of integers and a number called n. The function sould calculate the maximum sum of n consecutive elements in the array.

```javascript
maxSubarraySum([1, 2, 5, 2, 8, 1, 5], 2); // 10
maxSubarraySum([1, 2, 5, 2, 8, 1, 5], 4); // 17
maxSubarraySum([4, 2, 1, 6], 1); // 6
maxSubarraySum([4, 2, 1, 6, 2], 4); // 13
maxSubarraySum([], 4); // null
```

### Native Solution

Time Complexity - O(n^2)

```javascript
function maxSubarraySum(arr, num) {
  if (num > arr.length) return null;
  var max = -Infinity;
  for (let i = 0; i < arr.length - num + 1; i++) {
    temp = 0;
    for (let j = 0; j < num; j++) {
      temp += arr[i + j];
    }
    if (temp > max) {
      max = temp;
    }
  }
  return max;
}
```

### Refactor

Time Complexity - O(n)

```javascript
function maxSubarraySum(arr, num) {
  let maxSum = 0;
  let tempSum = 0;

  if (arr.length < n) return null;
  for (let i = 0; i < num; i++) {
    maxSum += arr[i];
  }

  tempSum = maxSum;
  for (let i = num; i < arr.length; i++) {
    tempSum = tempSum - arr[i - num] + arr[i];
    maxSum = Math.max(maxSum, tempSum);
  }

  return maxSum;
}
```

- 다음 항목으로 넘어갈 때 처음부터 다시 합쳐주는 것이 아니라 제일 앞에 인덱스를 빼주고 가장 마지막 인덱스를 더해주기만 하면 된다.
  - 그리고 비교를 통해 maxSum을 결정

## 분할과 정복 패턴

### Divide and Conquer

This pattern involves dividing a data set into smaller chuks and then repeating a process with a subset of data.  
This pattern can tremendously decrease time complexity.

- 이 알고리즘은 주로 배열이나 문자열 같은 큰 규모의 데이터셋을 처리한다.
- 큰 데이터 덩어리를 작은 조각으로 나누어 각 조각들을 어디로 이동시킬지 결정하는 작업 등을 한다.

### Example

Given a **_sorted_** array of integers, write a function called search, that accepts a value and returns the index where the value passed to the function is located. If the value is not found, return -1

```javascript
search([1, 2, 3, 4, 5, 6], 4); // 3
search([1, 2, 3, 4, 5, 6], 6); // 5
search([1, 2, 3, 4, 5, 6], 11); // -1
```

### Native Solution

Linear Search - Time Complexity O(n)

```javascript
function search(arr, val) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === val) return i;
  }
  return -1;
}
```

### Refactor

이진 탐색(Binary Search) - Time Complexity Log(n)

```javascript
function search(array, val) {
  let min = 0;
  let max = array.length - 1;
  while (min <= max) {
    let middle = Math.floor((min + max) / 2); // 중간 인덱스
    let currentElement = array[middle];

    if (array[middle] < val) {
      // 찾는 값이 중간 인덱스 값보다 크면 우측 엘리먼트들만
      min = middle + 1;
    } else if (array[middle] > val) {
      // 찾는 값이 중간 인덱스 값보다 작으면 좌측 엘리먼트들만
      max = middle - 1;
    } else {
      return middle; // 같은 값이면 반환
    }
  }

  return -1;
}
```

# 05. 100% 선택적 도전 과제

## Frequency Counter - sameFrequency

Write a function called **_sameFrequency._** Given two prositive integers, find out if the two numbers have the same frequency of digits.

- Your solution MUST have the follwing complexities
  - Time: O(N)
- Sample Input
  ```javascript
  sameFrequency(182, 281); // true
  sameFrequency(34, 14); // false
  sameFrequency(3589578, 5879385); // true
  sameFrequency(22, 222); // false
  ```

### 내가 푼 풀이법

```javascript
function sameFrequency(first, second) {
  const str1 = first.toString();
  const str2 = second.toString();
  const obj = {};

  if (str1.length !== str2.length) return false;

  for (let i = 0; i < first.length; i++) {
    let value = str1[i];
    obj[value] = (obj[value] || 0) + 1;
  }

  for (let i = 0; i < second.length; i++) {
    let value = str2[i];
    if (!obj[value]) return false;
    else obj[value] -= 1;
  }

  return true;
}
```

### 강의 풀이

<details>
  <summary>sameFrequency 솔루션</summary>

```javascript
function sameFrequency(num1, num2) {
  let strNum1 = num1.toString();
  let strNum2 = num2.toString();
  if (strNum1.length !== strNum2.length) return false;

  let countNum1 = {};
  let countNum2 = {};

  for (let i = 0; i < strNum1.length; i++) {
    countNum1[strNum1[i]] = (countNum1[strNum1[i]] || 0) + 1;
  }

  for (let j = 0; j < strNum1.length; j++) {
    countNum2[strNum2[j]] = (countNum2[strNum2[j]] || 0) + 1;
  }

  for (let key in countNum1) {
    if (countNum1[key] !== countNum2[key]) return false;
  }

  return true;
}
```

</details>

## Frequency Counter / Multiple Pointers - areThereDuplicates

Implement a function called, areThereDuplicates which accepts a variable number of arguments, and checks whether there are any duplicates among the arguments passed in. You can solve this using the frequency counter pattern OR the multiple pointers pattern.

- Restrictions
  - Time - O(N)
  - Space - O(N)
- Sample Input

```javascript
areThereDuplicates(1, 2, 3); // false
areThereDuplicates(1, 2, 2); // true
areThereDuplicates("a", "b", "c", "a"); // true
```

### 내가 푼 풀이

```javascript
function areThereDuplicates() {
  const obj = {};

  for (let i = 0; i < arguments.length; i++) {
    let value = arguments[i];
    obj[value] = (obj[value] || 0) + 1;
  }

  for (let count of Object.values(obj)) {
    if (count > 1) return true;
  }

  return false;
}
```

### 강의 풀이

<details>
  <summary>sameFrequency 솔루션</summary>

```javascript
// 빈도 수 세기
function areThereDuplicates() {
  let collection = {};
  for (let val in arguments) {
    collection[arguments[val]] = (collection[arguments[val]] || 0) + 1;
  }
  for (let key in collection) {
    if (collection[key] > 1) return true;
  }
  return false;
}
```

```javascript
// 다중 포인터
function areThereDuplicates(...ars) {
  // Two pointers
  args.sort((a, b) => a > b);
  let start = 0;
  let next = 1;
  while (next < args.length) {
    if (args[start] === args[next]) return true;
    start++;
    next++;
  }
  return false;
}
```

```javascript
// One Liner
function areThereDuplicates() {
  return new Set(argements).size !== arguments.length;
}
```

</details>

## Multiple Pointers - average Pair

Write a function called averagePair. Given a sorted array of integers and a target average, determine if there is a pair of values in the array where the average of the pair equals the target average. There may be more than one pair that matched the average target.

- Bonus Constraints
  - Time: O(N)
  - Space: O(1)
- Sample Input

```javascript
averagePair([1, 2, 3], 2.5); // true
averagePair([1, 3, 3, 5, 6, 7, 10, 12, 19], 8); // true
averagePair([-1, 0, 3, 4, 5, 6], 4.1); // false
averagePair([], 4); // false
```

### 내가 푼 풀이

```javascript
function averagePair(array, target) {
  let left = 0;
  let right = array.length - 1;
  let average = 0;

  while (left < right) {
    average = (array[left] + array[right]) / 2;
    console.log(average);

    if (average > target) {
      right--;
    } else if (average < target) {
      left++;
    } else {
      return true;
    }
  }
  return false;
}
```

### 강의 솔루션

<details>
  <summary>averagePair 솔루션</summary>

```javascript
function averagePair(arr, num) {
  let start = 0;
  let end = arr.length - 1;
  while (start < end) {
    let avg = (arr[start] + arr[end]) / 2;
    if (avg === num) return true;
    else if (avg < num) start++;
    else end--;
  }

  return false;
}
```

</details>

## Multiple Pointers - isSubsequence

Write a function called **_isSubsequence_** which takes in two string and checks whether the characters in the first string form a subsequence of the characters in the second string. In other words, the function should check whether the characters in the first string appear some where in the second string, **_without their order changing._**

- Your solution MUST have AT LEAST the following complexities
  - Time Complextity - O(N + M)
- Sample Input

```javascript
isSubsequence("hello", "hello world"); // true
isSubsequence("sing", "sting"); // true
isSubsequence("abc", "abracadabra"); // true
isSubsequence("abc", "acb"); // false (order matters)
```

### 내가 푼 풀이

```javascript
function isSubsequence(first, second) {
  const arr = Array.from(first);
  const e = arr[0];

  if (!e) return true;
  if (!second.includes(e)) return false;

  const s = second.slice(second.indexOf(e));

  return isSubsequence(arr.slice(1), s);
}
```

### 강의 솔루션

<details>
  <summary>averagePair 솔루션</summary>

```javascript
// 반복
function isSubsequence(str1, str2) {
  let i = 0;
  let j = 0;
  if (!str1) return true;

  while (j < str2.length) {
    if (str2[j] === str1[i]) i++;
    if (i === str1.length) return true;
    j++;
  }

  return false;
}
```

```javascript
function isSubsequence(str1, str2) {
  if (str1.length === 0) return true;
  if (str2.length === 0) return false;

  if (str2[0] === str1[0]) return isSubsequence(str1.slice(1), str2.slice(1));

  return isSubsequence(str1, str2.slice(1));
}
```

</details>

## Sliding Window - maxSubarraySum

Given an array of integers and a number, write a function called maxSubarraySum, which finds the maxium sum of a subarray with the length of the number passed to the function.  
Note that a subarray must consist of consecutive elements from the original array. In the first example below, [100, 200, 300] is a subarray of the original array, but [100, 300] is not.

- Constraints
  - Time Complexity: O(N)
  - Space Complexity: O(1)

```javascript
maxSubarraySum([100, 200, 300, 400], 2); // 700
maxSubarraySum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4); // 39
maxSubarraySum([-3, 4, 0, -2, 6, -1], 2); // 5
maxSubarraySum([3, -2, 7, -4, 1, -1, 4, -2, 1], 2); // 5
maxSubarraySum([2, 3], 3); // null
```

### 내가 푼 솔루션

```javascript
function maxSubarraySum(arr, num) {
  if (arr.length < num) return null;
  let sum = 0;

  for (let i = 0; i < num; i++) {
    sum += arr[i];
  }

  let temp = sum;
  for (let i = num; i < arr.length; i++) {
    temp = temp - arr[i - num] + arr[i];
    console.log(arr[i - num], temp);

    sum = Math.max(temp, sum);
  }

  return sum;
}
```

## Sliding Window - minSubArrayLen

Write a function called minSubArrayLen which accepts two parameters - an array of positive integers and a positive integer.  
This function should return the minimal length of a **_contiguous_** subarray of which the sum is greater than or equal to the integer passed to the function. If there isn't one, return 0 instead.

- Constraints
  - Time Complexity: O(N)
  - Space Complexity: O(1)
- Example Input

```javascript
minSubArrayLen([2, 3, 1, 2, 4, 3], 7); // 2 -> because [4,3] is the smallest subarray
minSubArrayLen([2, 1, 6, 5, 4], 9); // 2 -> because [5,4] is the smallest subarray
minSubArrayLen([3, 1, 7, 11, 2, 9, 8, 21, 62, 33, 19], 52); // 1 -> because [62] is greater than 52
minSubArrayLen([1, 4, 16, 22, 5, 7, 8, 9, 10], 39); // 3
minSubArrayLen([1, 4, 16, 22, 5, 7, 8, 9, 10], 55); // 5
minSubArrayLen([4, 3, 3, 8, 1, 2, 3], 11); // 2
minSubArrayLen([1, 4, 16, 22, 5, 7, 8, 9, 10], 95); // 0
```

### 내가 푼 솔루션

```javascript
function minSubArrayLen(arr, num) {
  let total = 0;
  let bigE = 0;

  // 예외와 엘리먼트 하나가 num 보다 큰 경우
  if (num === 1) return 1;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > num) return 1;
    bigE = Math.max(bigE, arr[i]);
    total += arr[i];
  }

  if (num > total) return 0;

  let sum = bigE;
  let left = arr.indexOf(bigE) - 1;
  let right = arr.indexOf(bigE) + 1;
  // 가장 큰 수를 기점으로 좌우 큰 수부터 하나씩 더한다.
  while (left >= 0 || right <= arr.length - 1) {
    if (arr[left] > arr[right]) sum += arr[left];
    else sum += arr[right];
    // 좌우 값이 같을 때 이렇게 되면 한 번 건너뛴 수를 비교해서 그쪽으로 더해야 한다... 못 풀겠다..
  }
}
```

### minSubArrayLen 함수 솔루션

<details>
  <summary>minSubArrayLen 함수 솔루션</summary>

```javascript
function minSubArrayLen(nums, sum) {
  let total = 0;
  let start = 0;
  let end = 0;
  let minLen = Infinity;

  while (true) {
    // if current window doesn't add up to the given sum then
    // move the window to right
    if (total < sum && end < nums.length) {
      total += nums[end]; // 8 -> 10 -> 9
      end++; // 4 -> 5 -> 6
    } // 먼저 total에 nums 합계를 구하다 더하는 과정 중 total >= sum되면 else if로

    // if current window adds up to at least the sum given then
    // we can shrink the window
    else if (total >= sum) {
      console.log("end", end); // 4 -> 5 -> 5 -> 6 -> 6
      minLen = Math.min(minLen, end - start);
      // 4 - 0 -> 5 - 1 -> 5 - 2 -> 6 - 3 -> 6 - 4
      total -= nums[start]; // 6 -> 7 -> 6 -> 7 -> 3
      start++; // 1 -> 2 -> 3 -> 4 -> 5
    }

    // current total less than required total but we reach the end,
    // need this or else we'll be in an infinite loop
    else {
      break;
    }
  }
  console.log(total, end, start, minLen);
  return minLen === Infinity ? 0 : minLen;
}
```

</details>

## Sliding Window - findLongestSubstring

Write a function called **_findLongestSubstring_**, which accepts a string and returns the length of the longest substring with all distinct characters.

- Constraints
  - Time Complexity - O(N)
- Sample Input

```javascript
findLongestSubstring(""); // 0
findLongestSubstring("rithmschool"); // 7
findLongestSubstring("thisisawesome"); // 6
findLongestSubstring("thecatinthehat"); // 7
findLongestSubstring("bbbbbb"); // 1
findLongestSubstring("longestsubstring"); // 8
findLongestSubstring("thisishowwedoit"); // 6
```

### 강의 솔루션

```javascript
function findLongestSubstring(str) {
  let longest = 0;
  let seen = {};
  let start = 0;

  // rithmschool
  for (let i = 0; i < str.length; i++) {
    let char = str[i]; // r
    if (seen[char]) {
      start = Math.max(start, seen[char]);
    }
    // index - beginning of substring + 1 (to include current in count)
    longest = Math.max(longest, i - start + 1);
    // store the index of the next char so as to not double count
    seen[char] = i + 1;
  }
  return longest;
}
```
