# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [19. 스택(Stack)과 큐(Queues)](#19-스택stack과-큐queues)
  - [What is a stack?](#what-is-a-stack)
  - [How is it used?](#how-is-it-used)
  - [How we'll visualize a stack](#how-well-visualize-a-stack)
  - [Where stacks are used](#where-stacks-are-used)
  - [Linked Lists의 개념을 활용해서 스택 셋업하기](#linked-lists의-개념을-활용해서-스택-셋업하기)
  - [push/pop 메서드](#pushpop-메서드)
  - [Big O of Stacks](#big-o-of-stacks)
  - [What is a queue?](#what-is-a-queue)
  - [enqueue/dequeue 메서드](#enqueuedequeue-메서드)
  - [Big O of Queues](#big-o-of-queues)
- [20. 이진 검색 트리(Trees)](#20-이진-검색-트리trees)
  - [What is a tree?](#what-is-a-tree)
  - [Where trees are used](#where-trees-are-used)
  - [Kind of Trees](#kind-of-trees)
  - [The Binary Search Trees](#the-binarysearchtree-class)
  - [insert 메서드](#insert-메서드)
  - [find 메서드](#find-메서드)
  - [Big O of Binary Search Trees](#big-o-of-binary-search-trees)
- [21. 트리 순회](#21-트리-순회)
  - [Two Ways of Traversing a Tree](#two-ways-of-traversing-a-tree)
  - [Breath-first Search(너비 우선 탐색)](#breath-first-search너비-우선-탐색)
  - [Depth-first Search - PreOrder(깊이 우선 탐색 - 전위 순회)](#depth-first-search---preorder깊이-우선-탐색---전위-순회)
  - [Depth-first Search - PostOrder(깊이 우선 탐색 - 후위 순회)](#depth-first-search---postorder깊이-우선-탐색---후위-순회)
  - [Depth-first Search - InOrder(깊이 우선 탐색 - 중위 순회)](#depth-first-search---inorder깊이-우선-탐색---중위-순회)
  - [BFS? DFS? Which is better?](#bfs-dfs-which-is-better)
- [22. 이진 힙(Binary Heaps)](#22-이진-힙binary-heaps)
  - [What is a binary](#what-is-a-binary)
  - [What does it look like?](#what-does-it-look-like)
  - [Max Binary Heap](#max-binary-heap)
  - [Why do we need to know this?](#why-do-we-need-to-know-this)
  - [Defining Heap class](#defining-heap-class)
  - [insert 메서드](#insert-eba994ec849ceb939c-1)
  - [ExtractMax 메서드](#extractmax-메서드)
  - [What is a Priority Queue(우선 순위 큐)](#what-is-a-priority-queue우선-순위-큐)
  - [Priority Queue](#priority-queue)
  - [PriorityQueue Class](#priorityqueue-class)
  - [Big O of Binary Heap](#big-o-of-binary-heap)
  - [Recap](#recap-1)
- [23. 해시 테이블(Hash Tables)](#23-해시-테이블hash-tables)
  - [What is a hash table?](#what-is-a-hash-table)
  - [Why should I care?](#why-should-i-care)
  - [The Hash](#the-hash)
  - [What makes a good hash?](#what-makes-a-good-hash)
  - [A HashTable Class](#a-hashtable-class)
  - [set/get메서드, keys/valuse 메서드](#setget-메서드-keysvalues-메서드)
- [24. 그래프(Graphs)](#24-그래프graphs)
  - [What are graphs?](#what-are-graphs)
  - [Uses for Graphs](#uses-for-graphs)
  - [Essential Graph Terms](#essential-graph-terms)
  - [그래프 정렬(인접 행렬/리스트)](#그래프-정렬인접-행렬리스트)
  - [Differences & Big O](#differences--big-o)
  - [Grpah Class](#grpah-class)
  - [Adding a Vertex / Adding an Edge](#adding-a-vertex--adding-an-edge)
  - [Removing an Edge / Removing a Vertex](#removing-an-edge--removing-a-vertex)
- [25. 그래프 순회(Graph Traversal)](#25-그래프-순회graph-traversal)
  - [Graph Traversal Uses](#graph-traversal-uses)
  - [Depth First](#depth-first)
  - [DFS - Recursive](#dfs---recursive)
  - [DFS - Iterative](#dfs---iterative)
  - [Breath First](#breath-first)
- [26. 다익스트라 알고리즘(Dijkstra's Algorithm)](#26-다익스트라-알고리즘dijkstras-algorithm)
  - [What is it](#what-is-it)
  - [Why is it useful?](#why-is-it-useful)
  - [Write Weighted Graph](#write-weighted-graph)
  - [The Approach](#the-approach)
  - [A Simple PQ](#a-simple-pq)
  - [Dijkstra's Pseudocode](#dijkstras-pseudocode)
  - [우선순위 큐 업그레이드](#우선순위-큐-업그레이드)
- [27. 동적 프로그래밍(Dynamic Programming)](#27-동적-프로그래밍dynamic-programming)
  - [What is a Dynamic Programming](#what-is-a-dynamic-programming)
  - [Overlapping Subproblems(중복되는 하위문제)](#overlapping-subproblems중복되는-하위문제)
  - [Fibonacci Sequence](#fibonacci-sequence)
  - [Optimal Substructure(최적 부분 구조)](#optimal-substructure최적-부분-구조)
  - [The Fibonacci Sequence](#the-fibonacci-sequence)
  - [Enter Dynamic Programming](#enter-dynamic-programming)
  - [Memorization](#memorization)
  - [타뷸레이션(Tabulation): 상향식 접근](#타뷸레이션tabulation-상향식-접근)

## 19. 스택(Stack)과 큐(Queues)

### Objectives

- Define what a stack is
- Understand use cases for a stack
- Implement operations on a stack data structure
- Define what a queue is
- Understand use cases for a queue
- Implement operations on a queue data structure

### What is a stack?

- 한 마디로 하면 스택은 후입선출의 원칙(**LIFO**)을 따르는 데이터들의 집합
- A **LIFO** data structure!
  - The last element added to the stack will be the first element removed from the stack
- 반대로 큐는 선입선출의 원칙을 따른다.

### How is it used?

Think about a stack of **plates**, or a stack of **markers** or a stack of ...**anything**  
As you pile it up the last thing (or the topmostthing) is what gets removed first

### How we'll visualize a stack

```
A siries of nodes!

     last     size = 4     first
       ---------------------
      |                     |
<--- 10 <--- 2 <--- 22 <--- 7
```

### Where stacks are used

- Managing function invocations
- Undo / Redo (command + z / command + shift + z와 같은..)
- Routing (this history object) is treated like a stack!
- And much more!

### Linked Lists의 개념을 활용해서 스택 셋업하기

- Singly Linked Lists의 `push`와 `pop`을 사용하지 않는 이유?
  - Singly Linked Lists에서 `pop`은 상수값의 시간을 가지지 않는다.
  - 전체 리스트를 순회해서 테일노드의 앞 노드를 알아야 하므로 상수값을 가지지 않는다.
- 그냥 리스트에서 맨 뒤에 추가와 제거를 스택에서 맨 앞에서 추가와 제거를 하면 된다.

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }
}
```

### push/pop 메서드

**Add** and **remove** a value to the **top** of the stack!

#### Push Pseducode

- The function should accept a value
- Create a new node with that value
- If there are no nodes in the stack, set the first and last property to be the newly created node
- If there is at least one node, create a variable that stores the current first property on the stack
- Reset the first property ot be the newly created node
- Set the next property on the node to be the previously created variable
- Increment the size of the stack by 1

#### Pop Pseudocode

- If there are no nodes in the stack, return null
- Create a temporary variable to store the first property on the stack
- If there is only 1 node, set the first and last property to be null
- If there is more than one node, set the first property to be the next property on the current first

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }

  push(value) {
    const newNode = new Node(value);
    if (!this.first) {
      this.first = newNode;
      this.last = newNode;
    } else {
      const temp = this.first;
      this.first = newNode;
      this.first.next = temp;
    }
    return ++this.size;
  }

  pop() {
    if (!this.first) return null;

    const temp = this.first;
    // this.size === 1
    if (this.first === this.last) {
      this.last = null;
    }
    // 가장 처음 들어간 노드의 next는 항상 null이므로 if 문 밖으로 빼줘서 노드가 둘 이상인 경우와 같이 한 번에 처리
    this.first = this.first.next;
    this.size--;

    return temp.value;
  }
}
```

### Big O of Stacks

- Insertion - O(1)
- Removal - O(1)
- Searching - O(n)
- Access - O(n)

### What is a queue?

- A **FIFO** data structure!
  - First In First Out
- Queues are useful for processing tasks and are foundational for more complex data structures

### enqueue/dequeue 메서드

#### Enqueue Pseudocode

- This function accepts some value
- Create a new node using that value passed to the function
- If there are no nodes in the queue, set this node to be the first and last property of the queue
- Otherwise, set the next property on the current last to be that node, and then set the last property of the queue to be that node
- Increment the size of the queue by 1
- Return the size of the queue

#### Dequeue Pseudocode

- If there is no first property, just return null
- Store the first property in a variable
- see if the first is the same as the last (check if there is only 1 node). If so, set the first and last to be null
- If there is more than 1 node, set the first property to be the next property of first
- Decrement the size by 1
- Return the value of the node dequeued

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Queue {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }

  enqueue(value) {
    const newNode = new Node(value);
    if (!this.first) {
      this.first = newNode;
      this.last = newNode;
    } else {
      this.last.next = newNode;
      this.last = newNode;
    }

    return ++this.size;
  }

  dequeue() {
    if (!this.first) return null;

    const temp = this.first;
    if (this.first === this.last) {
      this.last = null;
    }
    this.first = this.first.next;
    this.size--;

    return temp.value;
  }
}
```

### Big O of Queues

- Insertion - O(1)
- Removal - O(1)
- Searching - O(n)
- Access - O(n)
- Insertion and Removal can be done in **O(1)**

## 20. 이진 검색 트리(Trees)

### Objectives

- Defined what a tree is
- Compare and contrast trees and lists
- Explain the differences between trees, binary trees, and binary search trees
- Implement operations on binary search trees

### What is a tree?

- A data structure that consists of nodes in a **parent / child** relationship
  - **Lists** - linear(선형 구조)
  - **Trees** - nonlinear(비선형 구조)
- Tree Terminology
  - **Root** - The top node in a tree
  - **Child** - A node directly connected to another node when moving away from the Root
  - **Parent** - The converse notion of a child
  - **Siblings** - A group of nodes with the same parent
  - **Leaf** - A node with no children
  - **Edge** - The connection between one node and another

### Where trees are used

- Lots of different applications!
  - HTML DOM
    - 개발자 도구에 document.body.children[0].children...으로 출력하면 부모-자식 관계로 이루어진 것 확인 가능
    - 여러 요소들이 있고, 한 요소 안에 자식에 해당하는 다른 요소가 중첩되어 있다.
  - Network Routing
  - Abstract Syntax Tree(프로그래밍 언어로 작성된 추상 구문 트리)
  - Artificial Intelligence(인공 지능)
  - Folders in Operating Systems
  - Computer File Systems

### Kind of Trees

- Trees - 자식이 몇 개든 상관없다.
- Binary Trees - 각 노드가 최대 두 개의 자식을 가져야 하는 특별한 조건이 있다.
- Binary Search Trees - 특별한 방식으로 데이터가 순서대로 정렬된 이진 트리의 종류 중 하나
  - Every parent node has at most **two** children
  - Every node to the left of a parent node is **always less** than the parent
  - Every node to the right of a parent node is **always greater** than the parent
    ```
             41
          /     \
        20       65
      /   \     /  \
    11    29   50   91
      \     \      /  \
       12    32   72   99
    ```

### The BinarySearchTree Class

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySerachTree {
  constructor() {
    this.root = null;
  }
}
```

### insert 메서드

#### Insert Pseudocode(Steps - Iteratively or Recursively)

- Create a new node
- Starting at the root
- Check if there is a root, if not - the root now becomes that new node!
  - If there is a root, check if the value of the new node is greater than or less than the value of the root
  - If it is greater, Check to see if there is a node to the right
    - If there is, move to that node and repeat these steps
    - If there is not, add that node as the right property
  - If is less, Check to see if there is a node to the left
    - If there is, move to that node and repeat these steps
    - If there is not, add that node as the left property

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  insert(value) {
    const newNode = new Node(value);
    if (!this.root) {
      this.root = newNode;
      return this;
    } else {
      let current = this.root; // root를 시작점으로 자식으로 내려가면서 현재 노드위치를 나타내는 변수
      while (true) {
        if (value === current.value) return undefined;
        if (value < current.value) {
          if (!current.left) {
            // 왼쪽 가지가 빈 경우
            current.left = newNode;
            return this;
          }
          // 왼쪽 가지에 노드가 있는 경우
          current = current.left;
        } else {
          if (!current.right) {
            current.right = newNode;
            return this;
          }
          current = current.right;
        }
      }
    }
  }
}
```

### find 메서드

#### Finding Pseudocode

- Starting at the root
  - Check if there is a root, if not - we're done searching!
  - If there is a root, check if the vaue of the new node is the value we are looking for. If we found it, we're done!
  - If not, check to see if the value is greater than or less than the value of the root
  - If it is greater, check to see if there is a node to the right
    - If there is, move to that node and repeat these steps
    - If there is not, we're done searching!
  - If it is less, check to see if there is a node to the left
    - If there is, move to that node and repeat these steps
    - If there is not, we're done searching!

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  find(value) {
    if (this.root === null) return false;
    let current = this.root;
    let found = false;
    while (current && !found) {
      if (value < current.value) {
        current = current.left;
      } else if (value > current.value) {
        current = current.right;
      } else {
        found = true;
      }
    }
    if (!found) return false;
    return current;
  }

  // true, false 값만 반환하는 메서드
  contains(value) {
    if (this.root === null) return false;
    let current = this.root;
    let found = false;
    while (current && !found) {
      if (value < current.value) {
        current = current.left;
      } else if (value > current.value) {
        current = current.right;
      } else {
        return true;
      }
    }
    return false;
  }
}
```

```js
// 내가 만들어본 find 메서드
find(value) {
    if (this.root === null) return false;

    let current = this.root;
    while (true) {
      if (value === current.value) return current;
      if (value < current.value) {
        if (!current.left) return false;
        current = current.left;
      } else {
        if (!current.right) return false;
        current = current.right;
      }
    }
  }
```

### Big O of Binary Search Trees

- Insertion - **O(log n)**
- Searching - **O(log n)**
- 이미 데이터를 insert할 때 O(log n)으로 위치를 찾아 정렬하기 때문에 search할 때도 O(log n) 시간 복잡도로 데이터를 찾을 수 있다.
- **But, NOT guaranteed!**
  - 이진 탐색 트리는 평균적인 경우와 최고의 경우에 트리가 가지는 시간 복잡도는 O(log n)이다.
  - 최악의 경우
    - 3 -> 17 -> 19 -> 32 -> 34 -> 63 -> 86 -> 91 -> ...로 리스트처럼 한쪽으로 가지가 치우진 경우
    - 그러면 완전히 한 쪽으로 쏠린 트리에 대해서는 O(n)의 값을 가지게 된다.

## 21. 트리 순회

### Two Ways of Traversing a Tree

- Breath-first Search(너비 우선 탐색)
- Depth-first Search(깊이 우선 탐색)
  - InOrder(중위 순회)
  - PreOrder(전위 순회)
  - PostOrder(후위 순회)

### Breath-first Search(너비 우선 탐색)

- Create a queue (this can be an array) and a variable to store the values of nodes visited
- Place the root node in the queue
- Loop as long as there is anything in the queue
  - Dequeue a node from the queue and push the value of the node into the variable that stores the nodes
  - If there is a left property on the node dequeued - add it to the queue
  - if there is a right property on the ndoe dequeued - add it to the queue
- Return the variable that stores the values

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  BFS() {
    let node = this.root; // 순회할 때마다 변경될 노드
    const data = []; // 맨 마지막에 출력할 배열 생성
    const queue = []; // 순회하면서 노드를 넣을 배열(queue) 생성
    queue.push(node);

    while (queue.length) {
      // 빈 배열인 경우 true 값 가지니 queue.length로 조건 설정
      node = queue.shift();
      data.push(node); // 아님 node.value 노상관!
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    return data;
  }
}
```

### Depth-first Search - PreOrder(깊이 우선 탐색 - 전위 순회)

- Create a variable to store the values of nodes visited
- Store the root of the BST in a variable called current
- Write a helper function which accepts a node
  - Push the value of the node to the variable that stores the values
  - If the node has a left property, call the helper function nwith the left property on the node
  - If the node has a right property, call the helper function with the right property on the node
- Invoke the helper function with the current variable

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  DFSPreOrder() {
    const data = [];
    let current = this.root;
    function traverse(node) {
      data.push(node);
      if (node.left) traverse(node.left);
      if (node.right) traverse(node.right);
    }
    traverse(current);

    return data;
  }
}
```

### Depth-first Search - PostOrder(깊이 우선 탐색 - 후위 순회)

- Create a variable to store the values of nodes visited
- Store the root of the BST in a variable called current
- Write a helper funtion which accepts a node
  - If the node has a left property, call the helper function with the left property on the node
  - If the node has a right property, call the helper function with the right property on the node
  - Push the value of the node to the variable that stores the values
- Invoke the helper function with the current variable

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  DFSPostOrder() {
    const data = [];

    function traverse(node) {
      if (node.left) traverse(node.left);
      if (node.right) traverse(node.right);
      data.push(data.value);
    }
    traverse(this.root);

    return data;
  }
}
```

### Depth-first Search - InOrder(깊이 우선 탐색 - 중위 순회)

- Create a variable to store the values of nodes visited
- Store the root of the BST in a variable called current
- Write a helper funtion which accepts a node
  - If the node has a left property, call the helper function with the left property on the node
  - Push the value of the node to the variable that stores the values
  - If the node has a right property, call the helper function with the right property on the node
- Invoke the helper function with the current variable

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  DFSInOrder() {
    const data = [];

    function traverse(node) {
      node.left && traverse(node.left); // if 문 다르게 표현
      data.push(node);
      node.right && traverse(node.right);
    }
    traverse(this.root);

    return data;
  }
}
```

### BFS? DFS? Which is better?

#### BFS

- 100 레벨 정도 깊이 내려가야 하는 경우나 트리가 리스트처럼 한 쪽으로 치우친 경우를 생각하면 BFS에서 큐에 엄청난게 많은 데이터가 저장되기 때문에 무리일 수 있다.

#### DFS

- InOrder - 트리에 있는 모든 노드들을 오름차순으로 구할 수 있다.
- PreOrder - 트리를 복사하거나 linear시켜 저장하는 경우(파일이나 DB에 저장하기 위해) 다시 연쇄 구조로 만들어 낼 때 도움이 된다.

### Recap

- Trees are non-linear data structures that contain a root and child nodes
- Binary Trees can have values of any type, but at most two children for each parent
- Binary Search Trees are a more specific version of binary trees where every node to the left of a parent is less than it's value and every node to the right is greater
- We can search through Trees using BSF and DFS

## 22. 이진 힙(Binary Heaps)

### Objectives

- Define what a binary heap is
- Compare and contrast min and max heaps
- Implement basic methods on heaps
- Understand where heaps are used in the real world and what other data structures can be constructed from heaps

### What is a binary

**Very** similar to a binary search tree, but with some different rules!  
In a **MaxBinaryHeap**, parent nodes are always larger than child nodes. In a **MinBinaryHeap**, parent nodes are always smaller than child nodes

- For any index of an array `n`...
  - The left child is stored at `2n + 1`
  - The right child is at `2n + 2`
  - 배열 안에 있는 모든 인덱스에 대해 그 왼쪽 자식은 `2n+1`에 저장되어 있고, 오른쪽 자식은 `2n+2`에 저장되어 있다.
- For any child node at index `n`...
  - Its parent is at index `(n-1)/2`
  - 인덱스 n에 자식이 있다면 1을 빼고 2로 나눈 다음에 내림하면 부모를 찾을 수 있다.

### What does it look like?

```
        41
     /      \
   39        33
  /  \      /
18    27   12
```

- 이진 탐색 트리와는 다르게 왼쪽과 오른쪽에는 순서가 존재하지 않는다!

### Max Binary Heap

- Each parent has at most two child nodes
- The value of each parent node is **always** greater than its child nodes
- In a max Binary Heap the parent is greater than the children, but there are no guarantees between sibling nodes
  - **No Implied Ordering Between Siblings**
- A binary heap is as compact as possible. All the children of each node are as full as they can be and left children are filled out first
  - 이진 트리 탐색에서는 끝없이 요소를 추가할 수 있지만, **이진 힙은 최적의 용량(가능한 적은 공간)을 가진다.**

### Why do we need to know this?

Binary Heaps are used to implement Priority Queues, which are **very** commonly used data structures  
They are also used quite a bit, with **graph traversal** algorithms

### Defining Heap class

```js
class MaxBinaryHeap {
  constructor() {
    this.values = [];
  }
}
```

- 다른 트리나 리스트처럼 노드 클래스 또는 prev/next 포인터, left/right 포인터가 필요없다!

### insert 메서드

#### Insert Pseudocode

- Push the value into the values property on the heap
- Bubble the value up to tis correct spot!
  - Create a variable called index which is the length of the values property-1
  - Create a variable called parentIndex which is the floor of (index-1)/2
  - Keep looping as long as the values element at the parentIndex is less than the values element at the child index
    - Swap the value of the values element at the parentIndex with the value of the element property at the child index
    - Set the index to ve the parentIndex, and start over!

```js
class MaxBinaryHeap {
  constructor() {
    this.values = [];
  }

  bubbleUp() {
    let idx = this.values.length - 1;
    let element = this.values[idx];
    while (idx > 0) {
      // undefined와 비교하는 것 방지
      let parentIdx = Math.floor((idx - 1) / 2);
      let parent = this.values[parentIdx];
      if (element <= parent) break;

      // Swap!
      this.values[parentIdx] = element;
      this.values[idx] = parent;
      idx = parentIdx;
    }
  }

  insert(element) {
    this.values.push(element);
    this.bubbleUp();
  }
}

let heap = new MaxBinaryHeap();
// ex) [41, 39, 33, 18, 27, 12]에 heap.insert(55) 실행
// 결과: [55, 39, 41, 18, 27, 12, 33]
```

### ExtractMax 메서드

- Remove the root
- Replace with the most recently added
- Adjust (sink down)
- `sink down`?
  - The procedure for deleting the root from the heap (effectively extracting the maximum element in a max-heap or the minimum element in a min-heap) and restoring the properties is called _down-heap_ (also know as bubble-down, percolate-down, sift-down, treckle down, heapify-down, cascade-down, and extract-min/max)

#### ExtractMax Pseudocode

- Swap the first value in the values property with the last one
- Pop from the vlaues property, so you can return the value at the end
- Have the new root "sink down" to the correct spot..
  - Your parent index starts at 0(the root)
  - Find the index of the left child: `2 * index + 1` (make sure its not out of bounds)
  - Find the index of the right child: `2 * index + 2` (make sure its not out of bounds)
  - If the left or right child is greater than the element...swap. If both left and right children are larget, swap with the largest child.
  - The child index you wapped to now becomes the new parent index.
  - Keep looping and wapping until neither child is larger than the element
  - Return the old root!

```js
class BinaryHeap {
  constructor() {
    this.values = [];
  }

  extractMax() {
    const max = this.values[0];
    const end = this.values.pop();
    if (this.values.length > 0) {
      // 하나 남으면 this.values[0] = end; 때문에 제거되지 않아 조건문 설정
      this.values[0] = end;
      this.sinkDown();
    }

    return max;
  }

  sinkDown() {
    let idx = 0;
    const length = this.values.length;
    const element = this.values[idx];

    while (true) {
      let leftChildIdx = 2 * idx + 1; // 왼쪽 자식 인덱스
      let rightChildIdx = 2 * idx + 2; // 오른쪽 자식 인덱스
      let leftChild, rightChild;
      let swap = null;

      if (leftChildIdx < length) {
        leftChild = this.values[leftChildIdx];
        if (leftChild > element) {
          // 부모보다 왼쪽 자식이 큰 경우
          swap = leftChildIdx;
        }
      }

      if (rightChildIdx < length) {
        rightChild = this.values[rightChildIdx];
        //부모가 왼쪽 자식보다는 크지만 오른쪽 자식보다는 작은 경우, 부모보다 자식들이 크지만 오른쪽 자식이 더 큰 경우
        if (
          (swap === null && rightChild > element) ||
          (swap !== null && rightChild > leftChild)
        ) {
          swap = rightChildIdx;
        }
      }

      // 자리바꾸기를 하지 않는 경우 the most recently added element가 제대로 위치했기 때문에 루프 종료!
      if (swap === null) break;

      // Swap!
      this.values[idx] = this.values[swap];
      this.values[swap] = element;
      idx = swap;
    }
  }
}
```

### What is a Priority Queue(우선 순위 큐)

A data structure where each element has a priority.  
Elements with higer priorities are served before elements with lower priorities.

### Priority Queue

- Write a Min Binary Heap - lower number means higher priority
  - 1에 가까울 수록 우선순위가 높게 설정할 것이므로 최대 이진 힙이 아닌 최소 이진 힙 사용!
- Each Node has a val and a priority. Use the priority to build the heap
  - Value doesn't matter. Heap is constructed **using Priority**!
- `Enqueue` method accepts a value and priority, makes a new node, and puts it in the right spot based off of its priority.
- `Dequeue` method removes root element, returns it, and rearranges heap using priority.

### PriorityQueue Class

```js
class Node {
  constructor(value, priority) {
    this.value = value;
    this.priority = priority;
  }
}

class PriorityQueue {
  constructor() {
    this.values = [];
  }

  enqueue(value, priority) {
    const newNode = new Node(value, priority);
    this.values.push(newNode);
    this.bubbleUp();
  }

  bubbleUp() {
    let idx = this.values.length - 1;
    const element = this.values[idx];

    while (idx > 0) {
      let parentIdx = Math.floor((idx - 1) / 2);
      let parent = this.values[parentIdx];
      if (element.priority >= parent.priority) break;
      this.values[parentIdx] = element;
      this.values[idx] = parent;
      idx = parentIdx;
    }
  }

  dequeue() {
    const min = this.values[0];
    const end = this.values.pop();
    if (this.values.length > 0) {
      this.values[0] = end;
      this.sinkDown();
    }

    return min;
  }

  sinkDown() {
    let idx = 0;
    const length = this.values.length;
    const element = this.values[0];
    while (true) {
      let leftChildIdx = 2 * idx + 1;
      let rightChildIdx = 2 * idx + 2;
      let leftChild, rightChild;
      let swap = null;

      if (leftChildIdx < length) {
        leftChild = this.values[leftChildIdx];
        if (leftChild.priority < element.priority) {
          swap = leftChildIdx;
        }
      }

      if (rightChildIdx < length) {
        rightChild = this.values[rightChildIdx];
        if (
          (swap === null && rightChild.priority < element.priority) ||
          (swap !== null && rightChild.priority < leftChild.priority)
        ) {
          swap = rightChildIdx;
        }
      }

      if (swap === null) break;

      this.values[idx] = this.values[swap];
      this.values[swap] = element;
      idx = swap;
    }
  }
}

const ER = new PriorityQueue();
ER.enqueue("common cold", 5);
ER.enqueue("gunshot wound", 1);
ER.enqueue("hight fever", 4);
ER.enqueue("broken arm", 2);
ER.enqueue("glass in foot", 3);
```

### Big O of Binary Heap

- 이진 힙은 최대 힙이든 최소 힙이든 삽입과 삭제에 있어서 아주 성능이 좋다!
  - insertion - **O(log n)**
  - Removal - **O(log n)**
  - Search - **O(n)**

#### Why log(n)?

- 삽입할 때 16개 요소나 노드가 있으면 최대 4번의 비교로 새로 들어온 요소나 노드를 위치시킬 수 있기 때문이다!
  - 깊이는 4레벨까지 있고, 루트까지 비교하는데 최대 4번!

#### What about worst case?

- Binary Heap은 Binary Search Tree와 달리 왼쪽부터 채워지기 때문에 최악의 경우도 **O(log n)**이다!
  - 이진 힙은 따라서 탐색을 위한 것이 아니다.

### Recap

- Binary Heaps are very useful data structure for sotring, and implementing other data structures like priority queues
- Binary Heaps are either MaxBinaryHeaps or MinBinaryHeaps with parents either being smaller or larget than their children
- With just a little bit of math, we can represent heaps using arrays!
  - 약간의 수학 공식을 사용하면 배열을 가지고 힙을 쉽게 표현할 수 있다.

## 23. 해시 테이블(Hash Tables)

### Objectives

- Explain what a hash table is
- Define what a hashing algorithm
- Discuss what makes a good hasing algorithm
- Understand how collisions occur in a hash table
- Handle collisions using separate chaining or linear probing

### What is a hash table?

Hash tables are used to sotre _key-value_ pairs.  
They are like arrays, but the keys are not ordered.  
Unlike arrays, hash tables are _fast_ for all of the following operations: finding values, adding new values, and removing values!

### Why should I care?

Nearly every programming language has some sort of hash table data structure  
Because of their speed, hash tables are very commonly used!

#### Hash tables in the wild

- `Python` has **Dictionaries**
- `JS` has **Objects** and **Maps**
  - **Objects** have some restrictions, but are basically hash tables
- `Java`, `Go`, & `Scala` have **Maps**
- `Ruby` has... **Hashes**

### The Hash

- To implement a hash table, we'll be using an array.
- In order to look up values by key, we need a way to **convert keys into valid array indices**.
  - String을 가지고 숫자로 바꿔서 배열에 저장을 할 방법이 필요하다.
- A function that performs this task is called a `hash function`.

### What makes a good hash?

- Fast (i.e. constant time)
- Doesn't cluster outputs at specific indices, but distributes unifomly
  - 기본적으로 일관된 방식으로 분배를 해서 다른 것들과 겹치지 않게 해야 한다.
  - 모든 요소가 같은 자리에 저장돼야 한다.
- Deterministic (same input yields same output)
  - 좋은 해시 함수는 결정론적이다.
  - 특정 입력값을 입력할 때마다 같은 출력값이 나와야 한다.
  - 같은 출력값을 받게 되는 것이 이미 결정되어 있어야 한다는 것!

#### Non-Example

```js
// Fast에 어긋남 -> '상수값의 시간을 가지는 것이 필요하므로' 여러 번 반복되는 루프가 있어서는 안된다.
function slowHash(key) {
  for (let i = 0; i < 10000; i++) {
    console.log("everyday i'm hashing");
  }
  return key[0].charCodeAt(0);
}

// Uniformly Distributes Values에 어긋남
function sameHashedValue(key) {
  return 0;
}

// Deterministic에 어긋남
function randomHash(key) {
  return Math.floor(Math.random() * 1000);
}
```

#### Simple Hash Example

```js
// a hash function that works on string only
function hash(key, arrayLen) {
  let total = 0;
  for (let char of key) {
    // map "a" to 1, "b" to 2, "c" to 3, etc.
    let value = char.charCodeAt(0) - 96;
    total = (total + value) % arrayLen;
  }

  return total;
}
```

- Problems with the current hash
  - Only hashes strings
  - Not constant time - linear in key length
  - Could be a little more random

#### 해시 함수 성능 향상시키기

```js
function hash (key, arrayLen) {
  let total = 0;
  let WEIRD_PRIME = 31; // 입력한 데이터가 같은 그릇에 들어가지 않도록 충돌을 방지하기 위해 소수를 사용한다.
  for (let i = 0; i < Math.min(key, length, 100); i++) {
    let char = key[i];
    let value = char.charCodeAt(0) - 96;
    total = (total * WEIRD_PRIME + value) $ arrayLen;
  }

  return total;
}
```

#### Prime numbers?

The prime number in the hash is helpful in spreading out the keys more unifromly.  
It's also helpful if the array that you're putting values into hash a prime length.  
You don't need to know why because Math is complicated!

### Dealing with Collisions(충돌 처리)

Even with a large array and a great hash function , collisions are inevitable.  
There are many strategies fro dealing with collisions, but we'll focus on two:

1. Separate Chaining
2. Linear Probing

#### Separate Chaining

- With _separate chaining_, at each index in our array we store values using a more sophisticated data structure (e.g. an array or a linked list).
  - This allows us to store multiple key-value pairs at the same index.
  - 같은 장소에 여러 데이터를 저장할 때 배열이나 연결 리스트 등과 같은 것을 활용하여 이중 데이터 구조를 쓴다.
    - 그러면 테이블의 길이보다 더 많은 데이터를 저장할 수 있다.

#### Linear Probing

- With _linear probing_, when we find a collision, we search through the array to find the next empty slot.
  - 각 위치에 하나의 데이터만 저장한다는 규칙을 그대로 살리려고 한다.
  - 충돌이 발생하면 다음 빈 칸이 어디인지 확인해서 데이터가 같은 인덱스에 저장되는 것을 막는다.

### A HashTable Class

```js
class HashTable {
  constructor(size = 53) {
    // 해시 테이블의 크기 결정
    this.keyMap = new Array(size);
  }

  _hash(key) {
    let total = 0;
    let WEIRD_PRIME = 31;
    for (let i = 0; i < Math.mi(key.length, 100); i++) {
      let char = key[i];
      let value = char.charCodeAt(0) - 96;
      total = (total * WEIRD_PRIME + value) % this.keyMap.length;
    }

    return total;
  }
}
```

### set/get 메서드, keys/values 메서드

#### set

1. Accepts a key and a value
2. Hashes the key
3. Stores the key-value pair in the hash table array via **separate chaining**
   그냥 데이터를 저장하지 않고, 해당 자리에서 개별 체이닝을 통해 중첩 구조로 저장한다.

#### get

1. Accepts a key
2. Hashes the key (인덱스 값으로)
3. Retrieves the key-value pair in the hash table  
   인덱스 값으로 나온 위치로 가서 하나 이상의 요소가 있다면 key 값에 의존해서 중첩 구조 안에 key값이 있는지 확인한다.
4. 해시 테이블에 해당하는 것이 없다면 undefined 출력

#### keys

1. Loops through the hash table array and returns an array of keys in the table

#### values

1. Loops through the hash table array and returns an array of values in the table

```js
class HashTable {
  constructor(size = 53) {
    // 해시 테이블의 크기 결정
    this.keyMap = new Array(size);
  }

  _hash(key) {
    let total = 0;
    let WEIRD_PRIME = 31;
    for (let i = 0; i < Math.min(key.length, 100); i++) {
      let char = key[i];
      let value = char.charCodeAt(0) - 96;
      total = (total * WEIRD_PRIME + value) % this.keyMap.length;
    }

    return total;
  }

  set(key, value) {
    let index = this._hash(key);

    // 해당 위치에 key-value pair가 없는 경우(처음으로 해당 위치에 key-value가 들어가는 경우)
    if (!this.keyMap[index]) {
      this.keyMap[index] = [];
    }
    // [ , , , ,[[key, value], [key, value]], , , ] 형태로 중첩 구조로 추가
    this.keyMap[index].push([key, value]);

    return this;
  }

  get(key) {
    let index = this._hash(key);
    if (this.keyMap[index]) {
      for (let i = 0; i < this.keyMap[index].length; i++) {
        if (this.keyMap[index][i][0] === key) return this.keyMap[index][i][1];
      }
      // 내가 해본 것
      // for (let keyInIdx of this.keyMap[index]) {
      //   if (keyInIdx[0] === key) return keyInIdx[1];
      // }
    }

    return undefined;
  }

  values() {
    let valuesArr = [];
    for (let i = 0; i < this.keyMap.length; i++) {
      if (this.keyMap[i]) {
        for (let j = 0; j < this.keyMap[i].length; j++) {
          if (!valuesArr.includes(this.keyMap[i][j][1])) {
            valuesArr.push(this.keyMap[i][j][1]);
          }
        }
      }
    }

    return valuesArr;
  }

  keys() {
    let keysArr = [];
    for (let i = 0; i < this.keyMap.length; i++) {
      if (this.keyMap[i]) {
        for (let j = 0; j < this.keyMap[i].length; j++) {
          // 원래는 키가 중첩되면 덮어씌워지도록 set 메서드에서 설정해줘야 함
          if (!keysArr.includes(this.keyMap[i][j][0])) {
            keysArr.push(this.keyMap[i][j][0]);
          }
        }
      }
    }

    return keysArr;
  }
}

let ht = new HashTable();
ht.set("maroon", "#800000");
ht.set("yellow", "#FFFF00");
ht.set("olive", "#808000");
ht.set("salmon", "#FA8072");
ht.set("lightcoral", "#F08080");
ht.set("mediumvioletred", "#C71585");
ht.set("plum", "#DDA0DD");
```

### Big O of Hash Tables

- Average Case
  - Insert: O(1)
  - Deletion: O(1)
  - Access: O(1)
  - 위 빅오는 해시 함수가 얼마나 빠른지, 그리고 얼마나 고르게 데이터를 분배해서 충돌의 횟수를 줄이는지에 달려있다.
- Worst Case
  - 한 인덱스에 모든 것을 넣는 경우 -> O(n)
  - 이런 상황이 온다면 무언가를 가져오거나, 삽입하거나, 맨 뒤에서 제거를 하는 경우에는 n의 시간이 걸린다.
  - 해시 함수 자체가 상수값의 시간을 가진다고 해도 리스트와 다름없기 때문이다.

### Recap

- Hash tables are collections of key-value pairs
- Hash tables can find values quickly given a key
- Hash tables can add new key-values quickly
- Hash tables store data in a large array, and work by _hashing_ the keys
- A good hash sholud be fast, distribute keys uniformly, and be deterministic
  - 해시 함수는 빨라야 하고, 요소들 간의 충돌을 가능한 적게 일관된 방식으로 분배하며, 결정론적이어야 한다.
- Separate chaining and linear probing are two strategies used to deal with two keys that hash to the same index

## 24. 그래프(Graphs)

### Objectives

- Explain what a graph is
- Compare and contrast different types of graphs and their use cases in the real world
- Implement a graph using an adjacency list(인접 리스트)
- Traverse through a graph using BFS and DFS
- Compare and contrast graph traversal algorithms

### What are graphs?

A **graph data structure** consists of a finite (and possibly mutable) set of vertices or nodes or points, together with a set of unordered pairs of these vertices for an undirected **graph** or a set of ordered pairs for a directed **graph**.

- 그래프는 유한하고 변할 수 있는 꼭지점이나 노드나 점들의 집합으로 구성된 데이터 구조이다.
  - 이 꼭지점들의 집합에는 순서가 없는 경우에는 무방향 그래프, 순서가 있는 경우에는 유방향 그래프라고 한다.

### Uses for Graphs

- Social Networks(SNS 등)
- Location / Mapping(지도 기능 - 구글 지도나 방향 안내, 위치, 길 찾기 등)
- Routing Algorithms(라우팅 - 사이트를 요청하면 전체 네트워크에 퍼져있는 것 중 일부 연결 부위를 주는 것)
- Visual Hierarchy
- File System Optimizations
- Recommandations(아래처럼 추천 엔진도 예시가 될 수 있음)
  - "People also watched"
  - "You might also like..."
  - "People you might know"
  - "Frequently bought with"
- **EVERYWHERE!**
- 위 예시들을 만드는 방법이 모든 데이터를 그래프 관계로 저장하는 것이다!

### Essential Graph Terms

- **Vertext**(정점) - a node
- **Edge**(간선) - connection between nodes
  - 간선은 양쪽을 가리키고 있을 수도 한 방향만 가리킬 수도 있다.
- **Weighted/Unweighted**(가중/비가중) - values assigned to distances between vertices
  - 간선에 부여된 값로 순회를 하거나 최단경로를 계산할 때 이 값들을 사용할 수 있다.
- **Directed/Undirected**(방향/무방향) - directions assigned to distanced between vertices

### 그래프 정렬(인접 행렬/리스트)

- 연결 리스트에서는 노드 간의 next와 previous를, 이진 탐색 트리에서는 left와 right를 사용해서 관계를 정해줬지만 그래프에서는 사용할 수 없다.
  - 노드의 개수나 노드 사이의 연결인 간선의 개수가 정해져 있지 않기 때문이다.
- 대신 노드 간의 관계를 짓기 위해 `Adjacency Matrix/List(인접 행렬/리스트)`를 사용할 수 있다.
  - 인접 리스트의 경우 순서를 가지고 숫자를 다룬다면 배열의 자리를 사용해서 연결을 찾을 수 있지만
  - 순서를 가지지 않거나 글자를 다뤄야 하는 경우에는 **해시 테이블**을 사용한다.

```
무방향 그래프 예시
   0        * Adjacency Matrix     * Adjacency List
 /   \         \ 0 1 2 3 4 5           [
5     1        0 0 1 0 0 0 1         0  [1, 5],
|     |        1 1 0 1 0 0 0         1  [0, 2],
4     2        2 0 1 0 1 0 0         2  [1, 3],
 \   /         3 0 0 1 0 1 0         3  [2, 4],
   3           4 0 0 0 1 0 1         4  [3, 5],
               5 1 0 0 0 1 0         5  [4, 0]
                                       ]
무방향 그래프인데 순서가 없거나 문자를 다뤄야 하는 경우 -> '해시 테이블'로 해결
   A        * Adjacency List
 /   \         {
F     B         A: ["B", "F"],
|     |         B: ["A", "C"],
E     C         C: ["B", "D"],
 \   /          D: ["C", "E"],
   D            E: ["D", "F"],
                F: ["E", "A"]
              }
```

### Differences & Big O

- V - number of vertices(정점의 개수)
- E - number of edges(간선의 개수)

| OPERATION     | ADJACENCY LIST | ADJACENCY MATRIX |
| ------------- | -------------- | ---------------- |
| Add Vertex    | O(1)           | O( V^2 )         |
| Add Edge      | O(1)           | O(1)             |
| Remove Vertex | O( V + E )     | O( V^2 )         |
| Remove Edge   | O( E )         | O(1)             |
| Query         | O( V + E )     | O(1)             |
| Storage       | O( V + E )     | O( V^2 )         |

- 인접 행렬을 보면 `O(V^2)`의 값을 가지는 것을 볼 수 있는데 행렬이 2차원 구조이기 때문이다.
  - 새로운 정점을 추가하면 한 칸을 더하는 것이 아니라 행에 한 줄, 열에 한 줄을 추가하므로 `O(V^2)` 시간이 걸린다.
  - 간선의 개수와는 상관이 없고, 정점이 몇 개 있는지에 따라 달라진다.
  - 따라서 데이터가 퍼져있고 연결, 즉 간선이 많지 않으면 행렬을 사용하지 않는 것이 좋다.
- 인접 리스트에서는 간선과 정점의 개수에 비례하여 증가한다.
  - 간선이 많지 않고 퍼져있는 그래프에 대해서는 인접 리스트를 사용하는 것이 좋다.
  - 인접 행렬은 간선을 확인하고 싶으면 모든 간선에 대해 루프를 돌아서 찾아야 하므로 인접 리스트를 사용하는 것이 좋다.

#### Adjacency List

- Can take up less space (in sparse graphs)
  - 간선이 많지 않고 퍼져있는 그래프에 대해서는 인접 행렬보다 더 적은 공간을 차지한다.
- Faster to iterate over all edges
- Can be slower to lookup specific edge
  - 인접 리스트에서는 특정 간선이 존재하는 것을 확인하려면 느릴 수 있다.

#### Adjacency Matrix

- Takes up more space (in sparse graphs)
- Slower to iterate over all edges
- Faster to lookup specific edge
  - 인접 행렬에서는 특정 간서이 존재하는지 O(1) 시간 복잡도가 들기 때문에 더 빠르다.
- Most data in the real-world tends to lend itself to sparser and/or larger graphs
  - 실제로 세상에서 사용되는 데이터 대부분(SNS의 친구나 영화에 나오는 배우들이나 위키피이다의 문서들)은 보통 퍼져있는 경우가 많기 때문에 차지하는 공간이 덜드는 **인접 리스트**를 사용하는 것이 더 매력적이고 좋다.

### Grpah Class

```js
class Graph {
  constructor() {
    this.adjacencyList = {};
  }
}
```

- adjacencyList라는 프로퍼티 하나만 있으면 정점 사이의 연결, 관계 즉, 실제 간선들을 저장할 수 있다.
- 간성이 양방향인 무방향 그래프를 작업할 것이지만 간선이 한 방향으로만 연결되는 방향 그래프로 바꾸는 것은 간단하다.

### Adding a Vertex / Adding an Edge

#### Adding a Vertex

- Write a method called addVertex, which accepts a name of a vertex
- It should add a key to the adjacency list with the name of the vertex and set its value to be an empty array
  - 정점의 이름을 인접 리스트의 키로 입력하고 값은 빈 배열이다. 그냥 단순히 정점들을 입력하는 것!

#### Adding an Edge

- This function should accept two vertices, we can call them vertext1 and vertex2
- The function should find in the adjacency list the key of vertex1 and push vertex2 to the array
- The function should find in the adjacency list the key of vertex2 and push vertex1 to the array
- Don't worry about handling errors/invalid vertices
  - 그저 이것들이 어떻게 작동하는지에 좀 더 초점을 두고 보자

```js
class Graph {
  constructor() {
    this.adjacencyList = {};
  }

  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) this.adjacencyList[vertex] = [];
  }

  addEdge(vertex1, vertex2) {
    this.adjacencyList[vertex1].push(vertex2);
    this.adjacencyList[vertex2].push(vertex1);
  }
}

const g = new Graph();
g.addVertex("Dallas");
g.addVertex("Tokyo");
g.addVertex("Aspen");
g.addVertex("Los Angeles");
g.addVertex("Hong Kong");
g.addEdge("Dallas", "Tokyo");
g.addEdge("Dallas", "Aspen");
g.addEdge("Hong Kong", "Tokyo");
g.addEdge("Hong Kong", "Dallas");
g.addEdge("Los Angeles", "Hong Kong");
g.addEdge("Los Angeles", "Aspen");
```

### Removing an Edge / Removing a Vertex

#### Removing an Edge

- This function should accept two vertices, we'll call them vertex1 and vertex2
- The function should reassign the key of vertex1 to be an array that does not contain vertex2
- THe function should reassign the key of vertex2 to be an array that does not contain vertex1
  - 정점1에 있는 키에 대해 전에 있던 것은 다 그대로 있지만 정점2를 제거한 배열을 다시 부여하고 정점2에서도 똑같이 한다.
- Don't worry about handling errors/invalid vertices

#### Removing a Vertex

- This fuction should accept a vertex to remove
- The function should loop as long as there are any other vertices in the adjacency list for that vertex
  - 정점만 제거하는 것이 아니라 그와 관련된 간선들도 제거해줘야 한다. 그렇지 않으면 간선은 깨진채로 남는다.
- Inside of the loop, call our **removeEdge** function with the vertex we are removing and any values in the adjacency list for that vertex
  - 해당 정점에 있는 모든 간선에 대해 모두 **removeEdge**를 호출해서 제거한다.
- Delete the key in the adjacency list for that vertex
  - 마지막으로 adjacencyList에서 키를 삭제한다.

```js
class Graph {
  constructor() {
    this.adjacencyList = {};
  }

  removeEdge(vertex1, vertex2) {
    // 정점이 없는 경우 에러나는 것은 생각하지 않고 그래프의 기초만을 작업해서 이해하기
    this.adjacencyList[vertex1] = this.adjacencyList[vertex1].filter(
      (v) => v !== vertex2
    );
    this.adjacencyList[vertex2] = this.adjacencyList[vertex2].filter(
      (v) => v !== vertex1
    );
  }

  removeVertex(vertex) {
    while (this.adjacencyList[vertex].length) {
      const adjacencyVertex = this.adjacencyList[vertex].pop();
      this.removeEdge(vertex, adjacencyVertex); // 두 정점의 간선 제거
    }

    delete this.adjacencyList[vertex]; // 빈배열이 된 정점 제거
  }
}
```

## 25. 그래프 순회(Graph Traversal)

- 트리와는 다르게 그래프를 순회하는 코드를 짤 때는 this.root라는 것이 없기 때문에 시작점을 정해줘야 한다.
  - 그래프의 한 노드에서 다른 노드로 갈 때에는 유일한 하나의 길만이 있다는 보장이 없다는 것이다!

### Graph Traversal Uses

- Peer to peer networking
- Web crawlers
- Finding "closet" - matches/recommendations
- Shortest path problems
  - GPS Navigation
  - Solving mazes
  - AI (shortest path to win the game)

### Depth First

Explore as far as possible down one branch before "backtracking"

```
   A         {                          {
 /   \         "A": ["B", "C"],           "A": true, // Visiting Things
B     C        "B": ["A", "D"],           "B": true,
|     |        "C": ["A", "E"],           "D": true,
D --- E        "D": ["B", "E", "F"],      "E": true,
 \   /         "E": ["C", "D", "F"],      "C": true,
   F           "F": ["D", "E"]            "F": true,
             }                           }
```

- `A`에서 시작한다고 가졍하면, 빠른 알파벳 순서로 하면 `B`로 간다.
- 그 다음에 `B`에는 한 가지 선택지 밖에 없으므로 `D`로 간다. 두 가지 선택지가 있다.
- 알파벳 순서로 하면 먼저 `E`로 간다. 세 개의 간선이 있는데 이미 `D`에 다녀왔다는 것을 알고 선택지는 두 개가 된다.
- 알파벳 순서로 하면 `C`로 이동하고, `C`를 보면 `A`도 다녀왔고 `E`도 다녀왔으므로 막다른 길이 된다.
- 다시 `E`로 가서 `E`는 이미 끝냈으니 `F`로 간다. 그러면 끝!
- 이것이 깊이 우선 탐색의 기본으로 가지를 따라 가는 것이다!
  - 아래로 내려간다고 말하기 어려운데 그래프에서 깊이가 정확히 의미하는 것이 무엇인지 눈으로 보기 어렵기 때문이다.
  - 위 경우에는 그냥 루프로 보인다. 실제 의미는 인접점을 따라가고 따라가서 길이 막힐 때까지 가는 것이다.

### DFS - Recursive

- The function should accept a starting node
- Create a list to store the end result, to be returned at the very end
  - 빈 리스트, 배열을 만들어서 최종 결과를 저장하고 맨 뒤에 다시 돌려준다.
- Create an object to store visited vertices(정점을 저장할 수 있는 객체를 만든다)
  - The helper function should return early if the vertex is empty
  - The helper function should place the vertex it accepts into the visited object and push that vertex into the result array
  - Loop over all of the values(neighbors) in the adjacencyList for that vertex
  - If any of those values have not been visited, recursively invoke the helper function with that vertex
- Invoke the helper function with the starting vertex
  - 위 내부 함수는 결과 배열과 방문 표시 객체를 잘 최신화하면서 반복할 것이다.
- Return the result array

```
DFS(vertex):
  if vertex is empty
    return (this is base case)
  add vertex to results list
  mark vertex as visited
  for each neighbor in vertex's neighbors:
    if neighbor is not visited:
      recursively call DFS on neighbor
```

```js
// 그래프 구조를 만들기 위해 미리 작성한 코드
g.addVertex("A");
g.addVertex("B");
g.addVertex("C");
g.addVertex("D");
g.addVertex("E");
g.addVertex("F");

g.addEdge("A", "B");
g.addEdge("A", "C");
g.addEdge("B", "D");
g.addEdge("C", "E");
g.addEdge("D", "E");
g.addEdge("D", "F");
g.addEdge("E", "F");
```

#### Graph DFS Recursive 메서드 작성

```js
class Graph {
  constructor() {
    this.adjacencyList = {};
  }

  depthFirstRecursive(start) {
    const result = []; // 마지막에 반환할 배열
    const visited = {}; // 방문한 정점에 대한 객체
    // helper 함수 안에서 this가 달라지므로 실제 그래프 자체인 this.adjacencyList를 변수에 할당
    const adjacencyList = this.adjacencyList;

    // result와 visited에 데이터를 추가하고 맨 뒤에 작업을 마치면 result를 돌려주는 helper함수 작성
    (function DFS(vertex) {
      // 해당 vertex가 비어 있는지 확인
      // 이 줄의 맨 마지막에 도달하면 더 이상 DFS에 입력할 것이 없어지게 된다.
      if (!vertex) return null;

      visited[vertex] = true; // 방문하면 true 값으로 visited 객체에 넣어주기
      result.push(vertex);

      adjacencyList[vertex].forEach((neighbor) => {
        // 방문하지 않았다면 해당 점점에 대해 헬퍼 함수를 재귀식으로 호출한다.
        if (!visited[neighbor]) {
          return DFS(neighbor);
        }
      });
    })(start);

    return result;
  }
}

g.depthFirstRecursive("A"); // ["A", "B", "D", "E", "C", "F"]
```

- 한 정점을 방문하고 그 정점의 인접한 정점을 방문하고 다시 그 인접한 정점을 방문하는 것을 반복하면서 visited와 result에 접정의 값을 넣는다.

### DFS - iterative

- The function should accept a starting node
- Create a stack to help use keep track of vertices (use a list/array)
- Create a list to store the end result, to be returned at the very end
- Create an object to store visited vertices
- Add the starting vertex to the stack, and mark it visited
- While the stack has something in it:
  - Pop the next vertex from the stack
  - If that vertex hasn't been visited yet:
    - Mark it as visited
    - Add it to the result list
    - Push all of its neighbors into the stack
- Return the result array

```
DFS-iterative(start):
  let S be a stack
  S.push(start)
  while S is not empty
    vertex = S.pop()
    if vertex is not labeled as discovered:
      visit vertex (add to result list)
      label vertex as discovered
      for each of vertex's neighbors, N do
        S.push(N)
```

#### Graph DFS Iterative 메서드 작성

```js
class Graph {
  constructor() {
    this.adjacencyList = {};
  }

  depthFirstIterative(start) {
    const result = [];
    const visited = {};
    const stack = [start]; // 정점 push하고 시작
    let currentVertex; // 루프 안에서 매번 다시 정의하는 대신 위에서 먼저 정의(사소한 차이임)
    visited[start] = true;

    while (stack.length) {
      currentVertex = stack.pop();
      result.push(currentVertex);

      this.adjacencyList[currentVertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true;
          stack.push(neighbor);
        }
      });
    }

    return result;
  }
}

g.depthFirstIterative("A"); // ["A", "C", "E", "F", "D", "B"]
```

### Breath First

Visit neighbors at current depth first!

#### BFS Pseudocode

- This function should accept a starting vertex
- Create a queue (you can use an array) and place the starting vertex in it
- Create an array to store
- Create an object to store nodes visited
- Mark the starting vertex as visited
- Loop as long as there is anything in the queue
- Remove the first vertex from the queue and push it into the array that stores nodes visited
- If it is not inside the object that stores nodes visited, mark it as visited and enqueue that vertex
- Once you have finished looping, return the array of visited nodes

```js
class Graph {
  constructor() {
    this.adjacencyList = {};
  }

  breathFirst(start) {
    const queue = [start];
    const result = [];
    const visited = {};
    let currentVertex;
    visited[start] = true;

    while (queue.length) {
      currentVertex = queue.shift();
      result.push(currentVertex);

      this.adjacencyList[currentVertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true;
          queue.push(neighbor);
        }
      });
    }

    return result;
  }
}

g.breathFirst("A"); // ["A", "B", "C", "D", "E", "F"]
```

## 26. 다익스트라 알고리즘(Dijkstra's Algorithm)

### Objectives

- Understand the importance of **Dijkstra's**
- Implment a Weighted Graph
- Walk through the steps of **Dijkstra's**
- Implement **Dijkstra's** using a naive priority queue
- Implement **Dijkstra's** using a binary heap priority queue

### What is it

- One of the most famous and widely used algorithms around!
- Find the shortest path between two vertices on a graph
  - like "What's the fastest way to get from point A to point B?"
  - 정말 큰 그래프에서는 수백만, 수천만 가지의 선택지가 있고, 가장 짧은 것을 계산할 때 **다익스트라 알고리즘**으로 처리한다.
- 다익스트라 알고리즘을 작성하기 위해서는 두 가지 데이터 구조를 알고 있어야 한다.
  - 그래프 - 다익스트라 알고리즘은 그래프에 대해 작동한다. 그래프를 가로지르며 탐색한다.
  - 우선순위 큐 - 이진힙을 이용해서 우선순위 큐를 만들고 이를 사용해 다익스트라 알고리즘을 작성한다.

### Why is it useful?

- GPS - finding fastest route
- Network Routing - find opend shortest path for data
- Biology - used to model the spread of viruses among humans
- Airline tickets - finding cheapest route to your destination
- Many other uses!

### Write Weighted Graph

간선에 가중치를 저장하기 위해 가중치 그래프 작성

```js
class WeightedGraph {
  constructor() {
    this.adjacencyList = {};
  }

  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) this.adjacencyList[vertex] = [];
  }

  addEdge(vertex1, vertex2, weight) {
    this.addjacencyList[vertex1].push({ node: vertex2, weight });
    this.addjacencyList[vertex2].push({ node: vertex1, weight });
  }

  // 간선을 제거하는 것과 정점을 제거하는 것은 생략
  // 갹채룰 재고햐여 헌더눈 곳먼 재외하면 앞에서 제거하는 것과 유사하다.
}

// {
//   "A": [{ node: "B", weight: 10 }]
// }
```

### The Approach

```
Find the shortest path from A to E
       A               Vertex | Shortest Dist From A  * Visited: [A, C, B, D, F]
     /   \ 4             A    |          0            * Previous: {
  2 /     \              B    |    Infinity -> 4                    A: null,
   /       B             C    |    Infinity -> 2                    B: A,
  / 2    3 | 3           D    |    Infinity -> 4                    C: A,
 C -- D -- E             E    |    Infinity -> 7 -> 6               E: B -> F,
4 \  1|  / 1             F    |    Infinity -> 5                    F: D
    \ | /                                                         }
      F
```

1. Every time we look to visit a new node, we pick the node with the smallest known distance to visit first.  
   처음 가장 작은 것으로 알려진 거리값을 가진 노드 방문
2. Once we've moved to the node we're going to visit, we look at each of its neighbors  
   그 노드로 이동한 다음에 그 인접점들을 보면서 살펴보기
3. For each neighboring node, we calculate the distance by summing the total edges that lead to that node we're checking _from the starting_ node.  
   각각의 인접한 노드에 대해 시작한 노드에서부터 해당 인접점까지의 거리를 합을 내어 구한다.
4. If the new total distance to a node is less than the previous total, we store the new shorter distance for that node.  
   각 인접점에 대해서 우리가 이미 알고 있는 시작한 노드("A")로부터의 거리보다 새로운 거리가 짧으면 파일을 최신화한다.

### A simple PQ

```js
class PriorityQueue {
  constructor() {
    // 단순한 배열로 다음 방문할 노드를 알려준다.
    this.values = [];
  }

  enqueue(val, priority) {
    this.values.push({ val, priority }); // 무언가를 추가할 때마다 우선순위를 부여
    this.sort();
  }

  dequeue() {
    return this.values.shift();
  }

  sort() {
    this.values.sort((a, b) => a.priority - b.priority);
  }
}
```

- Notice we are sorting which is O(N \* log(N))
- PQ에서 할 일은 WeightedGraph의 값들을 push해서 우선순위순으로 재정렬한다.

### Dijkstra's Pseudocode

- This function should accept a starting and ending vertex
- Create an object (we'll call it distances) and set each key to be every vertex in the adjacency list wit a value of infinity, except for the starting vertex which should have a value of 0.
  - 시작하는 정점을 제외하고 그 외 정점들과의 거리가 얼마나 먼지를 모르기 때문에 infinity로 설정
- After setting a value in the distances object, add each vertex with a priority of Infinity to the priority queue, except the starting vertex, which should have a priority of 0 because that's where we begin
  - 모든 값들을 distances 객체 안에서 설정을 한 뒤에는 우선순위 큐를 만든다.
- Create another object called previous and set each key to be every vertex in the adjacency list with a value of null
- Start looping as long as there is anything in the priority queue
  - dequeue a vertex from the priority queue
  - If that vertex is the same as the ending vertex - we are done!
  - Otherwise loop through each value in the adjacency list at that vertex
    - Calculate the distance to that vertex from the starting vertex
    - if the disance is less than what is currently stored in our distances object
      - Update the distances object with new lower distance(같은 정점을 새로운 낮은 거리와 함께 enqueue)
      - Update the previous object to contain that vertex
      - enqueue the vertex with the total disatnce from the start node

```js
class PriorityQueue {
  constructor() {
    this.values = [];
  }

  enqueue(value, priority) {
    this.values.push({ value, priority });
    this.sort();
  }

  dequeue() {
    return this.values.shift();
  }

  sort() {
    this.values.sort((a, b) => a.priority - b.priority);
  }
}

class WeightedGraph {
  constructor() {
    this.adjacencyList = {};
  }

  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) this.adjacencyList[vertex] = [];
  }

  addEdge(vertex1, vertex2, weight) {
    this.adjacencyList[vertex1].push({ node: vertex2, weight });
    this.adjacencyList[vertex2].push({ node: vertex1, weight });
  }

  dijkstra(start, finish) {
    const node = new PriorityQueue();
    // Create an object and set each key to be every vertex in the adjacency list wit a value of infinity
    const distances = {};
    // Create another object and set each key to be every vertex in the adjacency list with a value of null
    const previous = {}; // ex) C/E에 대해서 가장 빨리 갈 수 있는 경로는 A/F를 통한 것이라는 식으로 저장
    const path = []; // to return at end
    let smallest;

    // build up initial state(adjacencyList 전체에 대해 루프를 걸어야 한다)
    for (let vertex in this.adjacencyList) {
      if (vertex === start) {
        distances[vertex] = 0;
        node.enqueue(vertex, 0); // 우선순위 큐에 우선순위를 가진 정점들을 저장
      } else {
        distances[vertex] = Infinity;
        node.enqueue(vertex, Infinity);
      }

      previous[vertex] = null;
    }

    // as long as there is something to visit
    while (node.values.length) {
      smallest = node.dequeue().value; // 우리가 실제 방문하는 노드
      // If that vertex is the same as the ending vertex - we are done!
      if (smallest === finish) {
        while (previous[smallest]) {
          path.push(smallest);
          smallest = previous[smallest]; // start 정점인 경우에는 값이 null이므로 루프 종료
        }
        break;
      }
      // Otherwise loop through each value in the adjacency list at that vertex
      if (smallest || distances[smallest] !== Infinity) {
        // 그렇지 않은 경우 해당 점점이 adjacencyList에 가지고 있는 각 인접점에 대해서 루프를 돌려야 한다.
        for (let neighbor in this.adjacencyList[smallest]) {
          // find neighboring node
          let nextNode = this.adjacencyList[smallest][neighbor]; // 인접한 노드들
          // calculate new distances to neighboring node
          let candidate = distances[smallest] + nextNode.weight; // 방문한 노드(A에서부터 거리)와 인접한 노드의 거리 합산
          let nextNeighbor = nextNode.node;
          // distances 내의 nextNode의 값이 방문하고 있는 노드와 인접한 노드의 거리 합산보다 크면
          if (candidate < distances[nextNeighbor]) {
            // updating new smallest distance to neighbor
            distances[nextNeighbor] = candidate;
            // updating previous - How we got to neighbor
            previous[nextNeighbor] = smallest; // 더 짧은 경로가 바뀌었으므로 previous[nextNeighbor]의 값을 업데이트
            // enqueue in priority queue with new priority
            node.enqueue(nextNeighbor, candidate);
          }
        }
      }
    }
    // 마지막 스타트 정점만 push하지 못하고 루프를 나왔으므로 concat으로 push해주고 reverse() 메서드로 바꿔준다.
    return path.concat(smallest).reverse();
  }
}

const graph = new WeightedGraph();
graph.addVertex("A");
graph.addVertex("B");
graph.addVertex("C");
graph.addVertex("D");
graph.addVertex("E");
graph.addVertex("F");

graph.addEdge("A", "B", 4);
graph.addEdge("A", "C", 2);
graph.addEdge("B", "E", 3);
graph.addEdge("C", "D", 2);
graph.addEdge("C", "F", 4);
graph.addEdge("D", "E", 3);
graph.addEdge("D", "F", 1);
graph.addEdge("E", "F", 1);

graph.dijkstra("A", "E"); // ["A", "C", "D", "E", "F"] -> previous["F"]의 값이 6으로 제일 짧은 경로이다.
```

- let candidate = distances[smallest] + nextNode.weight;
  - 시작노드(A)부터 smallest(현재 방문한 노드)의 거리가 distances 객체에 저장되어 있다.
  - nextNode(\* this.adjacencyList[smallest][neighbor], 인접한 노드)까지의 거리를 합산한 값이
  - candidate보다 더 크게 되면 distances[nextNode.node]의 값을 candidate으로 업데이트한다.

### 우선순위 큐 업그레이드

```js
class Node {
  constructor(value, priority) {
    this.value = value;
    this.priority = priority;
  }
}

class PriorityQueue {
  constructor() {
    this.values = [];
  }

  enqueue(val, priority) {
    let newNode = new Node(val, priority);
    this.values.push(newNode);
    this.bubbleUp();
  }

  bubbleUp() {
    let idx = this.values.length - 1;
    const element = this.values[idx];
    while (idx > 0) {
      let parentIdx = Math.floor((idx - 1) / 2); // 부모 노등에 접근
      let parent = this.values[parentIdx];
      if (element.priority >= parent.priority) break;
      this.values[parentIdx] = element;
      this.values[idx] = parent;
      idx = parentIdx;
    }
  }

  dequeue() {
    const min = this.values[0];
    const end = this.values.pop();
    if (this.values.length > 0) {
      this.values[0] = end;
      this.sinkDown();
    }

    return min;
  }

  sinkDown() {
    let idx = 0;
    const length = this.values.length;
    const element = this.values[0];

    while (true) {
      let leftChildIdx = 2 * idx + 1;
      let rightChildIdx = 2 * idx + 2;
      let leftChild, rightChild;
      let swap = null;

      if (leftChildIdx < length) {
        leftChild = this.values[leftChildidx];
        if (leftChild.priority < element.priority) {
          swap = leftChildIdx;
        }
      }
      if (rightChildIdx < length) {
        rightChild = this.values[rightChildIdx];
        if (
          (swap === null && rightChild.priority < element.priority) ||
          (swap !== null && rightChild.priority < leftChild.priority)
        ) {
          swap = rightChildIdx;
        }
      }

      if (swap === null) break; // 제 위치에 있어 루프 종료
      // 더 priority값이 작은 자식 노드와 swap
      this.values[idx] = this.values[swap];
      this.values[swap] = element;
      idx = swap;
    }
  }
}
```

- 위 우선순위 큐는 매번 새로운 요소가 들어올 때마다 전체 배열을 정렬해야 해서 좀 느린 편이다.

## 27. 동적 프로그래밍(Dynamic Programming)

### Objectives

- Define what dynamic programming is
- Explain what overlapping subproblems are
- Understand what optimal substructure is
- Solve more challenging problems using dynamic programming

### What is a Dynamic Programming

A method for solving a complex problem vy breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.  
복잡한 문제를 더 간단한 하위 문제의 모음으로 쪼개서 각 하위 문제들을 풀어서 그 답을 저장하는 방식으로 문제를 해결한다.

- 간단하게 말하면 문제를 푸는데 사용할 수 있는 접근법 중 하나로 동적 프로그래밍으로 풀 수 있는 문제들에 있어 성능에 아주 큰 차이를 가져온다.
- It only works on problems with `Optimal Substructure` & `Overlapping Subproblems`

### Overlapping Subproblems(중복되는 하위문제)

- A problem is said to have **overlapping subproblems** if it can be broken down into subproblems which are reused several times
  - 한 문제를 더 작은 문제들로 나눌 수 있고, 그 조각들 중 일부가 재활용 가능할 수 있는 중첩되는 하위 문제가 있어야 한다.
  - 각각의 조각이 다른 모습이 아닌 여러 번 재사용되어야 한다.

### Fibonacci Sequence

- Every number after the first two is the sum of the two preceding ones
- 피보나치 수열도 동적 프로그래밍을 사용해서 해결할 수 있는 문제인데, 반복되는 하위문제들을 가지고 있다.

```
피보나치 수열 5번째 수 구하기
                   fib(5)
              /             \
           fib(4)   +      fib(3)
         /      \        /        \
      fib(3) + fib(2)  fib(2) + fib(1)
  /        \
fib(2) + fib(1)
```

- 이 안에는 하위 문제가 있다. 그리고, 한 문제를 더 작은 여러 단계들로 나눈다.
  - 위 문제는 보통 재귀를 통해서 처리한다.
  - 재귀형 해답이라 해서 꼭 중첩된다는 의미는 아니고,
  - 문제가 반복된다는 표현을 사용하는 경우 반복되는 것들 즉, 하위 문제가 반복되는지를 확인해야 한다.

### Optimal Substructure(최적 부분 구조)

- A problem is said to have **optimal substructure** if an optimal solution can be constructed from optimal solutions of its subproblems
  - 하위 문제의 최적 해답을 통해서 더 큰 범주의 문제의 최적 해답을 구성할 수 있는 경우 해당 문제를 최적 부분 구조라 할 수 있다.
  - 피보나치 수열의 경우도 5번째 수를 구하기 위해 네번째 세번째 수를 더하고 세번째 수를 구하기 위해 두번째 수와 첫 번쨰 수를 더하듯 최적 부분 구조로 이루어졌다고 할 수 있다.

#### Shortest Path

```
그래프에서 정점 사이의 최단 경로
  2
A ➡️ B  3  D
  2 ⬇️ ↘️  ⬆️ 1
    E  ➡️  C
       2

Shortset Path From:
A to D     A -> B -> C -> D
A to C     A -> B -> C
A to B     A -> B
```

- 위 문제도 최적 부분 구조를 가지고 있다고 할 수 있다.
  - A에서 D로 가는 경로에 대한 최적의 해답을 그 하위 문제들과 그 문제들의 최적의 해답을 가지고 구성할 수 있기 때문이다.
  - 이 때, 하위 문제는 위 문제의 경우 A에서 C로 가는 최단 경로가 된다.
  - 그리고 A에서 C로 가는 최단 경로는 A, B, C이고, A에서 B로 가는 최단 경로는 A, B가 된다.
- 따라서 그 하위 문제들을 가지고, 먼저 B로 가는 최단 경로를 찾고, 그 다음 C, 그 다음 D로 가는 최단 경로를 찾는 것이다.

### The Fibonacci Sequence

- 피보나치 수열은 `Overlapping Subproblems`와 `Optimal Substructure` 두 가지 특성을 다 가지고 있다.
  - Fib(n) = Fib(n-1) + Fib(n-2)
  - Fib(2) = 1
  - Fib(1) = 1

```js
function fibonacci(n) {
  if (n <= 2) return 1;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

- 실제로는 매우 비효율적인 코드이다.

#### Big O of Fibonacci Sequence

- 실제 수학공식으로 정확한 빅오 표기법은 아니지만 위 피보나치 수열 함수의 빅오는 `O(2^n)`이다.
  - n은 지수로 매우 좋지 않은 빅오 중 하나이다. 그리고 실제로는 대략 1.6의 n제곱이다.

#### What can we improve?

- 핵심은 `What if we could "remember" old values?` 이다.
  - 계산했던 값을 기억할 수 있도록 만드는 것이 동적 프로그래밍의 핵심이다.

### Enter Dynamic Programming

- Using past knowledge to make solving a future problem easier
  - 과거에 얻은 지식을 미래의 문제를 더 쉽게 풀기 위해 사용하는 것이
  - Dynamic Programming에서 **복잡한 문제를 더 간단한 하위 문제들의 모음으로 쪼개서 풀어내는 방법**인 것이다.
  - 하지만, 위 피보나치 수열은 하위 문제들로 쪼개져 있지만 다시 사용할 수 있도록 하지 않았다.

### Memorization

- Storing the results of expensive function calls and returning the cached result when the same inputs occur again
  - 핵심은 보통 배열이나 객체인 데이터를 저장할 구조를 만든 다음에 시간이 오래 걸리는 함수를 실행해 간단하게 테이블이나 배열을 확인해서 이미 값이 있는지 확인해 가져온다.

#### A Memorized Solution

```js
function fib(n, memo = []) {
  if (memo[n] !== undefined) return memo[n];
  if (n <= 2) return 1;
  let res = fib(n - 1, memo) + fib(n - 2, memo); // memo를 지닌 함수로 호출해야 한다.
  memo[n] = res;
  return res;
}
```

```
         fib(7)
       /        \
    fib(6)  +  fib(5)
   /      \
fib(5) + fib(4)
```

- 위 함수를 이용하면 fib(7)을 실행시켰을 때 fib(5)을 두 번 시켜야 하는 것을 memo에 저장해서 한 번으로 줄일 수 있다.
  - 그리고 fib(4)도 memo 배열에 접근해서 바로 가져올 수 있다.

```js
// memo에 엘리먼트를 미리 할당해서 코드 줄이기(약간 투박하다고 생각할 수 있음)
function fib(n, memo = [undefined, 1, 1]) {
  if (memo[n] !== undefined) return memo[n];
  let res = fib(n - 1, memo) + fib(n - 2, memo); // memo를 지닌 함수로 호출해야 한다.
  memo[n] = res;
  return res;
}
```

#### Big O of Memorized Solution

- fib(7)의 경우 fib(6), fib(5), fib(4), fib(3)의 값만 구하면 된다.
  - fib(2), fib(1)는 상수값의 시간을 가지기 때문에 포함할 필요가 없다.
- 따라서, n이 커짐에 따라 알고리즘을 실행하는데 걸리는 시간은 `O(n)`이 걸리게 된다.

### 타뷸레이션(Tabulation): 상향식 접근

- We've been working `TOP-DOWN`. but, there is another way! `BOTTOM-UP`
- Storing the result of a previous result in a "table" (usually an array)
  - Usually done using **iteration**
  - Better **space complexity** can be achieved using tabulation
- 타뷸레이션에서는 보통 루프와 같이 순환을 통해서 작업한다.
  - 가장 작은 하위 문제를 푼 다음에 그 결과를 테이블에 저장한다.

```js
function fib(n) {
  if (n <= 2) return 1;

  const fibNums = [0, 1, 1];
  for (let i = 3; i <= n; i++) {
    fibNums[i] = fibNums[i - 1] + fibNums[i - 2];
  }

  return fibNums[n];
}
```

- `TOP-DOWN` 방식으로 해결한 **Memorized Solution**은 재귀를 사용했기 때문에 fib(10000)처럼 큰 수를 실행하는 경우 스택에서 대기하고 있는 해결되지 않은 재귀 호출들이 있을 수 있게 되서 **Maximum call stack size exceeded** 에러가 발생하게 된다.
- 하지만 `BOTTOM-UP` 방식인 **Tabulation**은 공간을 많이 차지 않기 때문에 같은 오류가 발생하지는 않는다.
  - 물론 fib(10000) 하게 되면 Infinity 값을 얻게 된다.
