# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [19. 스택(Stack)과 큐(Queues)](#19-스택stack과-큐queues)
  - [What is a stack?](#what-is-a-stack)
  - [How is it used?](#how-is-it-used)
  - [How we'll visualize a stack](#how-well-visualize-a-stack)
  - [Where stacks are used](#where-stacks-are-used)
  - [Linked Lists의 개념을 활용해서 스택 셋업하기](#linked-lists의-개념을-활용해서-스택-셋업하기)
  - [push/pop 메서드](#pushpop-메서드)
  - [Big O of Stacks](#big-o-of-stacks)
  - [What is a queue?](#what-is-a-queue)
  - [enqueue/dequeue 메서드](#enqueuedequeue-메서드)
  - [Big O of Queues](#big-o-of-queues)
- [20. 이진 검색 트리(Trees)](#20-이진-검색-트리trees)
  - [What is a tree?](#what-is-a-tree)
  - [Where trees are used](#where-trees-are-used)
  - [Kind of Trees](#kind-of-trees)
  - [The Binary Search Trees](#the-binarysearchtree-class)
  - [insert 메서드](#insert-메서드)
  - [find 메서드](#find-메서드)
  - [Big O of Binary Search Trees](#big-o-of-binary-search-trees)
- [21. 트리 순회](#21-트리-순회)
  - [Two Ways of Traversing a Tree](#two-ways-of-traversing-a-tree)
  - [Breath-first Search(너비 우선 탐색)](#breath-first-search너비-우선-탐색)
  - [Depth-first Search - PreOrder(깊이 우선 탐색 - 전위 순회)](#depth-first-search---preorder깊이-우선-탐색---전위-순회)
  - [Depth-first Search - PostOrder(깊이 우선 탐색 - 후위 순회)](#depth-first-search---postorder깊이-우선-탐색---후위-순회)
  - [Depth-first Search - InOrder(깊이 우선 탐색 - 중위 순회)](#depth-first-search---inorder깊이-우선-탐색---중위-순회)
  - [BFS? DFS? Which is better?](#bfs-dfs-which-is-better)
- [22. 이진 힙(Binary Heaps)](#22-이진-힙binary-heaps)
  - [What is a binary](#what-is-a-binary)
  - [What does it look like?](#what-does-it-look-like)
  - [Max Binary Heap](#max-binary-heap)
  - [Why do we need to know this?](#why-do-we-need-to-know-this)
  - [Defining Heap class](#defining-heap-class)
  - [insert 메서드](#insert-eba994ec849ceb939c-1)
  - [ExtractMax 메서드](#extractmax-메서드)
  - [What is a Priority Queue(우선 순위 큐)](#what-is-a-priority-queue우선-순위-큐)
  - [Priority Queue](#priority-queue)
  - [PriorityQueue Class](#priorityqueue-class)
  - [Big O of Binary Heap](#big-o-of-binary-heap)
  - [Recap](#recap-1)
- [23. 해시 테이블(Hash Tables)](#23-해시-테이블hash-tables)

## 19. 스택(Stack)과 큐(Queues)

### Objectives

- Define what a stack is
- Understand use cases for a stack
- Implement operations on a stack data structure
- Define what a queue is
- Understand use cases for a queue
- Implement operations on a queue data structure

### What is a stack?

- 한 마디로 하면 스택은 후입선출의 원칙(**LIFO**)을 따르는 데이터들의 집합
- A **LIFO** data structure!
  - The last element added to the stack will be the first element removed from the stack
- 반대로 큐는 선입선출의 원칙을 따른다.

### How is it used?

Think about a stack of **plates**, or a stack of **markers** or a stack of ...**anything**  
As you pile it up the last thing (or the topmostthing) is what gets removed first

### How we'll visualize a stack

```
A siries of nodes!

     last     size = 4     first
       ---------------------
      |                     |
<--- 10 <--- 2 <--- 22 <--- 7
```

### Where stacks are used

- Managing function invocations
- Undo / Redo (command + z / command + shift + z와 같은..)
- Routing (this history object) is treated like a stack!
- And much more!

### Linked Lists의 개념을 활용해서 스택 셋업하기

- Singly Linked Lists의 `push`와 `pop`을 사용하지 않는 이유?
  - Singly Linked Lists에서 `pop`은 상수값의 시간을 가지지 않는다.
  - 전체 리스트를 순회해서 테일노드의 앞 노드를 알아야 하므로 상수값을 가지지 않는다.
- 그냥 리스트에서 맨 뒤에 추가와 제거를 스택에서 맨 앞에서 추가와 제거를 하면 된다.

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }
}
```

### push/pop 메서드

**Add** and **remove** a value to the **top** of the stack!

#### Push Pseducode

- The function should accept a value
- Create a new node with that value
- If there are no nodes in the stack, set the first and last property to be the newly created node
- If there is at least one node, create a variable that stores the current first property on the stack
- Reset the first property ot be the newly created node
- Set the next property on the node to be the previously created variable
- Increment the size of the stack by 1

#### Pop Pseudocode

- If there are no nodes in the stack, return null
- Create a temporary variable to store the first property on the stack
- If there is only 1 node, set the first and last property to be null
- If there is more than one node, set the first property to be the next property on the current first

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }

  push(value) {
    const newNode = new Node(value);
    if (!this.first) {
      this.first = newNode;
      this.last = newNode;
    } else {
      const temp = this.first;
      this.first = newNode;
      this.first.next = temp;
    }
    return ++this.size;
  }

  pop() {
    if (!this.first) return null;

    const temp = this.first;
    // this.size === 1
    if (this.first === this.last) {
      this.last = null;
    }
    // 가장 처음 들어간 노드의 next는 항상 null이므로 if 문 밖으로 빼줘서 노드가 둘 이상인 경우와 같이 한 번에 처리
    this.first = this.first.next;
    this.size--;

    return temp.value;
  }
}
```

### Big O of Stacks

- Insertion - O(1)
- Removal - O(1)
- Searching - O(n)
- Access - O(n)

### What is a queue?

- A **FIFO** data structure!
  - First In First Out
- Queues are useful for processing tasks and are foundational for more complex data structures

### enqueue/dequeue 메서드

#### Enqueue Pseudocode

- This function accepts some value
- Create a new node using that value passed to the function
- If there are no nodes in the queue, set this node to be the first and last property of the queue
- Otherwise, set the next property on the current last to be that node, and then set the last property of the queue to be that node
- Increment the size of the queue by 1
- Return the size of the queue

#### Dequeue Pseudocode

- If there is no first property, just return null
- Store the first property in a variable
- see if the first is the same as the last (check if there is only 1 node). If so, set the first and last to be null
- If there is more than 1 node, set the first property to be the next property of first
- Decrement the size by 1
- Return the value of the node dequeued

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Queue {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }

  enqueue(value) {
    const newNode = new Node(value);
    if (!this.first) {
      this.first = newNode;
      this.last = newNode;
    } else {
      this.last.next = newNode;
      this.last = newNode;
    }

    return ++this.size;
  }

  dequeue() {
    if (!this.first) return null;

    const temp = this.first;
    if (this.first === this.last) {
      this.last = null;
    }
    this.first = this.first.next;
    this.size--;

    return temp.value;
  }
}
```

### Big O of Queues

- Insertion - O(1)
- Removal - O(1)
- Searching - O(n)
- Access - O(n)
- Insertion and Removal can be done in **O(1)**

## 20. 이진 검색 트리(Trees)

### Objectives

- Defined what a tree is
- Compare and contrast trees and lists
- Explain the differences between trees, binary trees, and binary search trees
- Implement operations on binary search trees

### What is a tree?

- A data structure that consists of nodes in a **parent / child** relationship
  - **Lists** - linear(선형 구조)
  - **Trees** - nonlinear(비선형 구조)
- Tree Terminology
  - **Root** - The top node in a tree
  - **Child** - A node directly connected to another node when moving away from the Root
  - **Parent** - The converse notion of a child
  - **Siblings** - A group of nodes with the same parent
  - **Leaf** - A node with no children
  - **Edge** - The connection between one node and another

### Where trees are used

- Lots of different applications!
  - HTML DOM
    - 개발자 도구에 document.body.children[0].children...으로 출력하면 부모-자식 관계로 이루어진 것 확인 가능
    - 여러 요소들이 있고, 한 요소 안에 자식에 해당하는 다른 요소가 중첩되어 있다.
  - Network Routing
  - Abstract Syntax Tree(프로그래밍 언어로 작성된 추상 구문 트리)
  - Artificial Intelligence(인공 지능)
  - Folders in Operating Systems
  - Computer File Systems

### Kind of Trees

- Trees - 자식이 몇 개든 상관없다.
- Binary Trees - 각 노드가 최대 두 개의 자식을 가져야 하는 특별한 조건이 있다.
- Binary Search Trees - 특별한 방식으로 데이터가 순서대로 정렬된 이진 트리의 종류 중 하나
  - Every parent node has at most **two** children
  - Every node to the left of a parent node is **always less** than the parent
  - Every node to the right of a parent node is **always greater** than the parent
    ```
             41
          /     \
        20       65
      /   \     /  \
    11    29   50   91
      \     \      /  \
       12    32   72   99
    ```

### The BinarySearchTree Class

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySerachTree {
  constructor() {
    this.root = null;
  }
}
```

### insert 메서드

#### Insert Pseudocode(Steps - Iteratively or Recursively)

- Create a new node
- Starting at the root
- Check if there is a root, if not - the root now becomes that new node!
  - If there is a root, check if the value of the new node is greater than or less than the value of the root
  - If it is greater, Check to see if there is a node to the right
    - If there is, move to that node and repeat these steps
    - If there is not, add that node as the right property
  - If is less, Check to see if there is a node to the left
    - If there is, move to that node and repeat these steps
    - If there is not, add that node as the left property

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  insert(value) {
    const newNode = new Node(value);
    if (!this.root) {
      this.root = newNode;
      return this;
    } else {
      let current = this.root; // root를 시작점으로 자식으로 내려가면서 현재 노드위치를 나타내는 변수
      while (true) {
        if (value === current.value) return undefined;
        if (value < current.value) {
          if (!current.left) {
            // 왼쪽 가지가 빈 경우
            current.left = newNode;
            return this;
          }
          // 왼쪽 가지에 노드가 있는 경우
          current = current.left;
        } else {
          if (!current.right) {
            current.right = newNode;
            return this;
          }
          current = current.right;
        }
      }
    }
  }
}
```

### find 메서드

#### Finding Pseudocode

- Starting at the root
  - Check if there is a root, if not - we're done searching!
  - If there is a root, check if the vaue of the new node is the value we are looking for. If we found it, we're done!
  - If not, check to see if the value is greater than or less than the value of the root
  - If it is greater, check to see if there is a node to the right
    - If there is, move to that node and repeat these steps
    - If there is not, we're done searching!
  - If it is less, check to see if there is a node to the left
    - If there is, move to that node and repeat these steps
    - If there is not, we're done searching!

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  find(value) {
    if (this.root === null) return false;
    let current = this.root;
    let found = false;
    while (current && !found) {
      if (value < current.value) {
        current = current.left;
      } else if (value > current.value) {
        current = current.right;
      } else {
        found = true;
      }
    }
    if (!found) return false;
    return current;
  }

  // true, false 값만 반환하는 메서드
  contains(value) {
    if (this.root === null) return false;
    let current = this.root;
    let found = false;
    while (current && !found) {
      if (value < current.value) {
        current = current.left;
      } else if (value > current.value) {
        current = current.right;
      } else {
        return true;
      }
    }
    return false;
  }
}
```

```js
// 내가 만들어본 find 메서드
find(value) {
    if (this.root === null) return false;

    let current = this.root;
    while (true) {
      if (value === current.value) return current;
      if (value < current.value) {
        if (!current.left) return false;
        current = current.left;
      } else {
        if (!current.right) return false;
        current = current.right;
      }
    }
  }
```

### Big O of Binary Search Trees

- Insertion - **O(log n)**
- Searching - **O(log n)**
- 이미 데이터를 insert할 때 O(log n)으로 위치를 찾아 정렬하기 때문에 search할 때도 O(log n) 시간 복잡도로 데이터를 찾을 수 있다.
- **But, NOT guaranteed!**
  - 이진 탐색 트리는 평균적인 경우와 최고의 경우에 트리가 가지는 시간 복잡도는 O(log n)이다.
  - 최악의 경우
    - 3 -> 17 -> 19 -> 32 -> 34 -> 63 -> 86 -> 91 -> ...로 리스트처럼 한쪽으로 가지가 치우진 경우
    - 그러면 완전히 한 쪽으로 쏠린 트리에 대해서는 O(n)의 값을 가지게 된다.

## 21. 트리 순회

### Two Ways of Traversing a Tree

- Breath-first Search(너비 우선 탐색)
- Depth-first Search(깊이 우선 탐색)
  - InOrder(중위 순회)
  - PreOrder(전위 순회)
  - PostOrder(후위 순회)

### Breath-first Search(너비 우선 탐색)

- Create a queue (this can be an array) and a variable to store the values of nodes visited
- Place the root node in the queue
- Loop as long as there is anything in the queue
  - Dequeue a node from the queue and push the value of the node into the variable that stores the nodes
  - If there is a left property on the node dequeued - add it to the queue
  - if there is a right property on the ndoe dequeued - add it to the queue
- Return the variable that stores the values

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  BFS() {
    let node = this.root; // 순회할 때마다 변경될 노드
    const data = []; // 맨 마지막에 출력할 배열 생성
    const queue = []; // 순회하면서 노드를 넣을 배열(queue) 생성
    queue.push(node);

    while (queue.length) {
      // 빈 배열인 경우 true 값 가지니 queue.length로 조건 설정
      node = queue.shift();
      data.push(node); // 아님 node.value 노상관!
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    return data;
  }
}
```

### Depth-first Search - PreOrder(깊이 우선 탐색 - 전위 순회)

- Create a variable to store the values of nodes visited
- Store the root of the BST in a variable called current
- Write a helper function which accepts a node
  - Push the value of the node to the variable that stores the values
  - If the node has a left property, call the helper function nwith the left property on the node
  - If the node has a right property, call the helper function with the right property on the node
- Invoke the helper function with the current variable

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  DFSPreOrder() {
    const data = [];
    let current = this.root;
    function traverse(node) {
      data.push(node);
      if (node.left) traverse(node.left);
      if (node.right) traverse(node.right);
    }
    traverse(current);

    return data;
  }
}
```

### Depth-first Search - PostOrder(깊이 우선 탐색 - 후위 순회)

- Create a variable to store the values of nodes visited
- Store the root of the BST in a variable called current
- Write a helper funtion which accepts a node
  - If the node has a left property, call the helper function with the left property on the node
  - If the node has a right property, call the helper function with the right property on the node
  - Push the value of the node to the variable that stores the values
- Invoke the helper function with the current variable

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  DFSPostOrder() {
    const data = [];

    function traverse(node) {
      if (node.left) traverse(node.left);
      if (node.right) traverse(node.right);
      data.push(data.value);
    }
    traverse(this.root);

    return data;
  }
}
```

### Depth-first Search - InOrder(깊이 우선 탐색 - 중위 순회)

- Create a variable to store the values of nodes visited
- Store the root of the BST in a variable called current
- Write a helper funtion which accepts a node
  - If the node has a left property, call the helper function with the left property on the node
  - Push the value of the node to the variable that stores the values
  - If the node has a right property, call the helper function with the right property on the node
- Invoke the helper function with the current variable

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  DFSInOrder() {
    const data = [];

    function traverse(node) {
      node.left && traverse(node.left); // if 문 다르게 표현
      data.push(node);
      node.right && traverse(node.right);
    }
    traverse(this.root);

    return data;
  }
}
```

### BFS? DFS? Which is better?

#### BFS

- 100 레벨 정도 깊이 내려가야 하는 경우나 트리가 리스트처럼 한 쪽으로 치우친 경우를 생각하면 BFS에서 큐에 엄청난게 많은 데이터가 저장되기 때문에 무리일 수 있다.

#### DFS

- InOrder - 트리에 있는 모든 노드들을 오름차순으로 구할 수 있다.
- PreOrder - 트리를 복사하거나 linear시켜 저장하는 경우(파일이나 DB에 저장하기 위해) 다시 연쇄 구조로 만들어 낼 때 도움이 된다.

### Recap

- Trees are non-linear data structures that contain a root and child nodes
- Binary Trees can have values of any type, but at most two children for each parent
- Binary Search Trees are a more specific version of binary trees where every node to the left of a parent is less than it's value and every node to the right is greater
- We can search through Trees using BSF and DFS

## 22. 이진 힙(Binary Heaps)

### Objectives

- Define what a binary heap is
- Compare and contrast min and max heaps
- Implement basic methods on heaps
- Understand where heaps are used in the real world and what other data structures can be constructed from heaps

### What is a binary

**Very** similar to a binary search tree, but with some different rules!  
In a **MaxBinaryHeap**, parent nodes are always larger than child nodes. In a **MinBinaryHeap**, parent nodes are always smaller than child nodes

- For any index of an array `n`...
  - The left child is stored at `2n + 1`
  - The right child is at `2n + 2`
  - 배열 안에 있는 모든 인덱스에 대해 그 왼쪽 자식은 `2n+1`에 저장되어 있고, 오른쪽 자식은 `2n+2`에 저장되어 있다.
- For any child node at index `n`...
  - Its parent is at index `(n-1)/2`
  - 인덱스 n에 자식이 있다면 1을 빼고 2로 나눈 다음에 내림하면 부모를 찾을 수 있다.

### What does it look like?

```
        41
     /      \
   39        33
  /  \      /
18    27   12
```

- 이진 탐색 트리와는 다르게 왼쪽과 오른쪽에는 순서가 존재하지 않는다!

### Max Binary Heap

- Each parent has at most two child nodes
- The value of each parent node is **always** greater than its child nodes
- In a max Binary Heap the parent is greater than the children, but there are no guarantees between sibling nodes
  - **No Implied Ordering Between Siblings**
- A binary heap is as compact as possible. All the children of each node are as full as they can be and left children are filled out first
  - 이진 트리 탐색에서는 끝없이 요소를 추가할 수 있지만, **이진 힙은 최적의 용량(가능한 적은 공간)을 가진다.**

### Why do we need to know this?

Binary Heaps are used to implement Priority Queues, which are **very** commonly used data structures  
They are also used quite a bit, with **graph traversal** algorithms

### Defining Heap class

```js
class MaxBinaryHeap {
  constructor() {
    this.values = [];
  }
}
```

- 다른 트리나 리스트처럼 노드 클래스 또는 prev/next 포인터, left/right 포인터가 필요없다!

### insert 메서드

#### Insert Pseudocode

- Push the value into the values property on the heap
- Bubble the value up to tis correct spot!
  - Create a variable called index which is the length of the values property-1
  - Create a variable called parentIndex which is the floor of (index-1)/2
  - Keep looping as long as the values element at the parentIndex is less than the values element at the child index
    - Swap the value of the values element at the parentIndex with the value of the element property at the child index
    - Set the index to ve the parentIndex, and start over!

```js
class MaxBinaryHeap {
  constructor() {
    this.values = [];
  }

  bubbleUp() {
    let idx = this.values.length - 1;
    let element = this.values[idx];
    while (idx > 0) {
      // undefined와 비교하는 것 방지
      let parentIdx = Math.floor((idx - 1) / 2);
      let parent = this.values[parentIdx];
      if (element <= parent) break;

      // Swap!
      this.values[parentIdx] = element;
      this.values[idx] = parent;
      idx = parentIdx;
    }
  }

  insert(element) {
    this.values.push(element);
    this.bubbleUp();
  }
}

let heap = new MaxBinaryHeap();
// ex) [41, 39, 33, 18, 27, 12]에 heap.insert(55) 실행
// 결과: [55, 39, 41, 18, 27, 12, 33]
```

### ExtractMax 메서드

- Remove the root
- Replace with the most recently added
- Adjust (sink down)
- `sink down`?
  - The procedure for deleting the root from the heap (effectively extracting the maximum element in a max-heap or the minimum element in a min-heap) and restoring the properties is called _down-heap_ (also know as bubble-down, percolate-down, sift-down, treckle down, heapify-down, cascade-down, and extract-min/max)

#### ExtractMax Pseudocode

- Swap the first value in the values property with the last one
- Pop from the vlaues property, so you can return the value at the end
- Have the new root "sink down" to the correct spot..
  - Your parent index starts at 0(the root)
  - Find the index of the left child: `2 * index + 1` (make sure its not out of bounds)
  - Find the index of the right child: `2 * index + 2` (make sure its not out of bounds)
  - If the left or right child is greater than the element...swap. If both left and right children are larget, swap with the largest child.
  - The child index you wapped to now becomes the new parent index.
  - Keep looping and wapping until neither child is larger than the element
  - Return the old root!

```js
class BinaryHeap {
  constructor() {
    this.values = [];
  }

  extractMax() {
    const max = this.values[0];
    const end = this.values.pop();
    if (this.values.length > 0) {
      // 하나 남으면 this.values[0] = end; 때문에 제거되지 않아 조건문 설정
      this.values[0] = end;
      this.sinkDown();
    }

    return max;
  }

  sinkDown() {
    let idx = 0;
    const length = this.values.length;
    const element = this.values[idx];

    while (true) {
      let leftChildIdx = 2 * idx + 1; // 왼쪽 자식 인덱스
      let rightChildIdx = 2 * idx + 2; // 오른쪽 자식 인덱스
      let leftChild, rightChild;
      let swap = null;

      if (leftChildIdx < length) {
        leftChild = this.values[leftChildIdx];
        if (leftChild > element) {
          // 부모보다 왼쪽 자식이 큰 경우
          swap = leftChildIdx;
        }
      }

      if (rightChildIdx < length) {
        rightChild = this.values[rightChildIdx];
        //부모가 왼쪽 자식보다는 크지만 오른쪽 자식보다는 작은 경우, 부모보다 자식들이 크지만 오른쪽 자식이 더 큰 경우
        if (
          (swap === null && rightChild > element) ||
          (swap !== null && rightChild > leftChild)
        ) {
          swap = rightChildIdx;
        }
      }

      // 자리바꾸기를 하지 않는 경우 the most recently added element가 제대로 위치했기 때문에 루프 종료!
      if (swap === null) break;

      // Swap!
      this.values[idx] = this.values[swap];
      this.values[swap] = element;
      idx = swap;
    }
  }
}
```

### What is a Priority Queue(우선 순위 큐)

A data structure where each element has a priority.  
Elements with higer priorities are served before elements with lower priorities.

### Priority Queue

- Write a Min Binary Heap - lower number means higher priority
  - 1에 가까울 수록 우선순위가 높게 설정할 것이므로 최대 이진 힙이 아닌 최소 이진 힙 사용!
- Each Node has a val and a priority. Use the priority to build the heap
  - Value doesn't matter. Heap is constructed **using Priority**!
- `Enqueue` method accepts a value and priority, makes a new node, and puts it in the right spot based off of its priority.
- `Dequeue` method removes root element, returns it, and rearranges heap using priority.

### PriorityQueue Class

```js
class Node {
  constructor(value, priority) {
    this.value = value;
    this.priority = priority;
  }
}

class PriorityQueue {
  constructor() {
    this.values = [];
  }

  enqueue(value, priority) {
    const newNode = new Node(value, priority);
    this.values.push(newNode);
    this.bubbleUp();
  }

  bubbleUp() {
    let idx = this.values.length - 1;
    const element = this.values[idx];
    while (idx > 0) {
      let parentIdx = Math.floor((idx - 1) / 2);
      let parent = this.values[parentIdx];
      if (element.priority >= parent.priority) break;
      this.values[parentIdx] = element;
      this.values[idx] = parent;
      idx = parentIdx;
    }
  }

  dequeue() {
    const min = this.values[0];
    const end = this.values.pop();
    if (this.values.length > 0) {
      this.values[0] = end;
      this.sinkDown();
    }

    return min;
  }

  sinkDown() {
    let idx = 0;
    const length = this.values.length;
    const element = this.values[0];
    while (true) {
      let leftChildIdx = 2 * idx + 1;
      let rightChildIdx = 2 * idx + 2;
      let leftChild, rightChild;
      let swap = null;

      if (leftChildIdx < length) {
        leftChild = this.values[leftChildIdx];
        if (leftChild.priority < element.priority) {
          swap = leftChildIdx;
        }
      }

      if (rightChildIdx < length) {
        rightChild = this.values[rightChildIdx];
        if (
          (swap === null && rightChild.priority < element.priority) ||
          (swap !== null && rightChild.priority < leftChild.priority)
        ) {
          swap = rightChildIdx;
        }
      }

      if (swap === null) break;

      this.values[idx] = this.values[swap];
      this.values[swap] = element;
      idx = swap;
    }
  }
}

const ER = new PriorityQueue();
ER.enqueue("common cold", 5);
ER.enqueue("gunshot wound", 1);
ER.enqueue("hight fever", 4);
ER.enqueue("broken arm", 2);
ER.enqueue("glass in foot", 3);
```

### Big O of Binary Heap

- 이진 힙은 최대 힙이든 최소 힙이든 삽입과 삭제에 있어서 아주 성능이 좋다!
  - insertion - **O(log n)**
  - Removal - **O(log n)**
  - Search - **O(n)**

#### Why log(n)?

- 삽입할 때 16개 요소나 노드가 있으면 최대 4번의 비교로 새로 들어온 요소나 노드를 위치시킬 수 있기 때문이다!
  - 깊이는 4레벨까지 있고, 루트까지 비교하는데 최대 4번!

#### What about worst case?

- Binary Heap은 Binary Search Tree와 달리 왼쪽부터 채워지기 때문에 최악의 경우도 **O(log n)**이다!
  - 이진 힙은 따라서 탐색을 위한 것이 아니다.

### Recap

- Binary Heaps are very useful data structure for sotring, and implementing other data structures like priority queues
- Binary Heaps are either MaxBinaryHeaps or MinBinaryHeaps with parents either being smaller or larget than their children
- With just a little bit of math, we can represent heaps using arrays!
  - 약간의 수학 공식을 사용하면 배열을 가지고 힙을 쉽게 표현할 수 있다.

## 23. 해시 테이블(Hash Tables)

### Objectives

- Explain what a hash table is
- Define what a hashing algorithm
- Discuss what makes a good hasing algorithm
- Understand how collisions occur in a hash table
- Handle collisions using separate chaining or linear probing

### What is a hash table?

Hash tables are used to sotre _key-value_ pairs.  
They are like arrays, but the keys are not ordered.  
Unlike arrays, hash tables are _fast_ for all of the following operations: finding values, adding new values, and removing values!

### Why should I care?

Nearly every programming language has some sort of hash table data structure  
Because of their speed, hash tables are very commonly used!

#### Hash tables in the wild

- `Python` has **Dictionaries**
- `JS` has **Objects** and **Maps**
  - **Objects** have some restrictions, but are basically hash tables
- `Java`, `Go`, & `Scala` have **Maps**
- `Ruby` has... **Hashes**


