# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [19. 스택(Stack)과 큐(Queues)](#19-스택stack과-큐queues)
  - [What is a stack?](#what-is-a-stack)
  - [How is it used?](#how-is-it-used)
  - [How we'll visualize a stack](#how-well-visualize-a-stack)
  - [Where stacks are used](#where-stacks-are-used)
  - [Linked Lists의 개념을 활용해서 스택 셋업하기](#linked-lists의-개념을-활용해서-스택-셋업하기)
  - [push/pop 메서드](#pushpop-메서드)
  - [Big O of Stacks](#big-o-of-stacks)
  - [What is a queue?](#what-is-a-queue)
  - [enqueue/dequeue 메서드](#enqueuedequeue-메서드)
  - [Big O of Queues](#big-o-of-queues)
- [20. 이진 검색 트리(Trees)](#20-이진-검색-트리trees)
  - [What is a tree?](#what-is-a-tree)
  - [Where trees are used](#where-trees-are-used)
  - [Kind of Trees](#kind-of-trees)
  - [The Binary Search Trees](#the-binarysearchtree-class)
  - [insert 메서드](#insert-메서드)
  - [find 메서드](#find-메서드)
  - [Big O of Binary Search Trees](#big-o-of-binary-search-trees)
- [21. 트리 순회](#21-트리-순회)
  - [Two Ways of Traversing a Tree](#two-ways-of-traversing-a-tree)
  - [Breath-first Search(너비 우선 탐색)](#breath-first-search너비-우선-탐색)
  - [Depth-first Search - PreOrder(깊이 우선 탐색 - 전위 순회)](#depth-first-search---preorder깊이-우선-탐색---전위-순회)
  - [Depth-first Search - PostOrder(깊이 우선 탐색 - 후위 순회)](#depth-first-search---postorder깊이-우선-탐색---후위-순회)
  - [Depth-first Search - InOrder(깊이 우선 탐색 - 중위 순회)](#depth-first-search---inorder깊이-우선-탐색---중위-순회)
  - [BFS? DFS? Which is better?](#bfs-dfs-which-is-better)
- [22. 이진 힙(Binary Heaps)](#22-이진-힙binary-heaps)
  - [What is a binary](#what-is-a-binary)
  - [What does it look like?](#what-does-it-look-like)
  - [Max Binary Heap](#max-binary-heap)
  - [Why do we need to know this?](#why-do-we-need-to-know-this)
  - [Defining Heap class](#defining-heap-class)
  - [insert 메서드](#insert-eba994ec849ceb939c-1)
  - [ExtractMax 메서드](#extractmax-메서드)
  - [What is a Priority Queue(우선 순위 큐)](#what-is-a-priority-queue우선-순위-큐)
  - [Priority Queue](#priority-queue)
  - [PriorityQueue Class](#priorityqueue-class)
  - [Big O of Binary Heap](#big-o-of-binary-heap)
  - [Recap](#recap-1)
- [23. 해시 테이블(Hash Tables)](#23-해시-테이블hash-tables)
  - [What is a hash table?](#what-is-a-hash-table)
  - [Why should I care?](#why-should-i-care)
  - [The Hash](#the-hash)
  - [What makes a good hash?](#what-makes-a-good-hash)
  - [A HashTable Class](#a-hashtable-class)
  - [set/get메서드, keys/valuse 메서드](#setget-메서드-keysvalues-메서드)
- [24. 그래프(Graphs)](#24-그래프graphs)

## 19. 스택(Stack)과 큐(Queues)

### Objectives

- Define what a stack is
- Understand use cases for a stack
- Implement operations on a stack data structure
- Define what a queue is
- Understand use cases for a queue
- Implement operations on a queue data structure

### What is a stack?

- 한 마디로 하면 스택은 후입선출의 원칙(**LIFO**)을 따르는 데이터들의 집합
- A **LIFO** data structure!
  - The last element added to the stack will be the first element removed from the stack
- 반대로 큐는 선입선출의 원칙을 따른다.

### How is it used?

Think about a stack of **plates**, or a stack of **markers** or a stack of ...**anything**  
As you pile it up the last thing (or the topmostthing) is what gets removed first

### How we'll visualize a stack

```
A siries of nodes!

     last     size = 4     first
       ---------------------
      |                     |
<--- 10 <--- 2 <--- 22 <--- 7
```

### Where stacks are used

- Managing function invocations
- Undo / Redo (command + z / command + shift + z와 같은..)
- Routing (this history object) is treated like a stack!
- And much more!

### Linked Lists의 개념을 활용해서 스택 셋업하기

- Singly Linked Lists의 `push`와 `pop`을 사용하지 않는 이유?
  - Singly Linked Lists에서 `pop`은 상수값의 시간을 가지지 않는다.
  - 전체 리스트를 순회해서 테일노드의 앞 노드를 알아야 하므로 상수값을 가지지 않는다.
- 그냥 리스트에서 맨 뒤에 추가와 제거를 스택에서 맨 앞에서 추가와 제거를 하면 된다.

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }
}
```

### push/pop 메서드

**Add** and **remove** a value to the **top** of the stack!

#### Push Pseducode

- The function should accept a value
- Create a new node with that value
- If there are no nodes in the stack, set the first and last property to be the newly created node
- If there is at least one node, create a variable that stores the current first property on the stack
- Reset the first property ot be the newly created node
- Set the next property on the node to be the previously created variable
- Increment the size of the stack by 1

#### Pop Pseudocode

- If there are no nodes in the stack, return null
- Create a temporary variable to store the first property on the stack
- If there is only 1 node, set the first and last property to be null
- If there is more than one node, set the first property to be the next property on the current first

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }

  push(value) {
    const newNode = new Node(value);
    if (!this.first) {
      this.first = newNode;
      this.last = newNode;
    } else {
      const temp = this.first;
      this.first = newNode;
      this.first.next = temp;
    }
    return ++this.size;
  }

  pop() {
    if (!this.first) return null;

    const temp = this.first;
    // this.size === 1
    if (this.first === this.last) {
      this.last = null;
    }
    // 가장 처음 들어간 노드의 next는 항상 null이므로 if 문 밖으로 빼줘서 노드가 둘 이상인 경우와 같이 한 번에 처리
    this.first = this.first.next;
    this.size--;

    return temp.value;
  }
}
```

### Big O of Stacks

- Insertion - O(1)
- Removal - O(1)
- Searching - O(n)
- Access - O(n)

### What is a queue?

- A **FIFO** data structure!
  - First In First Out
- Queues are useful for processing tasks and are foundational for more complex data structures

### enqueue/dequeue 메서드

#### Enqueue Pseudocode

- This function accepts some value
- Create a new node using that value passed to the function
- If there are no nodes in the queue, set this node to be the first and last property of the queue
- Otherwise, set the next property on the current last to be that node, and then set the last property of the queue to be that node
- Increment the size of the queue by 1
- Return the size of the queue

#### Dequeue Pseudocode

- If there is no first property, just return null
- Store the first property in a variable
- see if the first is the same as the last (check if there is only 1 node). If so, set the first and last to be null
- If there is more than 1 node, set the first property to be the next property of first
- Decrement the size by 1
- Return the value of the node dequeued

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Queue {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }

  enqueue(value) {
    const newNode = new Node(value);
    if (!this.first) {
      this.first = newNode;
      this.last = newNode;
    } else {
      this.last.next = newNode;
      this.last = newNode;
    }

    return ++this.size;
  }

  dequeue() {
    if (!this.first) return null;

    const temp = this.first;
    if (this.first === this.last) {
      this.last = null;
    }
    this.first = this.first.next;
    this.size--;

    return temp.value;
  }
}
```

### Big O of Queues

- Insertion - O(1)
- Removal - O(1)
- Searching - O(n)
- Access - O(n)
- Insertion and Removal can be done in **O(1)**

## 20. 이진 검색 트리(Trees)

### Objectives

- Defined what a tree is
- Compare and contrast trees and lists
- Explain the differences between trees, binary trees, and binary search trees
- Implement operations on binary search trees

### What is a tree?

- A data structure that consists of nodes in a **parent / child** relationship
  - **Lists** - linear(선형 구조)
  - **Trees** - nonlinear(비선형 구조)
- Tree Terminology
  - **Root** - The top node in a tree
  - **Child** - A node directly connected to another node when moving away from the Root
  - **Parent** - The converse notion of a child
  - **Siblings** - A group of nodes with the same parent
  - **Leaf** - A node with no children
  - **Edge** - The connection between one node and another

### Where trees are used

- Lots of different applications!
  - HTML DOM
    - 개발자 도구에 document.body.children[0].children...으로 출력하면 부모-자식 관계로 이루어진 것 확인 가능
    - 여러 요소들이 있고, 한 요소 안에 자식에 해당하는 다른 요소가 중첩되어 있다.
  - Network Routing
  - Abstract Syntax Tree(프로그래밍 언어로 작성된 추상 구문 트리)
  - Artificial Intelligence(인공 지능)
  - Folders in Operating Systems
  - Computer File Systems

### Kind of Trees

- Trees - 자식이 몇 개든 상관없다.
- Binary Trees - 각 노드가 최대 두 개의 자식을 가져야 하는 특별한 조건이 있다.
- Binary Search Trees - 특별한 방식으로 데이터가 순서대로 정렬된 이진 트리의 종류 중 하나
  - Every parent node has at most **two** children
  - Every node to the left of a parent node is **always less** than the parent
  - Every node to the right of a parent node is **always greater** than the parent
    ```
             41
          /     \
        20       65
      /   \     /  \
    11    29   50   91
      \     \      /  \
       12    32   72   99
    ```

### The BinarySearchTree Class

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySerachTree {
  constructor() {
    this.root = null;
  }
}
```

### insert 메서드

#### Insert Pseudocode(Steps - Iteratively or Recursively)

- Create a new node
- Starting at the root
- Check if there is a root, if not - the root now becomes that new node!
  - If there is a root, check if the value of the new node is greater than or less than the value of the root
  - If it is greater, Check to see if there is a node to the right
    - If there is, move to that node and repeat these steps
    - If there is not, add that node as the right property
  - If is less, Check to see if there is a node to the left
    - If there is, move to that node and repeat these steps
    - If there is not, add that node as the left property

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  insert(value) {
    const newNode = new Node(value);
    if (!this.root) {
      this.root = newNode;
      return this;
    } else {
      let current = this.root; // root를 시작점으로 자식으로 내려가면서 현재 노드위치를 나타내는 변수
      while (true) {
        if (value === current.value) return undefined;
        if (value < current.value) {
          if (!current.left) {
            // 왼쪽 가지가 빈 경우
            current.left = newNode;
            return this;
          }
          // 왼쪽 가지에 노드가 있는 경우
          current = current.left;
        } else {
          if (!current.right) {
            current.right = newNode;
            return this;
          }
          current = current.right;
        }
      }
    }
  }
}
```

### find 메서드

#### Finding Pseudocode

- Starting at the root
  - Check if there is a root, if not - we're done searching!
  - If there is a root, check if the vaue of the new node is the value we are looking for. If we found it, we're done!
  - If not, check to see if the value is greater than or less than the value of the root
  - If it is greater, check to see if there is a node to the right
    - If there is, move to that node and repeat these steps
    - If there is not, we're done searching!
  - If it is less, check to see if there is a node to the left
    - If there is, move to that node and repeat these steps
    - If there is not, we're done searching!

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  find(value) {
    if (this.root === null) return false;
    let current = this.root;
    let found = false;
    while (current && !found) {
      if (value < current.value) {
        current = current.left;
      } else if (value > current.value) {
        current = current.right;
      } else {
        found = true;
      }
    }
    if (!found) return false;
    return current;
  }

  // true, false 값만 반환하는 메서드
  contains(value) {
    if (this.root === null) return false;
    let current = this.root;
    let found = false;
    while (current && !found) {
      if (value < current.value) {
        current = current.left;
      } else if (value > current.value) {
        current = current.right;
      } else {
        return true;
      }
    }
    return false;
  }
}
```

```js
// 내가 만들어본 find 메서드
find(value) {
    if (this.root === null) return false;

    let current = this.root;
    while (true) {
      if (value === current.value) return current;
      if (value < current.value) {
        if (!current.left) return false;
        current = current.left;
      } else {
        if (!current.right) return false;
        current = current.right;
      }
    }
  }
```

### Big O of Binary Search Trees

- Insertion - **O(log n)**
- Searching - **O(log n)**
- 이미 데이터를 insert할 때 O(log n)으로 위치를 찾아 정렬하기 때문에 search할 때도 O(log n) 시간 복잡도로 데이터를 찾을 수 있다.
- **But, NOT guaranteed!**
  - 이진 탐색 트리는 평균적인 경우와 최고의 경우에 트리가 가지는 시간 복잡도는 O(log n)이다.
  - 최악의 경우
    - 3 -> 17 -> 19 -> 32 -> 34 -> 63 -> 86 -> 91 -> ...로 리스트처럼 한쪽으로 가지가 치우진 경우
    - 그러면 완전히 한 쪽으로 쏠린 트리에 대해서는 O(n)의 값을 가지게 된다.

## 21. 트리 순회

### Two Ways of Traversing a Tree

- Breath-first Search(너비 우선 탐색)
- Depth-first Search(깊이 우선 탐색)
  - InOrder(중위 순회)
  - PreOrder(전위 순회)
  - PostOrder(후위 순회)

### Breath-first Search(너비 우선 탐색)

- Create a queue (this can be an array) and a variable to store the values of nodes visited
- Place the root node in the queue
- Loop as long as there is anything in the queue
  - Dequeue a node from the queue and push the value of the node into the variable that stores the nodes
  - If there is a left property on the node dequeued - add it to the queue
  - if there is a right property on the ndoe dequeued - add it to the queue
- Return the variable that stores the values

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  BFS() {
    let node = this.root; // 순회할 때마다 변경될 노드
    const data = []; // 맨 마지막에 출력할 배열 생성
    const queue = []; // 순회하면서 노드를 넣을 배열(queue) 생성
    queue.push(node);

    while (queue.length) {
      // 빈 배열인 경우 true 값 가지니 queue.length로 조건 설정
      node = queue.shift();
      data.push(node); // 아님 node.value 노상관!
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    return data;
  }
}
```

### Depth-first Search - PreOrder(깊이 우선 탐색 - 전위 순회)

- Create a variable to store the values of nodes visited
- Store the root of the BST in a variable called current
- Write a helper function which accepts a node
  - Push the value of the node to the variable that stores the values
  - If the node has a left property, call the helper function nwith the left property on the node
  - If the node has a right property, call the helper function with the right property on the node
- Invoke the helper function with the current variable

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  DFSPreOrder() {
    const data = [];
    let current = this.root;
    function traverse(node) {
      data.push(node);
      if (node.left) traverse(node.left);
      if (node.right) traverse(node.right);
    }
    traverse(current);

    return data;
  }
}
```

### Depth-first Search - PostOrder(깊이 우선 탐색 - 후위 순회)

- Create a variable to store the values of nodes visited
- Store the root of the BST in a variable called current
- Write a helper funtion which accepts a node
  - If the node has a left property, call the helper function with the left property on the node
  - If the node has a right property, call the helper function with the right property on the node
  - Push the value of the node to the variable that stores the values
- Invoke the helper function with the current variable

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  DFSPostOrder() {
    const data = [];

    function traverse(node) {
      if (node.left) traverse(node.left);
      if (node.right) traverse(node.right);
      data.push(data.value);
    }
    traverse(this.root);

    return data;
  }
}
```

### Depth-first Search - InOrder(깊이 우선 탐색 - 중위 순회)

- Create a variable to store the values of nodes visited
- Store the root of the BST in a variable called current
- Write a helper funtion which accepts a node
  - If the node has a left property, call the helper function with the left property on the node
  - Push the value of the node to the variable that stores the values
  - If the node has a right property, call the helper function with the right property on the node
- Invoke the helper function with the current variable

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  DFSInOrder() {
    const data = [];

    function traverse(node) {
      node.left && traverse(node.left); // if 문 다르게 표현
      data.push(node);
      node.right && traverse(node.right);
    }
    traverse(this.root);

    return data;
  }
}
```

### BFS? DFS? Which is better?

#### BFS

- 100 레벨 정도 깊이 내려가야 하는 경우나 트리가 리스트처럼 한 쪽으로 치우친 경우를 생각하면 BFS에서 큐에 엄청난게 많은 데이터가 저장되기 때문에 무리일 수 있다.

#### DFS

- InOrder - 트리에 있는 모든 노드들을 오름차순으로 구할 수 있다.
- PreOrder - 트리를 복사하거나 linear시켜 저장하는 경우(파일이나 DB에 저장하기 위해) 다시 연쇄 구조로 만들어 낼 때 도움이 된다.

### Recap

- Trees are non-linear data structures that contain a root and child nodes
- Binary Trees can have values of any type, but at most two children for each parent
- Binary Search Trees are a more specific version of binary trees where every node to the left of a parent is less than it's value and every node to the right is greater
- We can search through Trees using BSF and DFS

## 22. 이진 힙(Binary Heaps)

### Objectives

- Define what a binary heap is
- Compare and contrast min and max heaps
- Implement basic methods on heaps
- Understand where heaps are used in the real world and what other data structures can be constructed from heaps

### What is a binary

**Very** similar to a binary search tree, but with some different rules!  
In a **MaxBinaryHeap**, parent nodes are always larger than child nodes. In a **MinBinaryHeap**, parent nodes are always smaller than child nodes

- For any index of an array `n`...
  - The left child is stored at `2n + 1`
  - The right child is at `2n + 2`
  - 배열 안에 있는 모든 인덱스에 대해 그 왼쪽 자식은 `2n+1`에 저장되어 있고, 오른쪽 자식은 `2n+2`에 저장되어 있다.
- For any child node at index `n`...
  - Its parent is at index `(n-1)/2`
  - 인덱스 n에 자식이 있다면 1을 빼고 2로 나눈 다음에 내림하면 부모를 찾을 수 있다.

### What does it look like?

```
        41
     /      \
   39        33
  /  \      /
18    27   12
```

- 이진 탐색 트리와는 다르게 왼쪽과 오른쪽에는 순서가 존재하지 않는다!

### Max Binary Heap

- Each parent has at most two child nodes
- The value of each parent node is **always** greater than its child nodes
- In a max Binary Heap the parent is greater than the children, but there are no guarantees between sibling nodes
  - **No Implied Ordering Between Siblings**
- A binary heap is as compact as possible. All the children of each node are as full as they can be and left children are filled out first
  - 이진 트리 탐색에서는 끝없이 요소를 추가할 수 있지만, **이진 힙은 최적의 용량(가능한 적은 공간)을 가진다.**

### Why do we need to know this?

Binary Heaps are used to implement Priority Queues, which are **very** commonly used data structures  
They are also used quite a bit, with **graph traversal** algorithms

### Defining Heap class

```js
class MaxBinaryHeap {
  constructor() {
    this.values = [];
  }
}
```

- 다른 트리나 리스트처럼 노드 클래스 또는 prev/next 포인터, left/right 포인터가 필요없다!

### insert 메서드

#### Insert Pseudocode

- Push the value into the values property on the heap
- Bubble the value up to tis correct spot!
  - Create a variable called index which is the length of the values property-1
  - Create a variable called parentIndex which is the floor of (index-1)/2
  - Keep looping as long as the values element at the parentIndex is less than the values element at the child index
    - Swap the value of the values element at the parentIndex with the value of the element property at the child index
    - Set the index to ve the parentIndex, and start over!

```js
class MaxBinaryHeap {
  constructor() {
    this.values = [];
  }

  bubbleUp() {
    let idx = this.values.length - 1;
    let element = this.values[idx];
    while (idx > 0) {
      // undefined와 비교하는 것 방지
      let parentIdx = Math.floor((idx - 1) / 2);
      let parent = this.values[parentIdx];
      if (element <= parent) break;

      // Swap!
      this.values[parentIdx] = element;
      this.values[idx] = parent;
      idx = parentIdx;
    }
  }

  insert(element) {
    this.values.push(element);
    this.bubbleUp();
  }
}

let heap = new MaxBinaryHeap();
// ex) [41, 39, 33, 18, 27, 12]에 heap.insert(55) 실행
// 결과: [55, 39, 41, 18, 27, 12, 33]
```

### ExtractMax 메서드

- Remove the root
- Replace with the most recently added
- Adjust (sink down)
- `sink down`?
  - The procedure for deleting the root from the heap (effectively extracting the maximum element in a max-heap or the minimum element in a min-heap) and restoring the properties is called _down-heap_ (also know as bubble-down, percolate-down, sift-down, treckle down, heapify-down, cascade-down, and extract-min/max)

#### ExtractMax Pseudocode

- Swap the first value in the values property with the last one
- Pop from the vlaues property, so you can return the value at the end
- Have the new root "sink down" to the correct spot..
  - Your parent index starts at 0(the root)
  - Find the index of the left child: `2 * index + 1` (make sure its not out of bounds)
  - Find the index of the right child: `2 * index + 2` (make sure its not out of bounds)
  - If the left or right child is greater than the element...swap. If both left and right children are larget, swap with the largest child.
  - The child index you wapped to now becomes the new parent index.
  - Keep looping and wapping until neither child is larger than the element
  - Return the old root!

```js
class BinaryHeap {
  constructor() {
    this.values = [];
  }

  extractMax() {
    const max = this.values[0];
    const end = this.values.pop();
    if (this.values.length > 0) {
      // 하나 남으면 this.values[0] = end; 때문에 제거되지 않아 조건문 설정
      this.values[0] = end;
      this.sinkDown();
    }

    return max;
  }

  sinkDown() {
    let idx = 0;
    const length = this.values.length;
    const element = this.values[idx];

    while (true) {
      let leftChildIdx = 2 * idx + 1; // 왼쪽 자식 인덱스
      let rightChildIdx = 2 * idx + 2; // 오른쪽 자식 인덱스
      let leftChild, rightChild;
      let swap = null;

      if (leftChildIdx < length) {
        leftChild = this.values[leftChildIdx];
        if (leftChild > element) {
          // 부모보다 왼쪽 자식이 큰 경우
          swap = leftChildIdx;
        }
      }

      if (rightChildIdx < length) {
        rightChild = this.values[rightChildIdx];
        //부모가 왼쪽 자식보다는 크지만 오른쪽 자식보다는 작은 경우, 부모보다 자식들이 크지만 오른쪽 자식이 더 큰 경우
        if (
          (swap === null && rightChild > element) ||
          (swap !== null && rightChild > leftChild)
        ) {
          swap = rightChildIdx;
        }
      }

      // 자리바꾸기를 하지 않는 경우 the most recently added element가 제대로 위치했기 때문에 루프 종료!
      if (swap === null) break;

      // Swap!
      this.values[idx] = this.values[swap];
      this.values[swap] = element;
      idx = swap;
    }
  }
}
```

### What is a Priority Queue(우선 순위 큐)

A data structure where each element has a priority.  
Elements with higer priorities are served before elements with lower priorities.

### Priority Queue

- Write a Min Binary Heap - lower number means higher priority
  - 1에 가까울 수록 우선순위가 높게 설정할 것이므로 최대 이진 힙이 아닌 최소 이진 힙 사용!
- Each Node has a val and a priority. Use the priority to build the heap
  - Value doesn't matter. Heap is constructed **using Priority**!
- `Enqueue` method accepts a value and priority, makes a new node, and puts it in the right spot based off of its priority.
- `Dequeue` method removes root element, returns it, and rearranges heap using priority.

### PriorityQueue Class

```js
class Node {
  constructor(value, priority) {
    this.value = value;
    this.priority = priority;
  }
}

class PriorityQueue {
  constructor() {
    this.values = [];
  }

  enqueue(value, priority) {
    const newNode = new Node(value, priority);
    this.values.push(newNode);
    this.bubbleUp();
  }

  bubbleUp() {
    let idx = this.values.length - 1;
    const element = this.values[idx];
    while (idx > 0) {
      let parentIdx = Math.floor((idx - 1) / 2);
      let parent = this.values[parentIdx];
      if (element.priority >= parent.priority) break;
      this.values[parentIdx] = element;
      this.values[idx] = parent;
      idx = parentIdx;
    }
  }

  dequeue() {
    const min = this.values[0];
    const end = this.values.pop();
    if (this.values.length > 0) {
      this.values[0] = end;
      this.sinkDown();
    }

    return min;
  }

  sinkDown() {
    let idx = 0;
    const length = this.values.length;
    const element = this.values[0];
    while (true) {
      let leftChildIdx = 2 * idx + 1;
      let rightChildIdx = 2 * idx + 2;
      let leftChild, rightChild;
      let swap = null;

      if (leftChildIdx < length) {
        leftChild = this.values[leftChildIdx];
        if (leftChild.priority < element.priority) {
          swap = leftChildIdx;
        }
      }

      if (rightChildIdx < length) {
        rightChild = this.values[rightChildIdx];
        if (
          (swap === null && rightChild.priority < element.priority) ||
          (swap !== null && rightChild.priority < leftChild.priority)
        ) {
          swap = rightChildIdx;
        }
      }

      if (swap === null) break;

      this.values[idx] = this.values[swap];
      this.values[swap] = element;
      idx = swap;
    }
  }
}

const ER = new PriorityQueue();
ER.enqueue("common cold", 5);
ER.enqueue("gunshot wound", 1);
ER.enqueue("hight fever", 4);
ER.enqueue("broken arm", 2);
ER.enqueue("glass in foot", 3);
```

### Big O of Binary Heap

- 이진 힙은 최대 힙이든 최소 힙이든 삽입과 삭제에 있어서 아주 성능이 좋다!
  - insertion - **O(log n)**
  - Removal - **O(log n)**
  - Search - **O(n)**

#### Why log(n)?

- 삽입할 때 16개 요소나 노드가 있으면 최대 4번의 비교로 새로 들어온 요소나 노드를 위치시킬 수 있기 때문이다!
  - 깊이는 4레벨까지 있고, 루트까지 비교하는데 최대 4번!

#### What about worst case?

- Binary Heap은 Binary Search Tree와 달리 왼쪽부터 채워지기 때문에 최악의 경우도 **O(log n)**이다!
  - 이진 힙은 따라서 탐색을 위한 것이 아니다.

### Recap

- Binary Heaps are very useful data structure for sotring, and implementing other data structures like priority queues
- Binary Heaps are either MaxBinaryHeaps or MinBinaryHeaps with parents either being smaller or larget than their children
- With just a little bit of math, we can represent heaps using arrays!
  - 약간의 수학 공식을 사용하면 배열을 가지고 힙을 쉽게 표현할 수 있다.

## 23. 해시 테이블(Hash Tables)

### Objectives

- Explain what a hash table is
- Define what a hashing algorithm
- Discuss what makes a good hasing algorithm
- Understand how collisions occur in a hash table
- Handle collisions using separate chaining or linear probing

### What is a hash table?

Hash tables are used to sotre _key-value_ pairs.  
They are like arrays, but the keys are not ordered.  
Unlike arrays, hash tables are _fast_ for all of the following operations: finding values, adding new values, and removing values!

### Why should I care?

Nearly every programming language has some sort of hash table data structure  
Because of their speed, hash tables are very commonly used!

#### Hash tables in the wild

- `Python` has **Dictionaries**
- `JS` has **Objects** and **Maps**
  - **Objects** have some restrictions, but are basically hash tables
- `Java`, `Go`, & `Scala` have **Maps**
- `Ruby` has... **Hashes**

### The Hash

- To implement a hash table, we'll be using an array.
- In order to look up values by key, we need a way to **convert keys into valid array indices**.
  - String을 가지고 숫자로 바꿔서 배열에 저장을 할 방법이 필요하다.
- A function that performs this task is called a `hash function`.

### What makes a good hash?

- Fast (i.e. constant time)
- Doesn't cluster outputs at specific indices, but distributes unifomly
  - 기본적으로 일관된 방식으로 분배를 해서 다른 것들과 겹치지 않게 해야 한다.
  - 모든 요소가 같은 자리에 저장돼야 한다.
- Deterministic (same input yields same output)
  - 좋은 해시 함수는 결정론적이다.
  - 특정 입력값을 입력할 때마다 같은 출력값이 나와야 한다.
  - 같은 출력값을 받게 되는 것이 이미 결정되어 있어야 한다는 것!

#### Non-Example

```js
// Fast에 어긋남 -> '상수값의 시간을 가지는 것이 필요하므로' 여러 번 반복되는 루프가 있어서는 안된다.
function slowHash(key) {
  for (let i = 0; i < 10000; i++) {
    console.log("everyday i'm hashing");
  }
  return key[0].charCodeAt(0);
}

// Uniformly Distributes Values에 어긋남
function sameHashedValue(key) {
  return 0;
}

// Deterministic에 어긋남
function randomHash(key) {
  return Math.floor(Math.random() * 1000);
}
```

#### Simple Hash Example

```js
// a hash function that works on string only
function hash(key, arrayLen) {
  let total = 0;
  for (let char of key) {
    // map "a" to 1, "b" to 2, "c" to 3, etc.
    let value = char.charCodeAt(0) - 96;
    total = (total + value) % arrayLen;
  }

  return total;
}
```

- Problems with the current hash
  - Only hashes strings
  - Not constant time - linear in key length
  - Could be a little more random

#### 해시 함수 성능 향상시키기

```js
function hash (key, arrayLen) {
  let total = 0;
  let WEIRD_PRIME = 31; // 입력한 데이터가 같은 그릇에 들어가지 않도록 충돌을 방지하기 위해 소수를 사용한다.
  for (let i = 0; i < Math.min(key, length, 100); i++) {
    let char = key[i];
    let value = char.charCodeAt(0) - 96;
    total = (total * WEIRD_PRIME + value) $ arrayLen;
  }

  return total;
}
```

#### Prime numbers?

The prime number in the hash is helpful in spreading out the keys more unifromly.  
It's also helpful if the array that you're putting values into hash a prime length.  
You don't need to know why because Math is complicated!

### Dealing with Collisions(충돌 처리)

Even with a large array and a great hash function , collisions are inevitable.  
There are many strategies fro dealing with collisions, but we'll focus on two:

1. Separate Chaining
2. Linear Probing

#### Separate Chaining

- With _separate chaining_, at each index in our array we store values using a more sophisticated data structure (e.g. an array or a linked list).
  - This allows us to store multiple key-value pairs at the same index.
  - 같은 장소에 여러 데이터를 저장할 때 배열이나 연결 리스트 등과 같은 것을 활용하여 이중 데이터 구조를 쓴다.
    - 그러면 테이블의 길이보다 더 많은 데이터를 저장할 수 있다.

#### Linear Probing

- With _linear probing_, when we find a collision, we search through the array to find the next empty slot.
  - 각 위치에 하나의 데이터만 저장한다는 규칙을 그대로 살리려고 한다.
  - 충돌이 발생하면 다음 빈 칸이 어디인지 확인해서 데이터가 같은 인덱스에 저장되는 것을 막는다.

### A HashTable Class

```js
class HashTable {
  constructor(size = 53) {
    // 해시 테이블의 크기 결정
    this.keyMap = new Array(size);
  }

  _hash(key) {
    let total = 0;
    let WEIRD_PRIME = 31;
    for (let i = 0; i < Math.mi(key.length, 100); i++) {
      let char = key[i];
      let value = char.charCodeAt(0) - 96;
      total = (total * WEIRD_PRIME + value) % this.keyMap.length;
    }

    return total;
  }
}
```

### set/get 메서드, keys/values 메서드

#### set

1. Accepts a key and a value
2. Hashes the key
3. Stores the key-value pair in the hash table array via **separate chaining**
   그냥 데이터를 저장하지 않고, 해당 자리에서 개별 체이닝을 통해 중첩 구조로 저장한다.

#### get

1. Accepts a key
2. Hashes the key (인덱스 값으로)
3. Retrieves the key-value pair in the hash table  
   인덱스 값으로 나온 위치로 가서 하나 이상의 요소가 있다면 key 값에 의존해서 중첩 구조 안에 key값이 있는지 확인한다.
4. 해시 테이블에 해당하는 것이 없다면 undefined 출력

#### keys

1. Loops through the hash table array and returns an array of keys in the table

#### values

1. Loops through the hash table array and returns an array of values in the table

```js
class HashTable {
  constructor(size = 53) {
    // 해시 테이블의 크기 결정
    this.keyMap = new Array(size);
  }

  _hash(key) {
    let total = 0;
    let WEIRD_PRIME = 31;
    for (let i = 0; i < Math.min(key.length, 100); i++) {
      let char = key[i];
      let value = char.charCodeAt(0) - 96;
      total = (total * WEIRD_PRIME + value) % this.keyMap.length;
    }

    return total;
  }

  set(key, value) {
    let index = this._hash(key);

    // 해당 위치에 key-value pair가 없는 경우(처음으로 해당 위치에 key-value가 들어가는 경우)
    if (!this.keyMap[index]) {
      this.keyMap[index] = [];
    }
    // [ , , , ,[[key, value], [key, value]], , , ] 형태로 중첩 구조로 추가
    this.keyMap[index].push([key, value]);

    return this;
  }

  get(key) {
    let index = this._hash(key);
    if (this.keyMap[index]) {
      for (let i = 0; i < this.keyMap[index].length; i++) {
        if (this.keyMap[index][i][0] === key) return this.keyMap[index][i][1];
      }
      // 내가 해본 것
      // for (let keyInIdx of this.keyMap[index]) {
      //   if (keyInIdx[0] === key) return keyInIdx[1];
      // }
    }

    return undefined;
  }

  values() {
    let valuesArr = [];
    for (let i = 0; i < this.keyMap.length; i++) {
      if (this.keyMap[i]) {
        for (let j = 0; j < this.keyMap[i].length; j++) {
          if (!valuesArr.includes(this.keyMap[i][j][1])) {
            valuesArr.push(this.keyMap[i][j][1]);
          }
        }
      }
    }

    return valuesArr;
  }

  keys() {
    let keysArr = [];
    for (let i = 0; i < this.keyMap.length; i++) {
      if (this.keyMap[i]) {
        for (let j = 0; j < this.keyMap[i].length; j++) {
          // 원래는 키가 중첩되면 덮어씌워지도록 set 메서드에서 설정해줘야 함
          if (!keysArr.includes(this.keyMap[i][j][0])) {
            keysArr.push(this.keyMap[i][j][0]);
          }
        }
      }
    }

    return keysArr;
  }
}

let ht = new HashTable();
ht.set("maroon", "#800000");
ht.set("yellow", "#FFFF00");
ht.set("olive", "#808000");
ht.set("salmon", "#FA8072");
ht.set("lightcoral", "#F08080");
ht.set("mediumvioletred", "#C71585");
ht.set("plum", "#DDA0DD");
```

### Big O of Hash Tables

- Average Case
  - Insert: O(1)
  - Deletion: O(1)
  - Access: O(1)
  - 위 빅오는 해시 함수가 얼마나 빠른지, 그리고 얼마나 고르게 데이터를 분배해서 충돌의 횟수를 줄이는지에 달려있다.
- Worst Case
  - 한 인덱스에 모든 것을 넣는 경우 -> O(n)
  - 이런 상황이 온다면 무언가를 가져오거나, 삽입하거나, 맨 뒤에서 제거를 하는 경우에는 n의 시간이 걸린다.
  - 해시 함수 자체가 상수값의 시간을 가진다고 해도 리스트와 다름없기 때문이다.

### Recap

- Hash tables are collections of key-value pairs
- Hash tables can find values quickly given a key
- Hash tables can add new key-values quickly
- Hash tables store data in a large array, and work by _hashing_ the keys
- A good hash sholud be fast, distribute keys uniformly, and be deterministic
  - 해시 함수는 빨라야 하고, 요소들 간의 충돌을 가능한 적게 일관된 방식으로 분배하며, 결정론적이어야 한다.
- Separate chaining and linear probing are two strategies used to deal with two keys that hash to the same index

## 24. 그래프(Graphs)

### Objectives

- Explain what a graph is
- Compare and contrast different types of graphs and their use cases in the real world
- Implement a graph using an adjacency list(인접 리스트)
- Traverse through a graph using BFS and DFS
- Compare and contrast graph traversal algorithms

### What are graphs?

A **graph data structure** consists of a finite (and possibly mutable) set of vertices or nodes or points, together with a set of unordered pairs of these vertices for an undirected **graph** or a set of ordered pairs for a directed **graph**.

- 그래프는 유한하고 변할 수 있는 꼭지점이나 노드나 점들의 집합으로 구성된 데이터 구조이다.
  - 이 꼭지점들의 집합에는 순서가 없는 경우에는 무방향 그래프, 순서가 있는 경우에는 유방향 그래프라고 한다.

### Uses for Graphs

- Social Networks(SNS 등)
- Location / Mapping(지도 기능 - 구글 지도나 방향 안내, 위치, 길 찾기 등)
- Routing Algorithms(라우팅 - 사이트를 요청하면 전체 네트워크에 퍼져있는 것 중 일부 연결 부위를 주는 것)
- Visual Hierarchy
- File System Optimizations
- Recommandations(아래처럼 추천 엔진도 예시가 될 수 있음)
  - "People also watched"
  - "You might also like..."
  - "People you might know"
  - "Frequently bought with"
- **EVERYWHERE!**
- 위 예시들을 만드는 방법이 모든 데이터를 그래프 관계로 저장하는 것이다!

### Essential Graph Terms
* **Vertext**(정점) - a node
* **Edge**(간선) - connection between nodes
* **Weighted/Unweighted**(가중/비가중) - values assigned to distances between vertices
* **Directed/Undirected**(방향/무방향) - directions assigned to distanced between vertices