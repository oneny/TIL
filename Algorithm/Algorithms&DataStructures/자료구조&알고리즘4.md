# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [19. 스택(Stack)과 큐(Queues)](#19-스택stack과-큐queues)
  - [What is a stack?](#what-is-a-stack)
  - [How is it used?](#how-is-it-used)
  - [How we'll visualize a stack](#how-well-visualize-a-stack)
  - [Where stacks are used](#where-stacks-are-used)
  - [Linked Lists의 개념을 활용해서 스택 셋업하기](#linked-lists의-개념을-활용해서-스택-셋업하기)
  - [push/pop 메서드](#pushpop-메서드)
  - [Big O of Stacks](#big-o-of-stacks)
  - [What is a queue?](#what-is-a-queue)
  - [enqueue/dequeue 메서드](#enqueuedequeue-메서드)
  - [Big O of Queues](#big-o-of-queues)
- [20. 이진 검색 트리(Trees)](#20-이진-검색-트리trees)

## 19. 스택(Stack)과 큐(Queues)

### Objectives

- Define what a stack is
- Understand use cases for a stack
- Implement operations on a stack data structure
- Define what a queue is
- Understand use cases for a queue
- Implement operations on a queue data structure

### What is a stack?

- 한 마디로 하면 스택은 후입선출의 원칙(**LIFO**)을 따르는 데이터들의 집합
- A **LIFO** data structure!
  - The last element added to the stack will be the first element removed from the stack
- 반대로 큐는 선입선출의 원칙을 따른다.

### How is it used?

Think about a stack of **plates**, or a stack of **markers** or a stack of ...**anything**  
As you pile it up the last thing (or the topmostthing) is what gets removed first

### How we'll visualize a stack

```
A siries of nodes!

     last     size = 4     first
       ---------------------
      |                     |
<--- 10 <--- 2 <--- 22 <--- 7
```

### Where stacks are used

- Managing function invocations
- Undo / Redo (command + z / command + shift + z와 같은..)
- Routing (this history object) is treated like a stack!
- And much more!

### Linked Lists의 개념을 활용해서 스택 셋업하기

- Singly Linked Lists의 `push`와 `pop`을 사용하지 않는 이유?
  - Singly Linked Lists에서 `pop`은 상수값의 시간을 가지지 않는다.
  - 전체 리스트를 순회해서 테일노드의 앞 노드를 알아야 하므로 상수값을 가지지 않는다.
- 그냥 리스트에서 맨 뒤에 추가와 제거를 스택에서 맨 앞에서 추가와 제거를 하면 된다.

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }
}
```

### push/pop 메서드

**Add** and **remove** a value to the **top** of the stack!

#### Push Pseducode

- The function should accept a value
- Create a new node with that value
- If there are no nodes in the stack, set the first and last property to be the newly created node
- If there is at least one node, create a variable that stores the current first property on the stack
- Reset the first property ot be the newly created node
- Set the next property on the node to be the previously created variable
- Increment the size of the stack by 1

#### Pop Pseudocode

- If there are no nodes in the stack, return null
- Create a temporary variable to store the first property on the stack
- If there is only 1 node, set the first and last property to be null
- If there is more than one node, set the first property to be the next property on the current first

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }

  push(value) {
    const newNode = new Node(value);
    if (!this.first) {
      this.first = newNode;
      this.last = newNode;
    } else {
      const temp = this.first;
      this.first = newNode;
      this.first.next = temp;
    }
    return ++this.size;
  }

  pop() {
    if (!this.first) return null;

    const temp = this.first;
    // this.size === 1
    if (this.first === this.last) {
      this.last = null;
    }
    // 가장 처음 들어간 노드의 next는 항상 null이므로 if 문 밖으로 빼줘서 노드가 둘 이상인 경우와 같이 한 번에 처리
    this.first = this.first.next;
    this.size--;

    return temp.value;
  }
}
```

### Big O of Stacks

- Insertion - O(1)
- Removal - O(1)
- Searching - O(n)
- Access - O(n)

### What is a queue?

- A **FIFO** data structure!
  - First In First Out
- Queues are useful for processing tasks and are foundational for more complex data structures

### enqueue/dequeue 메서드

#### Enqueue Pseudocode

- This function accepts some value
- Create a new node using that value passed to the function
- If there are no nodes in the queue, set this node to be the first and last property of the queue
- Otherwise, set the next property on the current last to be that node, and then set the last property of the queue to be that node
- Increment the size of the queue by 1
- Return the size of the queue

#### Dequeue Pseudocode

- If there is no first property, just return null
- Store the first property in a variable
- see if the first is the same as the last (check if there is only 1 node). If so, set the first and last to be null
- If there is more than 1 node, set the first property to be the next property of first
- Decrement the size by 1
- Return the value of the node dequeued

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Queue {
  constructor() {
    this.first = null;
    this.last = null;
    this.size = 0;
  }

  enqueue(value) {
    const newNode = new Node(value);
    if (!this.first) {
      this.first = newNode;
      this.last = newNode;
    } else {
      this.last.next = newNode;
      this.last = newNode;
    }

    return ++this.size;
  }

  dequeue() {
    if (!this.first) return null;

    const temp = this.first;
    if (this.first === this.last) {
      this.last = null;
    }
    this.first = this.first.next;
    this.size--;

    return temp.value;
  }
}
```

### Big O of Queues

- Insertion - O(1)
- Removal - O(1)
- Searching - O(n)
- Access - O(n)
- Insertion and Removal can be done in **O(1)**

## 20. 이진 검색 트리(Trees)

### Objectives

- Defined what a tree is
- Compare and contrast trees and lists
- Explain the differences between trees, binary trees, and binary search trees
- Implement operations on binary search trees

### What is a tree?

- A data structure that consists of nodes in a **parent / child** relationship
  - **Lists** - linear(선형 구조)
  - **Trees** - nonlinear(비선형 구조)
- Tree Terminology
  - **Root** - The top node in a tree
  - **Child** - A node directly connected to another node when moving away from the Root
  - **Parent** - The converse notion of a child
  - **Siblings** - A group of nodes with the same parent
  - **Leaf** - A node with no children
  - **Edge** - The connection between one node and another

### Where trees are used

- Lots of different applications!
  - HTML DOM
    - 개발자 도구에 document.body.children[0].children...으로 출력하면 부모-자식 관계로 이루어진 것 확인 가능
    - 여러 요소들이 있고, 한 요소 안에 자식에 해당하는 다른 요소가 중첩되어 있다.
  - Network Routing
  - Abstract Syntax Tree(프로그래밍 언어로 작성된 추상 구문 트리)
  - Artificial Intelligence(인공 지능)
  - Folders in Operating Systems
  - Computer File Systems

### Kind of Trees

- Trees - 자식이 몇 개든 상관없다.
- Binary Trees - 각 노드가 최대 두 개의 자식을 가져야 하는 특별한 조건이 있다.
- Binary Search Trees - 특별한 방식으로 데이터가 순서대로 정렬된 이진 트리의 종류 중 하나
  - Every parent node has at most **two** children
  - Every node to the left of a parent node is **always less** than the parent
  - Every node to the right of a parent node is **always greater** than the parent
    ```
             41
          /     \
        20       65
      /   \     /  \
    11    29   50   91
      \     \      /  \
       12    32   72   99
    ```

### The BinarySearchTree Class

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySerachTree {
  constructor() {
    this.root = null;
  }
}
```

### insert 메서드

#### Insert Pseudocode(Steps - Iteratively or Recursively)

- Create a new node
- Starting at the root
- Check if there is a root, if not - the root now becomes that new node!
  - If there is a root, check if the value of the new node is greater than or less than the value of the root
  - If it is greater, Check to see if there is a node to the right
    - If there is, move to that node and repeat these steps
    - If there is not, add that node as the right property
  - If is less, Check to see if there is a node to the left
    - If there is, move to that node and repeat these steps
    - If there is not, add that node as the left property

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  insert(value) {
    const newNode = new Node(value);
    if (!this.root) {
      this.root = newNode;
      return this;
    } else {
      let current = this.root; // root를 시작점으로 자식으로 내려가면서 현재 노드위치를 나타내는 변수
      while (true) {
        if (value === current.value) return undefined;
        if (value < current.value) {
          if (!current.left) {
            // 왼쪽 가지가 빈 경우
            current.left = newNode;
            return this;
          }
          // 왼쪽 가지에 노드가 있는 경우
          current = current.left;
        } else {
          if (!current.right) {
            current.right = newNode;
            return this;
          }
          current = current.right;
        }
      }
    }
  }
}
```

### find 메서드

#### Finding Pseudocode

- Starting at the root
  - Check if there is a root, if not - we're done searching!
  - If there is a root, check if the vaue of the new node is the value we are looking for. If we found it, we're done!
  - If not, check to see if the value is greater than or less than the value of the root
  - If it is greater, check to see if there is a node to the right
    - If there is, move to that node and repeat these steps
    - If there is not, we're done searching!
  - If it is less, check to see if there is a node to the left
    - If there is, move to that node and repeat these steps
    - If there is not, we're done searching!

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  find(value) {
    if (this.root === null) return false;
    let current = this.root;
    let found = false;
    while (current && !found) {
      if (value < current.value) {
        current = current.left;
      } else if (value > current.value) {
        current = current.right;
      } else {
        found = true;
      }
    }
    if (!found) return false;
    return current;
  }

  // true, false 값만 반환하는 메서드
  contains(value) {
    if (this.root === null) return false;
    let current = this.root;
    let found = false;
    while (current && !found) {
      if (value < current.value) {
        current = current.left;
      } else if (value > current.value) {
        current = current.right;
      } else {
        return true;
      }
    }
    return false;
  }
}
```

```js
// 내가 만들어본 find 메서드
find(value) {
    if (this.root === null) return false;

    let current = this.root;
    while (true) {
      if (value === current.value) return current;
      if (value < current.value) {
        if (!current.left) return false;
        current = current.left;
      } else {
        if (!current.right) return false;
        current = current.right;
      }
    }
  }
```

### Big O of Binary Search Trees

- Insertion - **O(log n)**
- Searching - **O(log n)**
- 이미 데이터를 insert할 때 O(log n)으로 위치를 찾아 정렬하기 때문에 search할 때도 O(log n) 시간 복잡도로 데이터를 찾을 수 있다.
- **But, NOT guaranteed!**
  - 이진 탐색 트리는 평균적인 경우와 최고의 경우에 트리가 가지는 시간 복잡도는 O(log n)이다.
  - 최악의 경우
    - 3 -> 17 -> 19 -> 32 -> 34 -> 63 -> 86 -> 91 -> ...로 리스트처럼 한쪽으로 가지가 치우진 경우
    - 그러면 완전히 한 쪽으로 쏠린 트리에 대해서는 O(n)의 값을 가지게 된다.
