# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [06. 재귀(Recursion)](#06-재귀recursion)
  - [재귀 함수를 사용하는 이유](#재귀-함수를-사용하는-이유)
    - [What is recursion](#what-is-recursion)
    - [The reason for using recursion function](#the-reason-for-using-recursion-function)
  - [스택 호출하기](#스택-호출하기)
    - [The Call Stack](#the-call-stack)
    - [Why do I care?](#why-do-i-care)
  - [Base Case](#base-case)
    - [How recursive functions work](#how-recursive-functions-work)
    - [What is Base Case?](#what-is-base-case)
    - [Two essential parts of a recursive function](#two-essential-parts-of-a-recursive-function)
    - [반복문으로 팩토리얼 구현하기](#반복문으로-팩토리얼-구현하기)
    - [재귀 호출로 팩토리얼 구현하기](#재귀-호출로-팩토리얼-구현하기)
  - [통상적인 재귀의 잠재적 위험](#통상적인-재귀의-잠재적-위험)
    - [Where things go wrong](#where-things-go-wrong)
  - [Helper 메서드 재귀](#helper-메서드-재귀)
    - [Helper Method Recursion](#helper-method-recursion)
    - [Example](#example)
  - [순수 재귀](#순수-재귀)
    - [Pure Recursion](#pure-recursion)
    - [Pure Recursion Tips](#pure-recursion-tips)
- [07. 재귀 문제 집합](#07-재귀-문제-집합)
  - [power](#power)
  - [factorial](#factorial)
  - [productOfArray](#productofarray)
  - [recursiveRange](#recursiverange)
  - [fib](#fib)
- [08. 보너스 도전 재귀 문제](#08-보너스-도전-재귀-문제)
  - [reverse](#reverse)
  - [isPalindrome](#ispalindrome)
  - [someRecursive](#somerecursive)
  - [flatten](#flatten)
  - [capitalizeFirst](#capitalizefirst)
  - [nestedEvenSum](#nestedevensum)
  - [capitalizeWords](#capitalizewords)
  - [stringifyNumbers](#stringifynumbers)
  - [collectStrings](#collectstrings)
- [09. 검색 알고리즘](#09-검색-알고리즘)
  - [선형 검색(Linear Search)](#선형-검색linear-search)
    - [How do we search?](#how-do-we-search)
    - [Linear Search Pseudocode(선형 검색 의사코드)](#linear-search-pseudocode선형-검색-의사코드)
    - [Linear Search BIG O](#linear-search-big-o)
  - [이진 검색(Binary Search)](#이진-검색binary-search)
    - [이진 검색 소개](#이진-검색-소개)
    - [Divide and Conquer](#divide-and-conquer)
    - [Binary Search Pseudocode](#binary-search-pseudocode)
    - [What About Big O](#what-about-big-o)
  - [나이브 문자열 검색(Naive String Search)](#나이브-문자열-검색naive-string-search)
    - [Naive String Search Pseudocode](#naive-string-search-pseudocode)
- [10. 버블 정렬](#10-버블-정렬)
  - [정렬 알고리즘 소개](#정렬-알고리즘-소개)
    - [What is sorting?](#what-is-sorting)
    - [Why do we need to learn this](#why-do-we-need-to-learn-this)
  - [버블 정렬(BubleSort)](#버블-정렬bublesort)
  - [BubbleSort Pseudocode](#bubblesort-pseudocode)
  - [버블 정렬 최적화](#버블-정렬-최적화)
  - [버블 정렬 빅오 표기법](#버블-정렬-빅오-복잡도)
- [11. 선택 정렬](#11-선택-정렬)
  - [Selection Sort](#selection-sort)
  - [Selection Sort Pseudocode](#selection-sort-pseudocode)
  - [선택 정렬 구현](#선택-정렬-구현)
  - [선택 정렬 빅오 복잡도](#선택-정렬-빅오-복잡도)
- [12. 삽입 정렬](#12-삽입-정렬)
  - [Insertion Sort](#insertion-sort)
    - [Insertion Sort Pseudocode](#insertion-sort-pseudocode)
    - [삽입 정렬 구현](#삽입-정렬-구현)
    - [삽입 정렬 빅오 복잡도](#삽입-정렬-빅오-복잡도)
  - [버블, 선택, 삽입 정렬 비교](#버블-선택-삽입-정렬-비교)
    - [Recap](#recap)

# 06. 재귀(Recursion)

### Obectives

- Define what recursion is and how it can be used
- Understand the two essential components of a recursive function
- Visualize the call stack to better debug and understand recursive functions
- Use helper method recursion and pure recursion to solve more difficult problems
  - 헬퍼 메서드 재귀와 순수 재귀에 대해 알아보고 두 가지를 비교하기

## 재귀 함수를 사용하는 이유

### What is recursion?

- A `process` (a function in our case) that `calls itself`
- 재귀는 자기 자신읗 호출하는 절차라는 의미이다.

### The reason for using recursion function

- It's everywhere!
  - 재귀는 어디서든 사용될 수 있다.
  - JSON.parse / JSON.stringify이 보통 재귀적으로 작성된다.
  - document.getElementById and DOM traversal algorithms(순회 알고리즘)
    - DOM은 모든 요소가 중첩된 트리 구조로 되어 있다.
  - Object traversal(객체 순회)
  - 데이터 구조/트리/그래프를 순회하고, 그 안에 있는 요소를 검색하고자 하는 경우에 자주 사용된다.
  - It's sometimes a cleaner alternative to iteration
    - 반복 대신 재귈르 사용하는 게 더 깔끔할 때가 있다.

## 스택 호출하기

- 재귀 함수가 자기 자신을 계속 호출하고 또 호출한다면, 자바스크립트 엔진에서 무슨 일이 일어날까?
- In almost all program languages, there is a built in data structure that manages what happens when functions are invoked.
  - 거의 모든 프로그래밍 언어에는 보이지 않는 곳에서 함수를 호출을 관리하는 일종의 데이터 구조가 있다.
  - 호출된 함수는 다른 함수가 반환(return)될 때까지 기다리는 경우가 많다.
    - 즉, 함수는 무작위로 실행된 것이 아닌 올바른 순서대로 실행되어야 한다.
  - 자바스크립트의 경우에는 `호출 스택`이 함수 호출을 관리하는 데이터 구조이다.

### The call stack

- It's a `stack` data structure
  - 자바스크립트의 보이지 않는 곳에서 작동하는 스택(`stack`) 데이터 구조이다.
- Any time a function is invoked it is placed (`pushed`) on the top of the call stack.
  - 함수를 호출하면, 호출 스택의 꼭대기에 쌓인다.
- When JavaScript sees the` return` keyword or when the function ends, the compiler will remove(`pop`)
  - 자바스크립트가 반환 키워드(return keyword)를 확인하거나, 함수 안에 더 이상 실행할 코드가 없으면 컴파일러(compiler)가 스택의 제일 위에 있는 항목을 제거할 것이다.

```javascript
function takeShower() {
  return "Showering!";
}

function eatBreakfast() {
  let meal = cookFood();
  return `Eating ${meal}`;
}

function cookFood() {
  let items = ["Oatmeal", "Eggs", "Protein Shake"];
  return items[Math.floor(Math.random() * items.length)]; // 0 ~ 2
}

function wakeUp() {
  takeShower();
  eatBreakfast();
  console.log("Ok ready to go to work!");
}

wakeUp();
```

- wakeUp 함수 호출 -> takeShower 함수 호출 -> "Showering!" 반환 -> eatBreakfast 함수 호출 -> cookFood() 함수 호출 -> 배열 중 엘리먼트 하나 반화 -> "Eating ..." 반환 -> console.log 실행

### Why do I care?

- 재귀 함수릃 작성하게 되면 호출 스택을 엄청나게 많이 사용하게 될 것이다.
- You're used to functions being pushed on the call stack and popped off when they are done.
  - 함수를 호출스택에 추가(push)하고, 완료되면 제거(pop)하는 과정에 익숙해졌다.
- When we write recursive functions, we keep pushing new functions onto the call stack!
  - 하지만, 재귀 함수는 계속해서 새로운(=) 함수를 호출 스택에 추가한다.
  - 그리고 언제 종료되는지를 알아야 한다.

## Base Case

### How recursive functions work

- Invoke the <b>same</b> function with a different input until you reach your base case!
  - 동일한 함수를 계속 호출하면서, 하나의 함수가 자기 자신을 재귀적으로 호출한다.
  - 종료 조건(`base case`)에 도달할 때까지!

### What is Base Case?

- The condition when the recursion ends(재귀가 멈추는 시점)
- This is the most important concept to understand

### Two essential parts of a recursive function

#### 첫 번째 함수

```javascript
function countDown(num) {
  if (num <= 0) {
    console.log("All done!");
    return;
  }
  console.log(num);
  num--;
  countDown(num);
}

countDown(3);

// 순서
// print "3"
// coundDown(2);
// print "2"
// coundDown(1);
// print "1"
// coundDown(0);
// print "All done!"
```

#### 두 번쨰 함수

- 참고해야 할 사항
  - Can you spot the base case?(종료 조건이 보이는지)
  - Do you notice the different input?(다른 입력값이 있는지)
  - What would happen if we didn't return?(return 되지 않는다면 어떤 일이 일어나는지)

```javascript
function sumRange(num) {
  if (num === 1) return 1;
  return num + sumRange(num - 1);
}

sumRange(4); // 10

//  4 + sumRange(3)
//  3 + sumRange(2)
//  2 + sumRanage(1)
// return 1
// return 2 + 1 (3)
// return 3 + 3 (6)
// return 4 + 6 (10)

// 4 + sumRange(3)
//     return 3 + sumRange(2)
//                return 2 + sumRange(1)
//                           return 1;
```

### 반복문으로 팩토리얼 구현하기

- 재귀 함수 사용법을 가장 고전적으로 설명하는 것이 **팩토리얼(factorial)** 이다.

- 아래 함수는 비재귀적 솔루션, 반복 솔루션이다.

```javascript
function factorial(num) {
  let total = 1;
  for (let i = num; i > 0; i--) {
    total *= i;
  }
  return total;
}
```

### 재귀 호출로 팩토리얼 구현하기

```javascript
function factorial(num) {
  if (num === 1) return 1;
  return num * factorial(num - 1);
}
```

## 통상적인 재귀의 잠재적 위험

### Where things go wrong

- No base case(종료 조건이 없거나 잘못되는 경우)
  - 종료 조건이 없으면 스택의 최대 크기 초과되고, `Maximum call stack size exceed`라는 에러 발생한다.
  - 최대 호출 스택 크기 초과를 보통 `스택 오버플로우(stack overflow)`라고 부른다.
- Forgetting to return or returning the wrong thing
  - 잘못된 값을 반환하거나, 애초에 반환하는 것을 잊는 것
  - 위의 return num \* factorial(num)으로 반환해버리면 num은 1에 도달하지 못하므로 위와 같은 에러가 발생한다.

## Helper 메서드 재귀

- 위에서 지금까지 작성했던 모든 재귀함수는 팩토리얼처럼 단일 단독 함수(single standalone function)이다.
  - 함수 외부에서 팩토리얼을 호출하면, 팩토리얼은 직접 자체 코드 내의 팩토리얼을 호출한다.
  - 즉, 스스로를 재귀한다.

### Helper Method Recursion

- 재귀적이지 않은 외부 함수가 호출되면 재귀적인 내부 함수를 호출하는 패턴

```javascript
function outer(input) {
  var outerScopeVariable = [];
  function helper(helperInput) {
    // modify the outerScopedVariable
    helper(helperInput--);
  }
  helper(input);

  return outerScopedVariable;
}
```

- 헬퍼 메서드 재귀에는 두 개의 함수가 있다.
  - 외부 함수(outer function)와 안에 있는 재귀 함수이다.
  - 개발자는 외부 함수를 호출해서 무언가를 내부로 전달할 수 있다.
  - 그리고 외부 함수 안에는 또 다른 함수가 정의되어 있고, 그 함수는 호출이 되어 재귀적으로 자기 자신을 호출한다.
  - 우리가 배열이나 데이터 목록 같은 것을 컴파일(compile)해야 할 때 흔히 위 패턴처럼 작업한다.

### Example

- Let's try to collect all of the odd values in an array

```javascript
function collectOddValues(arr) {
  let result = [];

  function helper(helperInput) {
    if (helperInput.length === 0) return; // helperInput의 엘리먼트 개수가 0되면 종료

    if (helperInput[0] % 2 !== 0) result.push(helperInput[0]);

    return helper(helperInput.slice(1)); // 0번 인덱스 뺸 배열
  }

  helper(arr);

  return result;
}

collectOddValues([1, 2, 3, 4, 5]); // [1, 3, 5]
```

## 순수 재귀

### Pure Recursion

```javascript
function collectOddValues(arr) {
  let newArr = [];

  if (arr.length === 0) return newArr;

  if (arr[0] % 2 !== 0) newArr.push(arr[0]);

  newArr = newArr.concat(collectOddValues(arr.slice(1)));

  return newArr;
}

collectOddValues([1, 2, 3]); // [1, 3]
// newArr
// [1].concat(collectOddValues([2, 3, 4, 5]))
//            [].concat(collectOddValues([3, 4, 5]))
//                      [3].concat(collectOddValues[])
//                                 return []
//                      [3].concat([])
//            [].concat([3])
// [1].concat[3]
// return [1, 3]
```

- 헬퍼 메서드 재귀가 훨씬 직관적인 것 같다.

### Pure Recursion Tips

- For arrays, use methods like `slice`, `the spread operator`, and `concat` that make copies of arrays so you do not mutate themz
  - 배열을 사용하고 헬퍼 메서드 없이 순수 재귀 솔루션을 작성하는 경우에
  - 배열을 복사하는 `splice`, `spread 연산자`, `concat` 같은 메서드를 사용할 수 있다.
  - 그러면 배열읍 변경할 필요가 없이 일종의 결과를 축적할 수 있다.

* Remember that strings are immutable so you will need to use methods like `slice`, `substr`, or `substring` to make copies of strings
  - 문자열은 변경할 수 없다.
  - 그래서 `slice`나 `substring`을 사용해서 사본을 만들어야 한다.
* To make copies of objects use `Object.assign`, or `the spread operator`
  - 객체의 경우, Object.assign이나 `spread 연산자`를 사용하는 것이 유용하다.

## 07. 재귀 문제 집합

### power

Write a function called `power` which accepts a base and an exponent(지수). The function should return the power of the base to the exponent. This function should mimic(흉내내다) the functionality of `Math.pow()` - do not worry about negative bases and exponents

```javascript
// power(2, 0) -> 1
// power(2, 2) -> 4
// power(2, 4) -> 16
function power(base, expo) {
  if (expo === 0) return 1;
  return base * power(base, --expo);
}
```

- 강의 솔루션도 같은 풀이

### factorial

Write a function `factorial` which accepts a number and returns the factorial of that number. A factorial is the product of an integer and all the integers below it; e.g., factorial four(4!) is equal to 24, because 4 _ 3 _ 2 \* 1 equals 24. factorial zero (0!) is always 1.

```javascript
// factorial(1) -> 1
// factorial(2) -> 2
// factorial(4) -> 24
function factorial(num) {
  if (num === 0) return 1;
  return num * factorial(--num);
}
```

#### 강의 솔루션

```javascript
function factorial(x) {
  if (x < 0) return 0;
  if (x <= 1) return 1;
  return x * factorial(x - 1);
}
```

### productOfArray

Write a function called `productOfArray` which takes in an array of numbers and returns the product of them all.

```javascript
// productOfArray([1, 2, 3]) -> 6
// productOfArray([1, 2, 3, 10]) -> 60
function productOfArray(arr) {
  if (arr.length === 0) return 1;
  return arr[0] * productOfArray(arr.slice(1));
}
```

- 강의 솔루션도 같은 풀이

### recursiveRange

Write a function called `recursiveRange` which accepts a number and adds up all the numbers from 0 to the number passed to the function

```javascript
// recursiveRange(6) -> 21
// recursiveRange(10) -> 55
function recursiveRange(num) {
  if (num === 0) return 0;
  return num + recursiveRange(--num);
}
```

- 강의 솔루션도 같은 풀이

### fib

Write a recursive function called `fib` which accepts a number and returns the nth number in the Fibonacci sequence. Recall that the Fibonacci sequence is the sequence of whole numbers 1, 1, 2, 3, 5, 8, ... which starts with 1 and 1, and where every number thereafter is equal to the sum of the previous two numbers.

```javascript
// fib(4) -> 3
// fib(10) -> 55
// fib(28) -> 317811
// fib(35) -> 9227465
function fib(num) {
  // 1 + 1 + 2 + 3 + 5 + 8 + 13 + 21 + 34 + 55
  const arr = [1, 1];
  let result = 0;
  let f1 = 0;
  let f2 = 1;
  if (num <= 2) return 1;

  function helper() {
    if (arr.length === num) {
      result = arr[arr.length - 1];
      return result;
    }

    arr.push(arr[f1] + arr[f2]);
    f1++;
    f2++;
    helper();
  }

  helper();

  return result;
}
```

#### 강의 솔루션

```javascript
function fib(n) {
  if (n <= 2) return 1;
  return fib(n - 1) + fib(n - 2);
}
```

## 08. 보너스 도전 재귀 문제

### reverse

Write a recursive function called `reverse` which accepts a string and returns a new string in reverse.

```javascript
// reverse('awesome') -> 'emosewa'
// reverse('rithmschool') -> 'loohcsmhtir'
function reverse(str) {
  // awesome
  let result = "";

  function helper(str) {
    if (str.length === 0) return;
    result += str[str.length - 1];

    helper(str.slice(0, str.length - 1));
  }

  helper(str);

  return result;
}

function reverse(str) {
  console.log("hi", str);
  let arr = str.split("");
  let result = [];

  if (arr.length === 0) return "";
  result.push(arr[arr.length - 1]);
  result = result.concat(reverse(arr.slice(0, arr.length - 1).join("")));

  return result.join("");
}

function reverse(str) {
  let result = "";

  if (str.length === 0) return "";
  result += str[str.length - 1];
  result = result.concat(reverse(str.slice(0, str.length - 1)));

  return result;
}
```

#### 강의 솔루션

```javascript
function reverse(str) {
  if (str.length <= 1) return str;
  return revers(str.slice(1)) + str[0];
}
```

### isPalindrome

Write a recursive function called `isPalindrome` which returns true if the string passed to it is a palindrome (reads the same forward and backward). Otherwise it returns false.

```javascript
// isPalindrome('awesome') -> false
// isPalindrome('foobar') -> false
// isPalindrome('tacocat') -> true
// isPalindrome('amanaplanacanalpanama') -> true
function isPalindrome(str) {
  if (str.length <= 1) return true;

  let start = 0;
  let end = str.length - 1;

  if (str[start] !== str[end]) return false;

  str = str.substring(1, str.length - 1);

  return isPalindrome(str);
}
```

#### isPalindrome 강의 솔루션

```javascript
function isPalindrome(str) {
  if (str.length === 1) return true;
  if (str.length === 2) return str[0] === str[1];
  if (str[0] === str.slice(-1)) return isPalindrome(str.slice(1, -1));
  return false;
}
```

### someRecursive

Write a recursive function called `someRecursive` which accepts an array and a callback. The function returns true if a single value in the array returns true when passed to the callback. Otherwise it returns false.

```javascript
// const isOdd = val => val % 2 !== 0;
// someRecursive([1,2,3,4], isOdd) // true
// someRecursive([4,6,8,9], isOdd) // true
// someRecursive([4,6,8], isOdd) // false
// someRecursive([4,6,8], val => val > 10); // false

function someRecursive(arr, callback) {
  if (arr.length === 0) return false;
  if (callback(arr[0])) return true;

  return someRecursive(array.slice(1), callback);
}
```

- 강의 솔루션과 같은 풀이

### flatten

Write a recursive function called `flatten` which accepts an array of arrays and returns a new array with all values flattened.

```javascript
// flatten([1, 2, 3, [4, 5]]) // [1, 2, 3, 4, 5]
// flatten([1, [2, [3, 4], [[5]]]]) // [1, 2, 3, 4, 5]
// flatten([[1],[2],[3]]) // [1,2,3]
// flatten([[[[1], [[[2]]], [[[[[[[3]]]]]]]]]]) // [1,2,3]
function flatten(arr) {
  const result = [];

  function helper(arr) {
    if (arr.length === 0) return;

    if (Array.isArray(arr[0])) {
      helper(arr[0]);
      helper(arr.slice(1));
    } else {
      result.push(arr[0]);
      helper(arr.slice(1));
    }
  }
  helper(arr);

  return result;
}
```

#### flatten 강의 솔루션

```javascript
function flatten(arr) {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
```

### capitalizeFirst

Write a recursive function called `capitalizeFirst`. Given an array of strings, capitalize the first letter of each string in the array.

```javascript
// capitalizeFirst(['car','taco','banana']); -> ['Car','Taco','Banana']
function capitalizeFirst(arr) {
  let result = [];

  for (let i = 0; i < arr.length; i++) {
    let value = arr[i];
    arr[i] = value.replace(value[0], value[0].toUpperCase());
  }
  return arr;
}
```

- capitalizeFirst 강의 솔루션 없음

### nestedEvenSum

문제 설명이 안나와 있지만 객체 내 프로퍼티를 돌면서 짝수들만 더하라는 문제인 것 같다.

```javascript
var obj1 = {
  outer: 2,
  obj: {
    inner: 2,
    otherObj: {
      superInner: 2,
      notANumber: true,
      alsoNotANumber: "yup",
    },
  },
};

var obj2 = {
  a: 6,
  b: { b: 2, bb: { b: 3, bb: { b: 2 } } },
  c: { c: { c: 2 }, cc: "ball", ccc: 5 },
  d: 1,
  e: { e: { e: 4 }, ee: "car" },
};

// nestedEvenSum(obj1); -> 6
// nestedEvenSum(obj2); -> 10
function nestedEvenSum(obj) {
  let result = 0;

  function helper(obj) {
    for (let value of Object.values(obj)) {
      if (typeof value === "object") {
        helper(value);
      } else {
        if (value % 2 === 0) result += value;
      }
    }
  }

  helper(obj);

  return result;
}
```

#### nestedEvenSum 솔루션

```javascript
// 파라미터에 sum = 0이 방법도 있었네... 그래도 비슷하게 풀었다
function nestedEvenSum(obj, sum = 0) {
  for (let key in obj) {
    if (typeof obj[key] === "object") {
      sum += nestedEvenSum(obj[key]); // sum += 안하면 재귀 호출할 때 sum이 0이 되버린다.
    } else if (typeof obj[key] === "number" && obj[key] % 2 === 0) {
      sum += obj[key];
    }
  }

  return sum;
}
```

### capitalizeWords

Write a recursive function called `capitalizeWords`. Given an array of words, return a new array containing each word capitalized.

```javascript
// capitalizeFirst(['car','taco','banana']); -> ['CAR','TACO','BANANA']
function capitalizeWords(arr) {
  if (arr.length === 1) return [arr[0].toUpperCase()];

  let res = capitalizeWords(arr.slice(0, -1));
  res.push(arr.slice(-1)[0].toUpperCase());

  return res;
}
```

#### capitalizeWords 솔루션

```javascript
// 답이 안나오는데....
function capitalizeWords(array) {
  if (array.length === 1) {
    return [array[0].toUpperCase()];
  }
  let res = capitalizeWords(array.slice(0, -1));
  res.push(array.slice(array.length - 1)[0].toUpperCase());
  return res;
}
```

### stringifyNumbers

Write a function called `stringifyNumbers` which takes in an object and finds all of the values which are numbers and converts them to strings. Recursion would be a great way to solve this!

```javascript
/*
let obj = {
    num: 1,
    test: [],
    data: {
        val: 4,
        info: {
            isRight: true,
            random: 66
        }
    }
}
/*

stringifyNumbers(obj)

/*
{
    num: "1",
    test: [],
    data: {
        val: "4",
        info: {
            isRight: true,
            random: "66"
        }
    }
}
*/
function stringifyNumbers(obj) {
  let newObj = {};

  for (let [key, value] of Object.entries(obj)) {
    if (typeof value === "object" && !Array.isArray(obj[key])) {
      newObj[key] = stringifyNumbers(value);
    } else if (typeof value === "number") {
      newObj[key] = value.toString();
    } else {
      newObj[key] = value;
    }
  }

  return newObj;
}
```

#### stringifyNumbers 솔루션

```javascript
function stringifyNumbers(obj) {
  var newObj = {};
  for (var key in obj) {
    if (typeof obj[key] === "number") {
      newObj[key] = obj[key].toString();
    } else if (typeof obj[key] === "object" && !Array.isArray(obj[key])) {
      newObj[key] = stringifyNumbers(obj[key]);
    } else {
      newObj[key] = obj[key];
    }
  }

  return newObj;
}
```

### collectStrings

Write a function called `collectStrings` which accepts an object and returns an array of all the values in the object that have a typeof string.

```javascript
const obj = {
  stuff: "foo",
  data: {
    val: {
      thing: {
        info: "bar",
        moreInfo: {
          evenMoreInfo: {
            weMadeIt: "baz",
          },
        },
      },
    },
  },
};

// collectStrings(obj) -> ["foo", "bar", "baz"])

function collectStrings(obj) {
  let arr = [];

  for (let value of Object.values(obj)) {
    if (typeof value === "string") {
      arr.push(value);
    } else if (typeof value === "object" && !Array.isArray(value)) {
      arr = arr.concat(collectStrings(value));
    }
  }

  return arr;
}
```

### collectString 솔루션

```javascript
// Helper 메서드 재귀 버전
function collectStrings(obj) {
  let stringArr = [];

  function gatherStrings(o) {
    for (let key in o) {
      if (typeof o[key] === "string") stringArr.push(o[key]);
      else if (typeof o[key] === "object") return gatherStrings(o[key]);
    }
  }

  gatherStrings(obj);

  return stringArr;
}

// 순수 재귀 버전
function collectStrings(obj) {
  var stringsArr = [];
  for (var key in obj) {
    if (typeof obj[key] === "string") {
      stringsArr.push(obj[key]);
    } else if (typeof obj[key] === "object") {
      stringsArr = stringsArr.concat(collectStrings(obj[key]));
    }
  }

  return stringsArr;
}
```

# 09. 검색 알고리즘

### Objectives

- Describe what a searching algorithm is(검색 알고리즘이 무엇인지 설명)
- Implement linear search on arrays(배열에 선형 검색 구현)
- Implement binary search on sorted arrays(정렬된 배열에서의 이진 검색 구현)
- Implment a naive string searching algorithm(naive 문자열 검색 알고리즘 구현)
- Implement the KMP string searching algorithm(KMP 문자열 검색 알고리즘 구현)

## 선형 검색(Linear Search)

### How do we search?

- Given an array, the simplest way to search for an value is to look at every element in the array and check if it's the value we want.
  - 가장 간단한 방법은 모든 개별 항목을 순서대로 살펴보면서 우리가 원하는 값인지 확인하는 것이다.
  - 이러한 접근법은 나쁜 방법은 아니지만 <b>알파벳순으로 분류된 데이터</b>가 있는 상황에서는 더 좋은 방법이 있다.
  - 위와 같은 가장 간단한 방법을 `선형 검색(Linear Search)`라고 한다.

#### Javascript has search!

- There are many different search methods on arrays in JavaScript
  - indexOd, includes, find, findIndex,
- But how do these functions work?
  - 위 메서드들은 우리가 어떤 항목을 입력하더라도 한 번에 하나의 항목을 확인하도록 보이지 않는 곳에서 같은 작업을 수행한다.
  - 즉, 여기서 진행되는 작업은 배열의 처음부터 끝까지 이동하면서 맨 끝에 도달할 떄까지 각 항목에 검색하는 값이 있는지 확인한다.
  - 시간 복잡도 - O(n)

### Linear Search

- Let's search for 12: [5, 8, 1, 100, 12, 3, 12]
  - indexOf 메서드를 사용하면 4, includes를 사용한다면 true를 반환한다.

### Linear Search Pseudocode(선형 검색 의사코드)

- This function accepts an array and a value
  - 여러 개의 숫자가 들어있는 배열을 인수로 사용
- Loop through the array and check if the current array element is equal to the value
  - 전체 배열에 대한 루프를 만들고 현재 확인 중인 배열 항목이 우리가 입력하는 갑소가 동일한지 확인
- If it is, return the index at which the element is found
- If the value is never found, return -1
  - 동일하다면 해당 값의 인덱스를 반환하고, 끝까지 찾을 수 없다면 -1을 반환
- Don't use indexOf to implement this function!

```javascript
// 내 솔루션
function linearSearch(arr, num) {
  let count = 0;
  let result = -1;

  while (count < arr.length) {
    if (arr[count] === num) {
      result = count;
      break;
    }
    count++;
  }

  return result;
}
```

#### 선형 검색 강의 솔루션

```javascript
function linearSearch(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === val) return i;
  }
  return -1;
}
```

### Linear Search BIG O

- Best Case - O(1)
  - 찾고자하는 단어를 바로 찾는 경우
- Average Case - O(n)
  - 4 분의 1 지점, 2 분의 1지점 아니면 바로 1번 인덱스에서 찾는 경우도 있지만
  - 결국 빅오의 경우, 신경써야할 점은 <b>광범위한 경향</b>이다.
- Worst Case - O(n)
  - 참고자하는 단어를 하나씩 비교해가면서 찾는 경우
  - 항목에 100만 개 있으면 100만 번 검색할 수도 있다.
  - 즉, n이 증가할수록 배열의 길이나 문자열 등 우리가 사용하는 데이터의 길이, 평균 소요 시간도 길어진다.
  - 이 방법은 데이터가 분류되지 않았을 때 사용할 수 있는 가장 좋은 방법이다.

## 이진 검색(Binary Search)

### 이진 검색 소개

- 선형 검색보다 크게 개선된 알고리즘이다.

* Binary search is a much faster form of search(이진 검색은 훨씬 더 빠른 검색 작업)
* Rather than eliminating one element at a time, you can eliminate **_half_** of the remaining elements at a time
  - 한 번에 하나의 항목만 제거하는 것 보다는 한 번에 남은 항목의 절반을 제거할 수 있다.
* Binary search only works on `sorted arrays`!
  - 이 때 주의할 점으로 `정렬된 배열`을 대상으로만 작동한다.

### Divide and Conquer

- 기본적인 개념은 분할 정복(dividing and conquering)이다.
- 보통 중간에 있는 중간점을 선택하고, 우리가 찾는 값이 중간점으로 기준으로 좌측 절반과 우측 절반 중 어느 쪽에 있을지를 확인한다.

### Binary Search Pseudocode

- This function accepts a sorted array and a value(정렬된 배열과 값을 아규먼트로 가진다)
- Create a left pointer at the start of the array, and a right pointer at the end of the array.
- While the left pointer comes before the right pointer
  - left pointer가 우측 포인터보다 앞에 있는 동안에만 연산이 계속되게 한다.
- Create a pointer in the middle
  - If you find the value you want, return the index
  - If the value is too small, mover the left pointer up
  - If the value is too larget, mover the right pointer down
- If you never find the value, return -1

```javascript
function binarySearch(arr, value) {
  let left = 0;
  let right = arr.length - 1;
  let middle = Math.floor((left + right) / 2);

  while (left <= right) {
    if (arr[middle] > value) {
      right = middle - 1;
      middle = Math.floor((left + right) / 2);
    } else if (arr[middle] < value) {
      left = middle + 1;
      middle = Math.floor((left + right) / 2);
    } else {
      return middle;
    }
  }

  return -1;
}
```

#### 이진 검색 강의 솔루션

```javascript
function binarySearch(arr, elem) {
  let start = 0;
  let end = arr.length - 1;
  let middle = Math.floor((start + end) / 2);

  while (arr[middle] !== elem && start <= end) {
    if (elem < arr[middle]) end = middle - 1;
    else start = middle + 1;
    middle = Math.floor((start + end) / 2);
  }

  return arr[middle] === elem ? middle : -1;
}

binarySearch([2, 5, 6, 9, 13, 15, 28, 30], 28);
// [2, 5, 6, 9, 13, 15, 28, 30]
//  s        m               e
//               s   m       e
//                      sm   e
//                          sme // 만약 30을 찾는다면
// 만약 10을 찾는다면
// [2, 5, 6, 9, 13, 15, 28, 30]
//  s        m               e
//              s   m        e
//             sme
//              me  s -> while 끝나고 -1 반환
```

- 우리가 하는 작업은 계속 연산을 하면서 중간점을 선택하는 과정을 반복한다.

### What About BIG O?

- Worst and Average Case - O(log n)
- Best Case - O(1)
  - 제일 처음으로 선택한 항목이 우리가 찾는 바로 그 값일 가능성인 경우

## 나이브 문자열 검색(Naive String Search)

- 긴 문자열에서 부분 문자열(substring)을 검색
- Suppose you want to count the number of times a smaller string appears in a longer string
  - 긴 문자열에서 짧은 문자열이 등장하는 횟수를 세려고 상상
- A straightforward approacth involves checking pairs of characters individually
  - 간단한 접근법 중 하나는 문자쌍을 하나씩 확인하는 것

### Naive String Search Pseudocode

- Loop over the longer string(긴 문자열을 반복하는 루프 작성)
- Loop over the shorter string(짧은 문자열을 반복하는 루프 작성)
- If the characters don't match, break out of the inner loop
  - 문자가 일치하지 않으면 내부 루프에서 벗어난다.
- If the characters do match, keep going
- If you complete the inner loop and find a match, increment the count of matches
  - 짧은 문자열의 끝에 도달하면 일치하는 문자열의 count 증가시킨다.
- Return the count

```javascript
// Time Complexity - O(n^2)
function searchNaiveString(str1, str2) {
  let count = 0;

  for (let i = 0; i < str1.length - str2.length + 1; i++) {
    for (let j = 0; j < str2.length; j++) {
      if (str2[j] !== str1[i + j]) break;
      if (j === str2.length - 1) {
        count++;
      }
    }
  }
  return count;
}

// 한 번 재귀로 해보자
function searchNaiveString(str1, str2) {
  let count = 0;

  function helper(str1, str2) {
    if (str2.length > str1.length) return;

    for (let i = 0; i < str2.length; i++) {
      if (str1[i] !== str2[i]) break;

      if (i === str2.length - 1) count++;
    }

    str1 = str1.substring(1);
    return helper(str1, str2);
  }
  helper(str1, str2);

  return count;
}
```

### 나이브 문자열 검색 솔루션

```javascript
function naiveSearch(long, short) {
  let count = 0;

  for (let i = 0; i < long.length; i++) {
    for (let j = 0; j < short.length; j++) {
      if (short[j] !== long[i + j]) break;
      if (j === short.length - 1) count++;
    }
  }

  return count;
}

naiveSearch("lorie loled", "lol");
```

# 10. 버블 정렬

### Objectives

- Implement bubble sort(버블 정렬 구현)
  - 버블 정렬이 어떤 알고리즘인지 배우고, 작동 원리와 구현 방법도 배우기
- Implement selection/insert sort(선택 정렬과 삽입 정렬 구현)
  - 위 3가지를 기본적인 정렬 알고리즘이라고 부른다.
  - 효율성이 떨어지기 때문에 흔히 사용되지 않는건 맞지만, 그렇다고 배우지 말아야 하는 것도 아니다.
- Understand why it is important to learn these simpler sorting algorithms
  - 따라서, 정렬 알고리즘을 배우는 중요한 이유에 대해서도 이해하기
  - 아주 특정한 상황에서 적어도 하나의 알고리즘이 굉장히 잘 작동하기 때문이다.

## 정렬 알고리즘 소개

### What is sorting?

- Sorting is the process of rearranging the items in a collection (e.g. an array) so that the items are in some kind of order.
  - 컬렉션(Collection)의 항목을 재배열하는 과정을 의미한다.
- Examples
  - Sorting numbers from smallest to largest(제일 작은 수에서 큰 수로 정렬)
  - Sorting names alphabetically(이름을 알파벳순으로 정렬)
  - Sorting movies based on release year(개봉 연도 순으로 영화 정렬)
  - Sorting movies based on release revenue(수익 순으로 영화 정렬)

### Why do we need to learn this?

- Sorting is an incredibly common task, so it's good to know how it works.
  - 첫 번째 이유는 정렬이 프로그래밍에서 정말로 흔하게 사용되기 때문에 어떻게 동작하는지 아는 것이 좋다.
  - 자바스크립트에 내장된 정렬 메서드에 사용되는 알고리즘을 이해하는 것이 중요하다.
- There are many different ways to sort things, and different techniques have their own advantages and disadvantages.
  - 데이터를 정렬할 수 있는 방법은 많고 우리가 살펴볼 각 알고리즘에는 장단점이 있다.
  - 몇몇 알고리즘은 일반적으로 나머지보다 빠르기는 하지만, 특정 상황에서는 어떤 알고리즘이 두각을 보인다.
  - [Sorting Algorithms Animations](https://www.toptal.com/developers/sorting-algorithms)에서 속도와 접근법이 어떻게 되는지 비교할 수 있다.

### Telling JavaScript how to sort

- The built-in **_sort_** method accepts an optioncal **_comparator_** function
  - 내장 정렬 메서드는 `선택적 비교함수`를 인자로 전달받는다.
- You can use this comparator function to tell JavaScript how you want it to sort
  - 이 함수를 사용해서 자바스크립트에 우리가 원하는 정렬 방식을 알릴 수 있다.
- The comparator looks at pairs of elements (a and b), determines their sort order based on the return value
  - 기본적으로 이 함수는 A와 B라는 2개의 항목이 있는 구조로 작성하고, 반환되는 값을 토대로 만들 정렬 순서를 자바스크립트에 알린다.
  - If it returns a negative number, a should come before b
    - 만약 음수를 반환하면 자바스크립트는 a가 b 앞에 온다고 결정한다.
  - If it returns a positive number, a should come after b
    - 양수를 반환하면 a가 b 다음에 온다.
  - If it returns 0, a and b are the same as far as the sort is concerned
    - 0을 반환하면 자바스크립트는 a와 b를 동일하게 취급하고 한꺼번에 정렬한다.

```javascript
function numberCompared(num1, num2) {
  return num1 - num2;
}

[6, 4, 15, 10].sort(numberCompare); // [4, 6, 10, 15]
```

## 버블 정렬(BubleSort)

- 별로 효율적이지는 않지만 두각을 나타내는 유스 케이스(use case)가 있다.
- 어떻게 사용하는지 알면 재밌는 알고리즘으로 몇 가지 최적화를 할 수도 있다.
- 다른 알고리즘이 버블 정렬보다 더 나은 이유를 이해하는 데에도 도움이 된다.

### BubbleSort

- A sorting algorithm where the largest values bubble up to the top!
  - 배열을 오름차순으로 정렬을 한다면 더 큰 숫자가 한 번에 하나씩 뒤로 이동을 한다는 것
- 버블정렬을 시각적으로 볼 수 있는 사이트
  - [VISUALGO](https://visualgo.net/en/sorting)
- 버블정렬에서 중요한 부분인 교환은 어떤 원리로 이루어질까?

### Before we sort, we must swap!

- Many sorting algorithms involve some type of swapping functionality (e.g. swapping to numbers to put them in order)
  - 루프를 돌면서 비교를 하고 아래 swap 함수를 호출한다.

```javascript
// ES5
// temp 변수를 설정해서 그 중 하나를 저장하고 두 인덱스를 교환하는 방식
function swap(arr, idx1, idx2) {
  var temp = arr[idx1]; // temp 변수를 설정해서 arr[idx1]을 temp에 저장
  arr[idx1] = arr[idx2]; // arr[idx1]을 arr[idx2] 값으로 업데이트
  arr[idx2] = temp; // 마지막 temp 변수를 사용해서 arr[idx2]를 업데이트
}

// ES2015
// 가독성이 떨어진다.
// arr[idx1]의 값을 arr[idx2]의 값과 교환하고, arr[idx2]의 값을 arr[idx1]의 값과 교환
const swap = (arr, idx1, idx2) => {
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
};
```

### BubbleSort Pseudocode

- Start looping from with a variable called i the end of the array towards the beginning
  - 전부 숫자인 배열을 인자로 받고, i 라는 변수를 가지고 배열의 맨 끝에서 루프를 시작해서 맨 앞에서 끝난다.
  - 정렬을 하고 있는 배열의 항목 수를 줄이는 것과 관련된다.

* Start an inner loop with a variable called j from the beginning until i - 1
  - 외부 루프 안에는 j 라는 변수가 포함된 내부 루프가 있고, 내부 루프는 처음부터 i - 1까지 실행된다.
  - 즉, 첫 번째 루프에 의존하는 중첩 루프라고 생각하면 된다.
* If arr[j] is greater than arr[j+1], swap those two values!
  - arr[j]가 arr[j+1]보다 더 크면 교환을 해야 한다.
* Return the sorted array(정렬된 배열을 반환)

```javascript
function bubbleSort(arr) {
  // start looping from with a variable called i the end of the array towards the beggining
  for (let i = arr.length; i > 0; i--) {
    // start an inner loop with a variable called j from the begging until i - 1
    for (let j = 0; j < i - 1; j++) {
      // if arr[j] is greater than arr[j+1], swap those two values
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }

  return arr;
}

function bubbleSort(arr) {
  const swap = (arr, idx1, idx2) => {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  };

  for (let i = arr.length; i > 0; i--) {
    for (let j = 0; j < i - 1; j++) {
      if (arr[j] > arr[j + 1]) swap(arr, j, j + 1);
    }
  }

  return arr;
}
```

### 버블 정렬 최적화

- 위 코드는 배열이 이미 다 정렬된 상태여도 i가 1번이 될 때까지 루프를 도는 낭비가 발생한다.
- 루프가 마지막으로 실행됐을 때 `교환`을 했는지 확인하여 코드 실행을 줄일 수 있다.
  - noSwaps라는 변수를 만들어 true라면 교환이 이루어지지 않으므로 루프를 빠져나오도록 작성

```javascript
function bubbleSort(arr) {
  // start looping from with a variable called i the end of the array towards the beggining
  let noSwaps;
  for (let i = arr.length; i > 0; i--) {
    // start an inner loop with a variable called j from the begging until i - 1
    noSwaps = true;
    for (let j = 0; j < i - 1; j++) {
      // if arr[j] is greater than arr[j+1], swap those two values
      console.log(arr, arr[j], arr[j + 1]);
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
        noSwaps = false;
      }
    }
    if (noSwaps) break;
  }

  return arr;
}
```

### 버블 정렬 빅오 복잡도

- 중첩 루프가 있으므로 일반적으로 O(n^2)이다.
  - 배열마다 각 항목마다 n번의 비교를 하고, 맨 앞 숫자를 맨 뒤로 보내려면 배열의 다른 모든 항목 하나하나 비교해야 한다.
- 그러나 데이터가 거의 정렬됐거나 이미 정렬이 끝난 상태에서 noSwaps 변수가 있는 신규 버전을 사용할 때는 `선형 시간(linear time)`에 가깝다.
  - 가능한 최고의 경우이고, O(n)이다.

# 11. 선택 정렬

## Selection Sort

- Similar to bubble sort, but instead of first placing large values into sorted position, it places small values into sorted position
  - 큰 값을 배열 끝에 위치시키는 대신 작은 값을 한 번에 하나씩 정렬된 위치에 위치시킨다.
  - 진행하면서 가장 작은 요소, 즉 최솟값을 선택하고 맨 앞으로 배치한다.

### Selection Sort Pseudocode

- Store the first element as the smallest value you've seen so far.
  - 처음에는 최솟값을 저장할 변수를 만들어 첫 번째 항목과 같게 설정한다.
- Compare this item to the next item in the array until you find a smaller number.
  - 더 작은 값이 있는지 찾을 때까지 다음 항목과 비교한다.
- If a smaller number is found, designate that smaller number to be the new "minimum" and continue until the end of the array.
  - 그 다음 항목이 더 작을 경우, 해당 다음 항목을 가장 작은 변수 값으로 갱신한다.
  - 더 작지 않다면 게속 진행한다.
- If the "minimum" is not the value (index) you initially began with, swap the two values.
  - 첫 번쨰 인덱스가 최솟값이 아니라면 두 값을 인덱스로 바꾼다.
- Repeat this with the next element until the array is sorted.
  - 배열이 정렬될 때까지 다음 항목부터 시작하여 다시 새로운 최솟값을 찾도록 반복한다.

```javascript
function selectionSort(arr) {
  // [3, 1, 5, 0, 6]
  for (let i = 0; i < arr.length - 1; i++) {
    let min = arr[i]; // 1
    let idx = i; // 1
    let swaps = false;

    for (let j = i + 1; j < arr.length; j++) {
      // j = 2 ~
      if (arr[i] > arr[j]) {
        min = arr[j];
        idx = j;
        swaps = true;
      }

      if (j === arr.length - 1 && swaps) {
        let temp = arr[i];
        arr[i] = min;
        arr[idx] = temp;
      }
    }
  }

  return arr;
}

function selectionSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let min = i;

    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[min]) min = j;

      if (i !== min && j === arr.length - 1) {
        let temp = arr[i];
        arr[i] = arr[min];
        arr[min] = temp;
      }
    }
  }
  return arr;
}
```

### 선택 정렬 구현

```javascript
function selectionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let lowest = i;

    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[lowest]) lowest = j;
    }
    if (i !== lowest) {
      let temp = arr[i];
      arr[i] = arr[lowest];
      arr[lowest] = temp;
    }
  }

  return arr;
}

// ES2015
function selectionSort(arr) {
  const swap = (arr, idx1, idx2) =>
    ([arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]);

  for (let i = 0; i < arr.length; i++) {
    let lowest = i;

    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[lowest]) lowest = j;
    }
    if (i !== lowest) swap(arr, i, lowest);
  }

  return arr;
}
```

### 선택 정렬 빅오 복잡도

- 선택 정렬은 엄청나게 효율적이지 않다.
- 모든 요소를 배열 속 다른 요소 모두와 비교해야 한다.
  - 따라서 배열 길이가 길어지면 비교 횟수도 n에 n을 곱한 n 제곱 비율로 늘어난다.
- 선택 정렬이 버블 정렬보다 더 나은 시나리오는 딱 하나이다.
  - 어떤 이유나 상황으로 스왑 수를 최소화하는 경우
  - 버블 정렬은 기본적으로 큰 항목을 끝까지 가져갈 수 있도록 계속 바꾸지만
  - 반복하여 많이 비교하지만, 각 루프가 끝날 때 한 번만 바꾼다.
- 따라서 어떤 이유로 메모리에 쓰는 것을 고려하거나, 실제 스왑을 수행하는 것을 고려하는 경우라면
  - 아주 흔한 경우는 아니지만 선택 정렬이 낫다.

# 12. 삽입 정렬

## Insertion Sort

- Builds up the sort by gradually creating a larger left half which is always sorted
  - 삽입 정렬은 배열의 과반을 점차적으로 만들어 정렬을 구축하며, 과반은 항상 정렬되어 있다.
  - 하나씩 이동하거나, 한 번에 가장 큰 요소를 찾거나 한 번에 가장 작은 요소를 찾는 대신
    - 각 요소를 취하여 정렬되어 있는 절반 속 해당되는 위치에 배치한다.
- 따라서 한 번에 하나의 항목을 올바른 위치에 삽입해서 배열의 정렬된 부분을 점진적으로 구축해간다.

### Insertion Sort Pseudocode

- Start by picking the second element in the array
  - 배열의 두 번째 요소부터 시작한다.
  - 맨 처음에는 첫 번째 요소를 정렬된 부분으로 간주하기 때문이다.
- Now compare the second element with the one before it and swap if neccessary.
  - 두 번째 값을 취해서 앞에 있는 값과 비교해서 바꿀 필요가 있다면 바꾼다.
- Continue to the next element and if it is in the incorrect order, iterate through the sorted portion (i.e. the left side) to place the element in the correct place.
  - 그런 다음 옆의 요소로 계속하여 올바른 위치에 있는지 확인한다.
  - 정렬된 부분을 거치며 반복한다.
- Repeat until the array is sorted.
  - 배열을 정렬할 때까지 반복한 다음 정렬을 반환한다.

```javascript
function insertionSort(arr) {
  // 두 번째 요소부터 시작
  for (let i = 1; i < arr.length; i++) {
    // 앞에 있는 요소보다 작으면 swap하고 또 그 앞에 있는 요소와 비교, 아니면 그대로 두고 끝
    for (let j = i - 1; j >= 0; j--) {
      if (arr[j + 1] >= arr[j]) break;
      else {
        let temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
    }
  }

  return arr;
}
```

### 삽입 정렬 구현

```javascript
function insertionSort(arr) {
  for (var i = 1; i < arr.length; i++) {
    var currentVal = arr[i];
    // 0번 인덱스까지 검사하고 비교 과정 중 arr[j]가 currentValue보다 큰 시점에 끝
    // 그럼 arr[j+1]에 currentValue가 위치되어야 한다.
    for (var j = i - 1; j >= 0 && arr[j] > currentVal; j--) {
      arr[j + 1] = arr[j];
    }
    arr[j + 1] = currentVal; // j-- 이후 루프를 빠져나오기 때문에 j + 1을 해줘야 한다.
  }

  return arr;
}

function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let currentVal = arr[i];
    let j = i - 1;
    for (j; j >= 0 && arr[j] > currentVal; j--) {
      arr[j + 1] = arr[j];
    }
    arr[j + 1] = currentVal;
  }

  return arr;
}
```

### 삽입 정렬 빅오 복잡도

- 거의 정렬된 상태에서는 효과가 좋지만 [4, 3, 2, 1] 같은 경우는 최악의 경우다.
- 온라인에서 실시간으로 번호를 제출하는 코드가 있다고 이를 받아서 정렬한다고 가정
  - 삽입 정렬은 한 부분을 정렬된 배열로 유지하고,
  - 한 번씩 항목을 삽입하여 작동하기 때문에 어떤 숫자가 입력되더라도 필요한 위치에 놓을 수 있다.
- 이런 방식으로 작동하는 정렬 알고리즘을 찾는 경우, 정렬된 부분을 유지하면서 들어온 요소를 적절한 위치에 삽입하기 때문에 효율성이 좋다.
  - 라이브, 스트리밍 방식으로 들어온 데이터를 즉시 입력해야 하는 상황에 편리

## 버블, 선택, 삽입 정렬 비교

| Algorithm      | Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| -------------- | --------------------- | ------------------------ | ---------------------- | ---------------- |
| Bubble Sort    | O(n)                  | O(n^2)                   | O(n^2)                 | O(1)             |
| Insertion Sort | O(n)                  | O(n^2)                   | O(n^2)                 | O(1)             |
| Selection Sort | O(n^2)                | O(n^2)                   | O(n^2)                 | O(1)             |

* 기본 정렬 알고리즘의 빅오
  * 가장 좋지 않을 경우를 고려해야하는 것이 빅오의 중점
* 삽입 정렬은 데이터가 들어와서 계속 재정렬하고, 실행 중인 정렬을 유지하여 최신 상태로 두는 경우에 효율성이 좋다.

### Recap
* Sorting is fundamental
  * 정렬을 필수적이다. 프로그래밍의 기본이다.
* Bubble sort, selection sort, and insertion sort are all roughly equivalent
  * 버블 정렬, 선택 정렬, 삽입 정렬 모두 거의 비슷하다.
  * 다음 섹션에서 배울 알고리즘들과 비교할 때 그렇다.
* All have average time complexities that are quadratic
  * 이 정렬 방식 모두 2차인 평균 시간 복잡도를 갖는다.
* We can do better... but we need more complex algorithms!
  * 우리는 더 발전시킬 수 있지만 더 복잡한 알고리즘이 필요하다.