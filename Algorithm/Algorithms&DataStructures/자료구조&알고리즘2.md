# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [06. 재귀(Recursion)](#06-재귀recursion)
  - [재귀 함수를 사용하는 이유](#재귀-함수를-사용하는-이유)
    - [What is recursion](#what-is-recursion)
    - [The reason for using recursion function](#the-reason-for-using-recursion-function)
  - [스택 호출하기](#스택-호출하기)
    - [The Call Stack](#the-call-stack)
    - [Why do I care?](#why-do-i-care)
  - [Base Case](#base-case)
    - [How recursive functions work](#how-recursive-functions-work)
    - [What is Base Case?](#what-is-base-case)
    - [Two essential parts of a recursive function](#two-essential-parts-of-a-recursive-function)
    - [반복문으로 팩토리얼 구현하기](#반복문으로-팩토리얼-구현하기)
    - [재귀 호출로 팩토리얼 구현하기](#재귀-호출로-팩토리얼-구현하기)
  - [통상적인 재귀의 잠재적 위험](#통상적인-재귀의-잠재적-위험)
    - [Where things go wrong](#where-things-go-wrong)
  - [Helper 메서드 재귀](#helper-메서드-재귀)
    - [Helper Method Recursion](#helper-method-recursion)
    - [Example](#example)
  - [순수 재귀](#순수-재귀)
    - [Pure Recursion](#pure-recursion)
    - [Pure Recursion Tips](#pure-recursion-tips)
- [07. 재귀 문제 집합](#07-재귀-문제-집합)
  - [power](#power)
  - [factorial](#factorial)
  - [productOfArray](#productofarray)
  - [recursiveRange](#recursiverange)
  - [fib](#fib)
- [08. 보너스 도전 재귀 문제](#08-보너스-도전-재귀-문제)
  - [reverse](#reverse)
  - [isPalindrome](#ispalindrome)
  - [someRecursive](#somerecursive)
  - [flatten](#flatten)
  - [capitalizeFirst](#capitalizefirst)
  - [nestedEvenSum](#nestedevensum)
  - [capitalizeWords](#capitalizewords)
  - [stringifyNumbers](#stringifynumbers)
  - [collectStrings](#collectstrings)
- [09. 검색 알고리즘](#)

# 06. 재귀(Recursion)

### Obectives

- Define what recursion is and how it can be used
- Understand the two essential components of a recursive function
- Visualize the call stack to better debug and understand recursive functions
- Use helper method recursion and pure recursion to solve more difficult problems
  - 헬퍼 메서드 재귀와 순수 재귀에 대해 알아보고 두 가지를 비교하기

## 재귀 함수를 사용하는 이유

### What is recursion?

- A `process` (a function in our case) that `calls itself`
- 재귀는 자기 자신읗 호출하는 절차라는 의미이다.

### The reason for using recursion function

- It's everywhere!
  - 재귀는 어디서든 사용될 수 있다.
  - JSON.parse / JSON.stringify이 보통 재귀적으로 작성된다.
  - document.getElementById and DOM traversal algorithms(순회 알고리즘)
    - DOM은 모든 요소가 중첩된 트리 구조로 되어 있다.
  - Object traversal(객체 순회)
  - 데이터 구조/트리/그래프를 순회하고, 그 안에 있는 요소를 검색하고자 하는 경우에 자주 사용된다.
  - It's sometimes a cleaner alternative to iteration
    - 반복 대신 재귈르 사용하는 게 더 깔끔할 때가 있다.

## 스택 호출하기

- 재귀 함수가 자기 자신을 계속 호출하고 또 호출한다면, 자바스크립트 엔진에서 무슨 일이 일어날까?
- In almost all program languages, there is a built in data structure that manages what happens when functions are invoked.
  - 거의 모든 프로그래밍 언어에는 보이지 않는 곳에서 함수를 호출을 관리하는 일종의 데이터 구조가 있다.
  - 호출된 함수는 다른 함수가 반환(return)될 때까지 기다리는 경우가 많다.
    - 즉, 함수는 무작위로 실행된 것이 아닌 올바른 순서대로 실행되어야 한다.
  - 자바스크립트의 경우에는 `호출 스택`이 함수 호출을 관리하는 데이터 구조이다.

### The call stack

- It's a `stack` data structure
  - 자바스크립트의 보이지 않는 곳에서 작동하는 스택(`stack`) 데이터 구조이다.
- Any time a function is invoked it is placed (`pushed`) on the top of the call stack.
  - 함수를 호출하면, 호출 스택의 꼭대기에 쌓인다.
- When JavaScript sees the` return` keyword or when the function ends, the compiler will remove(`pop`)
  - 자바스크립트가 반환 키워드(return keyword)를 확인하거나, 함수 안에 더 이상 실행할 코드가 없으면 컴파일러(compiler)가 스택의 제일 위에 있는 항목을 제거할 것이다.

```javascript
function takeShower() {
  return "Showering!";
}

function eatBreakfast() {
  let meal = cookFood();
  return `Eating ${meal}`;
}

function cookFood() {
  let items = ["Oatmeal", "Eggs", "Protein Shake"];
  return items[Math.floor(Math.random() * items.length)]; // 0 ~ 2
}

function wakeUp() {
  takeShower();
  eatBreakfast();
  console.log("Ok ready to go to work!");
}

wakeUp();
```

- wakeUp 함수 호출 -> takeShower 함수 호출 -> "Showering!" 반환 -> eatBreakfast 함수 호출 -> cookFood() 함수 호출 -> 배열 중 엘리먼트 하나 반화 -> "Eating ..." 반환 -> console.log 실행

### Why do I care?

- 재귀 함수릃 작성하게 되면 호출 스택을 엄청나게 많이 사용하게 될 것이다.
- You're used to functions being pushed on the call stack and popped off when they are done.
  - 함수를 호출스택에 추가(push)하고, 완료되면 제거(pop)하는 과정에 익숙해졌다.
- When we write recursive functions, we keep pushing new functions onto the call stack!
  - 하지만, 재귀 함수는 계속해서 새로운(=) 함수를 호출 스택에 추가한다.
  - 그리고 언제 종료되는지를 알아야 한다.

## Base Case

### How recursive functions work

- Invoke the <b>same</b> function with a different input until you reach your base case!
  - 동일한 함수를 계속 호출하면서, 하나의 함수가 자기 자신을 재귀적으로 호출한다.
  - 종료 조건(`base case`)에 도달할 때까지!

### What is Base Case?

- The condition when the recursion ends(재귀가 멈추는 시점)
- This is the most important concept to understand

### Two essential parts of a recursive function

#### 첫 번째 함수

```javascript
function countDown(num) {
  if (num <= 0) {
    console.log("All done!");
    return;
  }
  console.log(num);
  num--;
  countDown(num);
}

countDown(3);

// 순서
// print "3"
// coundDown(2);
// print "2"
// coundDown(1);
// print "1"
// coundDown(0);
// print "All done!"
```

#### 두 번쨰 함수

- 참고해야 할 사항
  - Can you spot the base case?(종료 조건이 보이는지)
  - Do you notice the different input?(다른 입력값이 있는지)
  - What would happen if we didn't return?(return 되지 않는다면 어떤 일이 일어나는지)

```javascript
function sumRange(num) {
  if (num === 1) return 1;
  return num + sumRange(num - 1);
}

sumRange(4); // 10

//  4 + sumRange(3)
//  3 + sumRange(2)
//  2 + sumRanage(1)
// return 1
// return 2 + 1 (3)
// return 3 + 3 (6)
// return 4 + 6 (10)

// 4 + sumRange(3)
//     return 3 + sumRange(2)
//                return 2 + sumRange(1)
//                           return 1;
```

### 반복문으로 팩토리얼 구현하기

- 재귀 함수 사용법을 가장 고전적으로 설명하는 것이 **팩토리얼(factorial)** 이다.

- 아래 함수는 비재귀적 솔루션, 반복 솔루션이다.

```javascript
function factorial(num) {
  let total = 1;
  for (let i = num; i > 0; i--) {
    total *= i;
  }
  return total;
}
```

### 재귀 호출로 팩토리얼 구현하기

```javascript
function factorial(num) {
  if (num === 1) return 1;
  return num * factorial(num - 1);
}
```

## 통상적인 재귀의 잠재적 위험

### Where things go wrong

- No base case(종료 조건이 없거나 잘못되는 경우)
  - 종료 조건이 없으면 스택의 최대 크기 초과되고, `Maximum call stack size exceed`라는 에러 발생한다.
  - 최대 호출 스택 크기 초과를 보통 `스택 오버플로우(stack overflow)`라고 부른다.
- Forgetting to return or returning the wrong thing
  - 잘못된 값을 반환하거나, 애초에 반환하는 것을 잊는 것
  - 위의 return num \* factorial(num)으로 반환해버리면 num은 1에 도달하지 못하므로 위와 같은 에러가 발생한다.

## Helper 메서드 재귀

- 위에서 지금까지 작성했던 모든 재귀함수는 팩토리얼처럼 단일 단독 함수(single standalone function)이다.
  - 함수 외부에서 팩토리얼을 호출하면, 팩토리얼은 직접 자체 코드 내의 팩토리얼을 호출한다.
  - 즉, 스스로를 재귀한다.

### Helper Method Recursion

- 재귀적이지 않은 외부 함수가 호출되면 재귀적인 내부 함수를 호출하는 패턴

```javascript
function outer(input) {
  var outerScopeVariable = [];
  function helper(helperInput) {
    // modify the outerScopedVariable
    helper(helperInput--);
  }
  helper(input);

  return outerScopedVariable;
}
```

- 헬퍼 메서드 재귀에는 두 개의 함수가 있다.
  - 외부 함수(outer function)와 안에 있는 재귀 함수이다.
  - 개발자는 외부 함수를 호출해서 무언가를 내부로 전달할 수 있다.
  - 그리고 외부 함수 안에는 또 다른 함수가 정의되어 있고, 그 함수는 호출이 되어 재귀적으로 자기 자신을 호출한다.
  - 우리가 배열이나 데이터 목록 같은 것을 컴파일(compile)해야 할 때 흔히 위 패턴처럼 작업한다.

### Example

- Let's try to collect all of the odd values in an array

```javascript
function collectOddValues(arr) {
  let result = [];

  function helper(helperInput) {
    if (helperInput.length === 0) return; // helperInput의 엘리먼트 개수가 0되면 종료

    if (helperInput[0] % 2 !== 0) result.push(helperInput[0]);

    return helper(helperInput.slice(1)); // 0번 인덱스 뺸 배열
  }

  helper(arr);

  return result;
}

collectOddValues([1, 2, 3, 4, 5]); // [1, 3, 5]
```

## 순수 재귀

### Pure Recursion

```javascript
function collectOddValues(arr) {
  let newArr = [];

  if (arr.length === 0) return newArr;

  if (arr[0] % 2 !== 0) newArr.push(arr[0]);

  newArr = newArr.concat(collectOddValues(arr.slice(1)));

  return newArr;
}

collectOddValues([1, 2, 3]); // [1, 3]
// newArr
// [1].concat(collectOddValues([2, 3, 4, 5]))
//            [].concat(collectOddValues([3, 4, 5]))
//                      [3].concat(collectOddValues[])
//                                 return []
//                      [3].concat([])
//            [].concat([3])
// [1].concat[3]
// return [1, 3]
```

- 헬퍼 메서드 재귀가 훨씬 직관적인 것 같다.

### Pure Recursion Tips

- For arrays, use methods like `slice`, `the spread operator`, and `concat` that make copies of arrays so you do not mutate themz
  - 배열을 사용하고 헬퍼 메서드 없이 순수 재귀 솔루션을 작성하는 경우에
  - 배열을 복사하는 `splice`, `spread 연산자`, `concat` 같은 메서드를 사용할 수 있다.
  - 그러면 배열읍 변경할 필요가 없이 일종의 결과를 축적할 수 있다.

* Remember that strings are immutable so you will need to use methods like `slice`, `substr`, or `substring` to make copies of strings
  - 문자열은 변경할 수 없다.
  - 그래서 `slice`나 `substring`을 사용해서 사본을 만들어야 한다.
* To make copies of objects use `Object.assign`, or `the spread operator`
  - 객체의 경우, Object.assign이나 `spread 연산자`를 사용하는 것이 유용하다.

## 07. 재귀 문제 집합

### power

Write a function called `power` which accepts a base and an exponent(지수). The function should return the power of the base to the exponent. This function should mimic(흉내내다) the functionality of `Math.pow()` - do not worry about negative bases and exponents

```javascript
// power(2, 0) -> 1
// power(2, 2) -> 4
// power(2, 4) -> 16
function power(base, expo) {
  if (expo === 0) return 1;
  return base * power(base, --expo);
}
```

- 강의 솔루션도 같은 풀이

### factorial

Write a function `factorial` which accepts a number and returns the factorial of that number. A factorial is the product of an integer and all the integers below it; e.g., factorial four(4!) is equal to 24, because 4 _ 3 _ 2 \* 1 equals 24. factorial zero (0!) is always 1.

```javascript
// factorial(1) -> 1
// factorial(2) -> 2
// factorial(4) -> 24
function factorial(num) {
  if (num === 0) return 1;
  return num * factorial(--num);
}
```

#### 강의 솔루션

```javascript
function factorial(x) {
  if (x < 0) return 0;
  if (x <= 1) return 1;
  return x * factorial(x - 1);
}
```

### productOfArray

Write a function called `productOfArray` which takes in an array of numbers and returns the product of them all.

```javascript
// productOfArray([1, 2, 3]) -> 6
// productOfArray([1, 2, 3, 10]) -> 60
function productOfArray(arr) {
  if (arr.length === 0) return 1;
  return arr[0] * productOfArray(arr.slice(1));
}
```

- 강의 솔루션도 같은 풀이

### recursiveRange

Write a function called `recursiveRange` which accepts a number and adds up all the numbers from 0 to the number passed to the function

```javascript
// recursiveRange(6) -> 21
// recursiveRange(10) -> 55
function recursiveRange(num) {
  if (num === 0) return 0;
  return num + recursiveRange(--num);
}
```

- 강의 솔루션도 같은 풀이

### fib

Write a recursive function called `fib` which accepts a number and returns the nth number in the Fibonacci sequence. Recall that the Fibonacci sequence is the sequence of whole numbers 1, 1, 2, 3, 5, 8, ... which starts with 1 and 1, and where every number thereafter is equal to the sum of the previous two numbers.

```javascript
// fib(4) -> 3
// fib(10) -> 55
// fib(28) -> 317811
// fib(35) -> 9227465
function fib(num) {
  // 1 + 1 + 2 + 3 + 5 + 8 + 13 + 21 + 34 + 55
  const arr = [1, 1];
  let result = 0;
  let f1 = 0;
  let f2 = 1;
  if (num <= 2) return 1;

  function helper() {
    if (arr.length === num) {
      result = arr[arr.length - 1];
      return result;
    }

    arr.push(arr[f1] + arr[f2]);
    f1++;
    f2++;
    helper();
  }

  helper();

  return result;
}
```

#### 강의 솔루션

```javascript
function fib(n) {
  if (n <= 2) return 1;
  return fib(n - 1) + fib(n - 2);
}
```

## 08. 보너스 도전 재귀 문제

### reverse

Write a recursive function called `reverse` which accepts a string and returns a new string in reverse.

```javascript
// reverse('awesome') -> 'emosewa'
// reverse('rithmschool') -> 'loohcsmhtir'
function reverse(str) {
  // awesome
  let result = "";

  function helper(str) {
    if (str.length === 0) return;
    result += str[str.length - 1];

    helper(str.slice(0, str.length - 1));
  }

  helper(str);

  return result;
}

function reverse(str) {
  console.log("hi", str);
  let arr = str.split("");
  let result = [];

  if (arr.length === 0) return "";
  result.push(arr[arr.length - 1]);
  result = result.concat(reverse(arr.slice(0, arr.length - 1).join("")));

  return result.join("");
}

function reverse(str) {
  let result = "";

  if (str.length === 0) return "";
  result += str[str.length - 1];
  result = result.concat(reverse(str.slice(0, str.length - 1)));

  return result;
}
```

#### 강의 솔루션

```javascript
function reverse(str) {
  if (str.length <= 1) return str;
  return revers(str.slice(1)) + str[0];
}
```

### isPalindrome

Write a recursive function called `isPalindrome` which returns true if the string passed to it is a palindrome (reads the same forward and backward). Otherwise it returns false.

```javascript
// isPalindrome('awesome') -> false
// isPalindrome('foobar') -> false
// isPalindrome('tacocat') -> true
// isPalindrome('amanaplanacanalpanama') -> true
function isPalindrome(str) {
  if (str.length <= 1) return true;

  let start = 0;
  let end = str.length - 1;

  if (str[start] !== str[end]) return false;

  str = str.substring(1, str.length - 1);

  return isPalindrome(str);
}
```

#### isPalindrome 강의 솔루션

```javascript
function isPalindrome(str) {
  if (str.length === 1) return true;
  if (str.length === 2) return str[0] === str[1];
  if (str[0] === str.slice(-1)) return isPalindrome(str.slice(1, -1));
  return false;
}
```

### someRecursive

Write a recursive function called `someRecursive` which accepts an array and a callback. The function returns true if a single value in the array returns true when passed to the callback. Otherwise it returns false.

```javascript
// const isOdd = val => val % 2 !== 0;
// someRecursive([1,2,3,4], isOdd) // true
// someRecursive([4,6,8,9], isOdd) // true
// someRecursive([4,6,8], isOdd) // false
// someRecursive([4,6,8], val => val > 10); // false

function someRecursive(arr, callback) {
  if (arr.length === 0) return false;
  if (callback(arr[0])) return true;

  return someRecursive(array.slice(1), callback);
}
```

- 강의 솔루션과 같은 풀이

### flatten

Write a recursive function called `flatten` which accepts an array of arrays and returns a new array with all values flattened.

```javascript
// flatten([1, 2, 3, [4, 5]]) // [1, 2, 3, 4, 5]
// flatten([1, [2, [3, 4], [[5]]]]) // [1, 2, 3, 4, 5]
// flatten([[1],[2],[3]]) // [1,2,3]
// flatten([[[[1], [[[2]]], [[[[[[[3]]]]]]]]]]) // [1,2,3]
function flatten(arr) {
  const result = [];

  function helper(arr) {
    if (arr.length === 0) return;

    if (Array.isArray(arr[0])) {
      helper(arr[0]);
      helper(arr.slice(1));
    } else {
      result.push(arr[0]);
      helper(arr.slice(1));
    }
  }
  helper(arr);

  return result;
}
```

#### flatten 강의 솔루션

```javascript
function flatten(arr) {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
```

### capitalizeFirst

Write a recursive function called `capitalizeFirst`. Given an array of strings, capitalize the first letter of each string in the array.

```javascript
// capitalizeFirst(['car','taco','banana']); -> ['Car','Taco','Banana']
function capitalizeFirst(arr) {
  let result = [];

  for (let i = 0; i < arr.length; i++) {
    let value = arr[i];
    arr[i] = value.replace(value[0], value[0].toUpperCase());
  }
  return arr;
}
```

- capitalizeFirst 강의 솔루션 없음

### nestedEvenSum

문제 설명이 안나와 있지만 객체 내 프로퍼티를 돌면서 짝수들만 더하라는 문제인 것 같다.

```javascript
var obj1 = {
  outer: 2,
  obj: {
    inner: 2,
    otherObj: {
      superInner: 2,
      notANumber: true,
      alsoNotANumber: "yup",
    },
  },
};

var obj2 = {
  a: 6,
  b: { b: 2, bb: { b: 3, bb: { b: 2 } } },
  c: { c: { c: 2 }, cc: "ball", ccc: 5 },
  d: 1,
  e: { e: { e: 4 }, ee: "car" },
};

// nestedEvenSum(obj1); -> 6
// nestedEvenSum(obj2); -> 10
function nestedEvenSum(obj) {
  let result = 0;

  function helper(obj) {
    for (let value of Object.values(obj)) {
      if (typeof value === "object") {
        helper(value);
      } else {
        if (value % 2 === 0) result += value;
      }
    }
  }

  helper(obj);

  return result;
}
```

#### nestedEvenSum 솔루션

```javascript
// 파라미터에 sum = 0이 방법도 있었네... 그래도 비슷하게 풀었다
function nestedEvenSum(obj, sum = 0) {
  for (let key in obj) {
    if (typeof obj[key] === "object") {
      sum += nestedEvenSum(obj[key]); // sum += 안하면 재귀 호출할 때 sum이 0이 되버린다.
    } else if (typeof obj[key] === "number" && obj[key] % 2 === 0) {
      sum += obj[key];
    }
  }

  return sum;
}
```

### capitalizeWords

Write a recursive function called `capitalizeWords`. Given an array of words, return a new array containing each word capitalized.

```javascript
// capitalizeFirst(['car','taco','banana']); -> ['CAR','TACO','BANANA']
function capitalizeWords(arr) {
  if (arr.length === 1) return [arr[0].toUpperCase()];

  let res = capitalizeWords(arr.slice(0, -1));
  res.push(arr.slice(-1)[0].toUpperCase());

  return res;
}
```

#### capitalizeWords 솔루션

```javascript
// 답이 안나오는데....
function capitalizeWords(array) {
  if (array.length === 1) {
    return [array[0].toUpperCase()];
  }
  let res = capitalizeWords(array.slice(0, -1));
  res.push(array.slice(array.length - 1)[0].toUpperCase());
  return res;
}
```

### stringifyNumbers

Write a function called `stringifyNumbers` which takes in an object and finds all of the values which are numbers and converts them to strings. Recursion would be a great way to solve this!

```javascript
/*
let obj = {
    num: 1,
    test: [],
    data: {
        val: 4,
        info: {
            isRight: true,
            random: 66
        }
    }
}
/*

stringifyNumbers(obj)

/*
{
    num: "1",
    test: [],
    data: {
        val: "4",
        info: {
            isRight: true,
            random: "66"
        }
    }
}
*/
function stringifyNumbers(obj) {
  let newObj = {};

  for (let [key, value] of Object.entries(obj)) {
    if (typeof value === "object" && !Array.isArray(obj[key])) {
      newObj[key] = stringifyNumbers(value);
    } else if (typeof value === "number") {
      newObj[key] = value.toString();
    } else {
      newObj[key] = value;
    }
  }

  return newObj;
}
```

#### stringifyNumbers 솔루션

```javascript
function stringifyNumbers(obj) {
  var newObj = {};
  for (var key in obj) {
    if (typeof obj[key] === "number") {
      newObj[key] = obj[key].toString();
    } else if (typeof obj[key] === "object" && !Array.isArray(obj[key])) {
      newObj[key] = stringifyNumbers(obj[key]);
    } else {
      newObj[key] = obj[key];
    }
  }

  return newObj;
}
```

### collectStrings

Write a function called `collectStrings` which accepts an object and returns an array of all the values in the object that have a typeof string.

```javascript
const obj = {
  stuff: "foo",
  data: {
    val: {
      thing: {
        info: "bar",
        moreInfo: {
          evenMoreInfo: {
            weMadeIt: "baz",
          },
        },
      },
    },
  },
};

// collectStrings(obj) -> ["foo", "bar", "baz"])

function collectStrings(obj) {
  let arr = [];

  for (let value of Object.values(obj)) {
    if (typeof value === "string") {
      arr.push(value);
    } else if (typeof value === "object" && !Array.isArray(value)) {
      arr = arr.concat(collectStrings(value));
    }
  }

  return arr;
}
```

### collectString 솔루션

```javascript
// Helper 메서드 재귀 버전
function collectStrings(obj) {
  let stringArr = [];

  function gatherStrings(o) {
    for (let key in o) {
      if (typeof o[key] === "string") stringArr.push(o[key]);
      else if (typeof o[key] === "object") return gatherStrings(o[key]);
    }
  }

  gatherStrings(obj);

  return stringArr;
}

// 순수 재귀 버전
function collectStrings(obj) {
  var stringsArr = [];
  for (var key in obj) {
    if (typeof obj[key] === "string") {
      stringsArr.push(obj[key]);
    } else if (typeof obj[key] === "object") {
      stringsArr = stringsArr.concat(collectStrings(obj[key]));
    }
  }

  return stringsArr;
}
```

# 09. 검색 알고리즘

### Objectives

- Describe what a searching algorithm is(검색 알고리즘이 무엇인지 설명)
- Implement linear search on arrays(배열에 선형 검색 구현)
- Implement binary search on sorted arrays(정렬된 배열에서의 이진 검색 구현)
- Implment a naive string searching algorithm(naive 문자열 검색 알고리즘 구현)
- Implement the KMP string searching algorithm(KMP 문자열 검색 알고리즘 구현)

## 선형 검색(Linear Search)

### How do we search?
