# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [13. 합병 정렬](#13-합병-정렬)
  - [Intermediate Sorting Algorithms](#intermediate-sorting-algorithms)
    - [Objectives](#Objectives)
    - [Why learn this?](#why-learn-this)
    - [Faster Sorts](#faster-sorts)
  - [Merge Sort 소개](#merge-sort-소개)
    - [Merge Sort](#merge-sort)
    - [How does it work?](#how-does-it-work)
    - [배열 합병(Merging Arrays)](#배열-합병merging-arrays)
    - [Merging Arrays](#merging-arrays)
    - [Merging Arrays Pseudocode](#mergesort-pseudocode)
    - [Big O of mergeSort](#big-o-of-mergesort)
- [14. 퀵 정렬](#14-퀵-정렬)

# 13. 합병 정렬

## Intermediate Sorting Algorithms

- 작동 방식에 집중하며, 코드의 각 행이 수행하는 작업을 다시 설명할 수 있는 능력에 집중해야 한다.
  - 처음부터 전부 만들어 내는 데는 집중하지 않아도 괜찮다.
- 위 기본 정렬 알고리즘 보다 빠르지만 직접 작성하기에는 직접적이지 않을 수 있다.
  - 이는 까다롭고, 연구자들이 오랫동안 시도하고 시험하여 만든 알고리즘이기 때문에 바로 이해하기 어려울 수 있다.

### Objectives

- Understand the limitations of the sorting algorithms we've learned so far
  - 지금까지 배운 알고리즘(버블/선택/삽입 정렬)의 한계를 이해한다.
- Implement merge/quick/radix sort
  - 합병 정렬, 퀵 정렬, 지수 정렬을 구현한다.

### Why learn this?

- The sorting algoriths we've learned so far don't scale well
  - 지금까지 배운 정렬 알고리즘은 큰 규모에 맞지 않는다.
  - 20개짜리 항목 배열과 같은 작은 규모에서는 꽤 잘 작동하지만 10만 개의 요소로 작업할 경우라면 잘 적용되지 않는다.
- Try out bubble sort on an array of 100000 elements, it will take quite some time!

  - 버블 정렬을 실제로 시도한다면, 규모를 줄여 10만개 요소로 작업할 경우라도 시간이 꽤 걸린다.

  ```javascript
  function bubbleSort(arr) {
    let noSwaps;
    for (let i = arr.length; i > 0; i--) {
      noSwaps = true;
      for (let j = 0; j < i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          let temp = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = temp;
          noSwaps = false;
        }
      }
      if (noSwaps) break;
    }

    return arr;
  }
  const data = Array.apply(null, { length: 100000 }).map(
    Function.call,
    Math.random
  );
  ```

### Faster Sorts

- There is a family of sorting algorithms that can improve time complexity from O(n^2) to O(n log n)
  - 앞으로 배울 빠른 알고리즘 집합은 시간 복잡도를 O(n^2)에서 O(n log n)으로 향상시킬 수 있다.
  - O(log n)과 O(n)만큼 좋지는 않지만 그래도 꽤 괜찮은 편이다.
  - 따라서 앞으로 시간 복잡도를 개선하는 세 가지 알고리즘을 배울 예정!
- There's a tradeoff between efficiency and simplicity
  - 효율성과 단순성은 안타깝게도 상충된다.
- The more efficient algoriths are much less simple, and generally take longer to understand
  - 그래서 효율적인 알고리즘은 활실히 더 어렵고, 더 길며, 코드가 길지 않더라도 이해하기 더 오래 걸린다.
  - 보통 사람들이 생각하는 방식과는 다르다.
  - 그래서 이해하는데 시간이 좀 더 걸리지만, 그럴만한 가치가 있다.

## Merge Sort 소개

### Merge Sort

- It's a combination of two things - merging and sorting!
  - 합병과 정렬의 조합이다.
  - 분한, 정렬, 합병이 일어나기 때문에 세 가지 조합이라고 볼 수도 있다.
- Exploits the fact that arrays of 0 or 1 element are always sorted
  - 0개, 1개 요소 배열이 이미 정렬되어 있다는 점을 활용한다.
- Works by decomposing an array into smaller arrays of 0 or 1 elements, then building up a newly sorted array
  - 배열을 더 작은 배열로 나누는 방식이다. 더 큰 배열을 나누고 0이나 1 요소 배열이 될 때까지 더 작은 하위 배열로 정렬한다.
  - 따라서 8개 요소 배열을 가져오면 8개의 단일 요소 배열이 될 때까지 분할하고 다시 병합시킨다.

### How does it work?

```
[8, 3, 5, 4, 7, 6, 1, 2] -> split
[8, 3, 5, 4] [7, 6, 1, 2] -> 아직 1개나 0개 요소 배열이 아님 -> split
[8, 3] [5, 4] [7, 6] [1, 2]
[8] [3] [5] [4] [7] [6] [1] [2]
[3, 8] [4, 5] [6, 7] [1, 2] -> 합병시키면서 정렬
[3, 4, 5, 8] [1, 2, 6, 7]
[1, 2, 3, 4, 5, 6, 6, 8]
```

- 정렬된 배열 두 개를 합치는 것은 정렬되지 않은 배열을 합치는 것보다 쉽다.
  - 따라서 기본적으로 어느 숫자가 더 작은지 비교해서 작은 것이 먼저 오도록 해야 한다.
  - 정렬된 배열 두 개를 합병시키는 방법을 이해한다면 나머지는 이해하기 쉽다.
- 시각적으로 어떻게 동작하는지 확인하기
  - [VISUALGO](https://visualgo.net/en/sorting)

### 배열 합병(Merging Arrays)

- 배열이 정렬되어 있다고 가정하고 정렬된 배열 두 개의 조합을 반환하기만 하면 된다.

```
merge([1, 10, 50], [2, 14, 99, 100])
return [1, 2, 10, 14, 50, 99, 100]
```

- In order to implement merge sort, it's useful to first implement a function responsible for merging two sorted arrays.
  - 정렬된 두 배열 합병을 담당할 함수를 먼저 구현하는 것이 좋다
- Given two arrays which are sorted, this helper function should create a new array which is also sorted, and consists of all of the elements in the two input arrays
  - 정렬된 두 배열이 주어지면 이 헬퍼 함수는 마찬가지로 정렬된 새 배열을 만든다.
  - 입력 배열 두 개에 있는 모든 요소를 포함하는 것이 중요하다.
  - 크기가 다를 때는 어떻게 해야 할까?
- This function should run in O(n + m) time and O(n + m) space and should not modify the parameters passed to it.
  - 실제 합병 정렬에서 합치는 두 배열이 주로 크기가 똑같거나 요소 하나 차이가 난다.
  - 하지만 어떠한 이유로 요소 천 개가 있는 배열을 백 만개 요소의 배열과 합병할 경우가 있다면 O(n + m)이 된다.

### Merging Arrays Pseudocode

- Create an empty array, take a look at the smallest values in each input array
  - 입력 두 개를 취하는 함수를 정의하여 마지막에 반환할 빈 배열을 만든다.
  - 각 입력 배열에서 가장 작은 값부터 시작한다.
- While there are still values we haven't looked at ...
  - If the value in the first array is smaller than the value in the second array, push te value in the first array into our results and move on to the next value in the first array
  - If the value in the first array is larget than the value in the second array, push the value in the second array into our results and move on to the next value in the second array
  - Once we exhaust on array, push in all remaining v alues from the other array
    - 배열 하나를 완료되면 다른 배열의 남은 값을 모두 넣는다.

```javascript
function mergeArrays(arr1, arr2) {
  let result = [];
  let i = 0;
  let j = 0;

  // result에 arr1, arr2 요소 합친 개수만큼 있으면 종료
  while (result.length < arr1.length + arr2.length) {
    if (arr1[i] <= arr2[j]) {
      // arr1[i]가 arr2[j]보다 작거나 같으면 arr1[i] 요소 삽입
      result.push(arr1[i]);
      i++;
      if (arr1.length === i) result = result.concat(arr2.slice(j));
    } else {
      result.push(arr2[j]);
      j++;
      if (arr2.length === j) result = result.concat(arr1.slice(i));
    }
  }

  return result;
}
```

- concat과 slice를 사용했는데 좋은 코드인지 잘 모르겠다..

### 배열 합병 구현

```javascript
function merge(arr1, arr2) {
  let results = [];
  let i = 0;
  let j = 0;
  // 두 배열 중 하나라도 끝 인덱스에 다른 작업을 해야 한다.(남은 배열의 요소들을 삽입하는 작업)
  while (i < arr1.length && j < arr2.length) {
    if (arr2[j] > arr1[i]) {
      results.push(arr1[i]);
      i++;
    } else {
      results.push(arr2[j]);
      j++;
    }
  }

  while (i < arr1.length) {
    results.push(arr1[i]);
    i++;
  }

  while (j < arr2.length) {
    results.push(arr2[j]);
    j++;
  }

  return results;
}
```

### mergeSort Pseudocode

- 대부분의 합병 절렬 구현 시 `재귀(Recursion)`을 사용한다.

- Break up the array into halves until you have arrays that are empty or have one element.
  - 요소를 하나 갖거나 빈 배열을 가질 때까지 배열을 반쪽들로 나눈다.
  - 하나의 배열을 반으로 나누려면 어떻게 해야 할까? -> Array.prototype.slice() 추천
  - 다 나눠진 배열들로 무엇을 할까?
- Once you have smaller sorted arrays, merge those arrays with other sorted arrays until you are back at the full length of the array.
  - 이렇게 작은 배열이 준비되면 작성해 놓았던 합병 함수를 사용해 전체 배열 길이로 돌아갈 때까지 다시 합친다.
- Once the array has been merged back togerther, return the merged (and sorted!) array
  - 배열을 다시 합쳤으면 가장 마지막에 합병된 배열을 반환한다.

```javascript
function merge(arr1, arr2) {
  let results = [];
  let i = 0;
  let j = 0;
  // 두 배열 중 하나라도 끝 인덱스에 다른 작업을 해야 한다.(남은 배열의 요소들을 삽입하는 작업)
  while (i < arr1.length && j < arr2.length) {
    if (arr2[j] > arr1[i]) {
      results.push(arr1[i]);
      i++;
    } else {
      results.push(arr2[j]);
      j++;
    }
  }

  while (i < arr1.length) {
    results.push(arr1[i]);
    i++;
  }

  while (j < arr2.length) {
    results.push(arr2[j]);
    j++;
  }

  return results;
}

function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  let mid = Math.floor(arr.length / 2);
  let left = mergeSort(arr.slice(0, mid));
  let right = mergeSort(arr.slice(mid));
  console.log(left, right);

  return merge(left, right);
}

mergeSort([10, 24, 76, 73, 72, 1, 9]);
// 계속 분할...
// [24] [76] - 3단계  <- 2단계 left에 [10]이 할당되고 right으로 가서 3단계로 내려감
// [10] [24, 76] - 2단계 -> [10, 24, 76] 1단계 left에 할당
// [73] [72] - 3단계
// [1] [9] - 3단계
// [72, 73] [1, 9] - 2단계 -> [1, 9, 72, 73] 1단계 right에 할당
// [10, 24, 76] [1, 9, 72, 73] -> 1단계 -> 마지막 merge(left, right)를 호출해서 반환
// [1, 9, 10, 24, 72, ,73, 76] 반환
```

### Big O of mergeSort

| Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| --------------------- | ------------------------ | ---------------------- | ---------------- |
| O(n log n)            | O(n log n)               | O(n log n)             | O(n)             |

- 입력값이 무엇이든 이미 정렬되어 있든, 거꾸로 되어 있든, 모두 무작위든 상관없이 계속 나누고 나눈 다음에 합치고 또 합친다.

#### n log n인 이유과 도출된 방법

```
// O(log n) decompositions * O(n) comparisons per decomposition
[8] [3] [5] [4] [7] [6] [1] [2]
[3, 8] [4, 5] [6, 7] [1, 2]
[3, 4, 5, 8] [1, 2, 6, 7]
[1, 2, 3, 4, 5, 6, 7, 8]
```

- 요소 여덟 개가 있는 배열로 시작한다면, 합병 과정을 거친 마지막에 다음과 같이 보인다.
- 배열에 항목 여덟 개가 있다면, 단일 요소 배열이 되려면 몇 번을 나누어야 할까?
  - 이 경우에는 세 번이다.
- 만약 32개의 요소가 있는 배열이 있다면
  - 나누어 16개 요소 2개(1) -> 8개 항목 4개(2) -> 4개 항목 8개(3) -> 2개 항목 16개(4) -> 1개 항목 32개(5)
  - 총 5번 나누어 진다.
- 위 나누어지는 과정을 빅오로 보면 log n이다.
- 그럼 n log n은 무엇일까? 어디서 나타난 것일까?
  - 각 분할마다, 합병할 때 O(n) 비교를 통해 합병한다.
  - n의 길이가 늘어난다면, 합병 정렬이 아닌 합병 알고리즘 자체는 O(n)의 시간 복잡도를 갖게 된다.
- 즉 분할은 O(log n)의 시간 복잡도를 가지는 반면, 분할마다 합병 자체는 O(n)의 시간 복잡도를 가진다.

# 14. 퀵 정렬

- Like merge sort, exploits the fact that arrays of 0 or 1 element are always sorted
  - 합병 정렬 같은 경우, 0개, 1개 요소 가진 배열은 항상 정렬되어 있다는 사실을 이용한다.
- Works by selecting one element (called the "pivot") and finding the index where the pivot should end up in the sorted array
  - 피벗 포인트라 부르는 단일 요소를 선택하여 수행한다.(\* 어떤 배열에서 어떤 요소를 선택하든 문제가 되지 않음)
  - 피벗이 정렬된 배열에서 끝나야 하는 인덱스를 찾는다.
  - 예를 들어, 중앙에 있는 요소를 선택했을 경우, 할 일은 해당 요소의 숫자보다 작은 숫자를 왼쪽으로 정렬이 아닌 옮기는 것이다. 그리고 그 숫자보다 큰 숫자를 오른쪽으로 정렬이 아닌 옮긴다.
  - 이 때, 그 숫자 하나는 올바른 위치이다. 그 숫자 하나만! 다른 숫자들이 오른쪽이나 왼쪽에 있지만 정렬되어 있는지는 모른다.
- Once the pivot is positioned approprivately, quick sort can be applied on either side of the pivot.
  - 그러면 이 과정을 왼쪽과 오른쪽에 반복한다.

### How does it work?

```
[5, 2, 1, 8, 4, 7, 6, 3] -> 1번 인덱스 5를 기준으로 작은 수는 왼쪽, 큰 수는 오른쪽
[3, 2, 1, 4, "5", 7, 6, 8] -> 5만 적절한 위치(4번 인덱스)에 있다. 이 과정을 왼쪽과 오른쪽에서 재귀적으로 반복
[1, 2, "3", 4, "5", 7, 6, 8] -> 3을 기준으로 적절한 위치에 두고 왼쪽은 요소가 2개 이상이므로 재귀 실행
["1", 2, "3", 4, "5", 7, 6, 8] -> 이제 5 기준 오른쪽에서 7을 기준으로 정렬
["1", 2, "3", 4, "5", 6, "7", 8] -> 요소가 하나 남은 것들은 재귀호출하지 않아도 되므로 정렬 완료.
           5 -> 1번
     3           7   -> 2번
1      4     6     8 -> 3번(왼쪽에서만)
   2
```

### Pivot Helper

- In order to implement merge sort, it's useful to first implement a function responsible arranging elements in an array on either side of a pivot
- Given an array, this helper function should designate an element as the pivot
- It should then reaarange elements in the array so that all values less than the pivot are moved to the left of the pivot, and all values greater than the pivot are moved to the right of the pivot
  - 배열이 주어지면 요소를 피벗 포인트로 지정하여 배열 속 요소를 재배치하는 함수를 작성한다.
- The order of elements on either side of the pivot doesn't matter!
  - 말 그대로 양쪽의 순서는 중요하지 않다.
- The helper should do this <b>in place</b>, that is, it should not create a new array
  - 새 배열을 만들면 안 되고, 피벗 인덱스를 반환해야 한다.
- When complete, the helper should return the index of the pivot
  - helper 함수는 제 자리에서 모두 수행하므로 새 배열을 만들지 않는다.

### Picking a pivot

- The runtime of quick sort depends in part on how one selects the pivot
  - 퀵 정렬의 실행 시간은 피벗 선택 위치에 따라 달라질 수 있다.
- Ideally, the pivot should be chosen so that it's roughly the median value in the data set you're sorting
  - 이상적으로는 데이터 집합의 중간값이 되도록 선택해야 한다.
  - 가능하다면 완벽하게 선택할 수 있는 경우, 데이터 정령의 중간값을 선택해서 왼쪽과 오른쪽이 같도록 하는 것이 좋지만
  - 데이터가 무엇인지, 순서가 어떻게 되어 있는지 모른다면 쉽지 않다. 그래서 다른 전략 선택.
- For simplicity, we'll always choose the pivot to be the first element (we'll talk about consequences of this later)
  - 편의상 항상 첫 번째 요소를 피벗으로 선택할 것이다.
  - 그렇게 하면 나중에 얘기할 빅오에 어떤 영향을 미친다.

#### Pivot Helper Example

```js
let arr = [5, 2, 1, 8, 4, 7, 6, 3];

pivot(arr); // 4;

arr;

// any one of these is an acceptable mutation:
// [2, 1, 4, 3, 5, 8, 7, 6]
// [1, 4, 3, 2, 5, 7, 6, 8]
// [3, 2, 1, 4, 5, 7, 6, 8]
// [4, 1, 2, 3, 5, 6, 8, 7]
// there are other acceptable mutations too!
```

### Pivot Pseudocode

- It will help to accept three arguments: an array, a start index, and an end index (these can default to 0 and the array length minus 1, respectively)
  - 피벗 또는 파티션이라 불리는 함수를 작성한다.
  - 이 함수는 배열, 시작인덱스(start index), 끝인덱스(end index)라는 세 개의 인수를 받는다.
  - 그리고 기본값으로 시작인덱스는 0, 끝인덱스는 배열 길이 - 1 이다.
- Grab the pivot from the start of the array
  - 다음 배열 시작 부분에서 피벗을 선택한다.(평의상임. 다른 피벗을 기준을 선택해도 됨)
- Store the current pivot index in a variable (this will keep track of where the pivot should end up)
  - 그런 다음 현재의 피벗 인덱스를 변수로 저장한다.
  - 이렇게 하여 마지막에 피벗을 바꿀 위치를 계속 확인한다.
- Loop through the array from the start until the end
  - 시작부터 끝까지 배열에 루프를 수행한다.
  - If the pivot is greater than the current element, increment the pivot index variable and then swap the current element with the element at the pivot index
    - 살펴보는 요소보다 피벗이 클 경우 피벗 인덱스 변수를 증가시킨 다음 현재 요소를 피벗 인덱스의 요소와 바꾼다.
- Swap the starting element (i.e. the pivot) with the pivot index
- Return the pivot index
  - 그리고 맨 마지막에는 시작했던 피벗과 피벗 인덱스를 바꾼 다음 피벗 인덱스를 반환한다.

### 피벗 helper 함수 구형

```js
function pivot(arr, start = 0, end = arr.lnegth - 1) {
  // ES5 버전의 스왑 함수
  // const swap = (arr, idx1, idx2) => {
  //   [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  // }

  function swap(arr, i, j) {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  let pivot = arr[start];
  let swapIdx = start; // 스왑 인덱스는 피벗이 맨 마지막에 어디로 옮길지 추적

  // 첫 번째 항목 뺴고 루프 수행
  for (let i = start + 1; i < arr.length; i++) {
    // 피벗 비교 (피벗이 해당 요소보다 클 경우 스왑!)
    if (pivot > arr[i]) {
      swapIdx++;
      swap(arr, swapIdx, i);
    }
  }
  swap(arr, start, swapIdx);

  return swapIdx;
}
// pivot([4, 8, 2, 1, 5, 7, 6, 3])
// 첫 번째 엘리먼트를 피벗으로 취하기 때문에 위치할 인덱스 3을 반환해야 한다.
// [4, 8, 2, 1, 5, 7, 6, 3] 첫 번쨰 루프
// [4, 2, 8, 1, 5, 7, 6, 3] 두 번쨰 루프, swapIdx = 1
// [4, 2, 1, 8, 5, 7, 6, 3] 세 번쨰 루프, swapIdx = 2
// [4, 2, 1, 3, 5, 7, 6, 8] 마지막 루프, swapIdx = 3
// 루프 끝나고 arr[swapIdx]와 arr[start] 스왑!
// [3, 2, 1, 4, 5, 7, 6, 8], swapIdx = 3
```

### Quicksort Pseudocode

- Call the pivot helper on the array
  - 전체 배열의 가장 앞에서 피벗 헬퍼를 호출한다.(인덱스를 반환하는 것이 중요)
  - 그리고 해당 피벗 포인트의 왼쪽과 오른쪽에서 다시 퀵 정렬을 호출
- When the helper returns to you the updated pivot index, recursively call the pivot helper on the subarray to the left of that index, and the subarray to the right of that index
  - 업데이트된 피벗 인덱스를 헬퍼가 반환하면 피벗 헬퍼를 재귀적으로 왼쪽과 오른쪽에 호출한다.
  - <b>중요한 점은 새로운 배열을 만들지 않는 것!</b> -> 모두 제자리(같은 배열)에서 일어난다.
  - 따라서 `base case`는 단순히 배열의 길이나 배열에 하나의 항목이 있는지 확인하는 것이 아니라 하위 배열에 항목 하나가 있는지 확인도록 작성해야 한다.
- Your base case occurs when you consider a subarray with less than 2 elements
  - 즉, 하위배열에 2개 미만의 요소가 있을 때 수행된다.

```js
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 하위 배열이 하나의 요소 길이에 도달했을 때를 base case로 둬야하는데
  // 이 때, 왼쪽과 오른쪽이 같다면 한 요소를 살펴보고 있다는 것이므로 left가 right보다 작을 때만 실행하도록 설정
  console.log(left, right);
  if (left < right) {
    // 가장 처음 진행할 때 전체 배열을 호출한 다음,
    // quickSort 재귀함수가 결국 이곳의 하위 배열을 다시 시작하기 때문에 하위 배열은 시작포인트, 끝포인트가 다른다.
    let pivotIndex = pivot(arr, left, right); // 피벗 인덱스, 배열에서 피벗을 호출하는 것과 같음
    // left
    console.log('pivot', pivotIndex);
    quickSort(arr, left, pivotIndex - 1);
    // right
    quickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

quickSort([4, 8, 2, 1, 5, 7, 6, 3]);
// [4, 8, 2, 1, 5, 7, 6, 3]
// [3, 2, 1, 4, 6, 9, 5]
//           4
//  3, 2, 1     6, 9, 5
//        3        6
//  2, 1        5     9
//     2
//  1
```

### 퀵 정렬 스택 호출 소개
```js
quickSort([4, 6, 9, 1, 2, 5]);

// 실행 순서
// quickSort([4, 6, 9, 1, 2, 5], 0, 5)
// pivot([4, 6, 9, 1, 2, 5], 0, 5) -> return 2(pivotIndex)
// 왼쪽부터 시작
// quickSort([2, 1, 4, 6, 9, 5], 0, 1)
// pivot([2, 1, 4, 6, 9, 5], 0, 1) -> return 1(pivotIndex)
// quickSort([1, 2, 4, 6, 9, 5], 0, 0) -> return 지금 arr
// quickSort([1, 2, 4, 6, 9, 5], 1, 1) -> return 지금 arr
// 이제부터 오른쪽
// quickSort([1, 2, 4, 6, 9, 5], 3, 5)
// pivot([1, 2, 4, 5, 6, 9], 3, 5) -> return 4(pivotIndex)
// quickSort([1, 2, 4, 5, 6, 9], 3, 3) -> return 지금 arr
// quickSort([1, 2, 4, 5, 6, 9], 5, 5) -> return 지금 arr
// 마지막 제일 위에 있는 quickSort 함수 호출에 대해서 return arr;

// pivot 빼고 Call Stack 형태

// quickSort([1, 2, 4, 6, 9, 5], 2, 1) -> return(2)
// quickSort([1, 2, 4, 6, 9, 5], 0, 0) -> return(1)
// quickSort([2, 1, 4, 6, 9, 5], 0, 1) -> return(3)
// quickSort([4, 6, 9, 1, 2, 5], 0, 5)

// quickSort([1, 2, 4, 5, 6, 9], 5, 5) -> return(2)
// quickSort([1, 2, 4, 5, 6, 9], 3, 3) -> return(1)
// quickSort([1, 2, 4, 5, 6, 9], 3, 3) -> return(3)
// quickSort([2, 1, 4, 6, 9, 5], 3, 5) -> return(4)
```

### Big O of Quicksort
