# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [13. 합병 정렬](#13-합병-정렬)

# 13. 합병 정렬

## Intermediate Sorting Algorithms

- 작동 방식에 집중하며, 코드의 각 행이 수행하는 작업을 다시 설명할 수 있는 능력에 집중해야 한다.
  - 처음부터 전부 만들어 내는 데는 집중하지 않아도 괜찮다.
- 위 기본 정렬 알고리즘 보다 빠르지만 직접 작성하기에는 직접적이지 않을 수 있다.
  - 이는 까다롭고, 연구자들이 오랫동안 시도하고 시험하여 만든 알고리즘이기 때문에 바로 이해하기 어려울 수 있다.

### Objectives

- Understand the limitations of the sorting algorithms we've learned so far
  - 지금까지 배운 알고리즘(버블/선택/삽입 정렬)의 한계를 이해한다.
- Implement merge/quick/radix sort
  - 합병 정렬, 퀵 정렬, 지수 정렬을 구현한다.

### Why learn this?

- The sorting algoriths we've learned so far don't scale well
  - 지금까지 배운 정렬 알고리즘은 큰 규모에 맞지 않는다.
  - 20개짜리 항목 배열과 같은 작은 규모에서는 꽤 잘 작동하지만 10만 개의 요소로 작업할 경우라면 잘 적용되지 않는다.
- Try out bubble sort on an array of 100000 elements, it will take quite some time!

  - 버블 정렬을 실제로 시도한다면, 규모를 줄여 10만개 요소로 작업할 경우라도 시간이 꽤 걸린다.

  ```javascript
  function bubbleSort(arr) {
    let noSwaps;
    for (let i = arr.length; i > 0; i--) {
      noSwaps = true;
      for (let j = 0; j < i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          let temp = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = temp;
          noSwaps = false;
        }
      }
      if (noSwaps) break;
    }

    return arr;
  }
  const data = Array.apply(null, { length: 100000 }).map(
    Function.call,
    Math.random
  );
  ```

### Faster Sorts

- There is a family of sorting algorithms that can improve time complexity from O(n^2) to O(n log n)
  - 앞으로 배울 빠른 알고리즘 집합은 시간 복잡도를 O(n^2)에서 O(n log n)으로 향상시킬 수 있다.
  - O(log n)과 O(n)만큼 좋지는 않지만 그래도 꽤 괜찮은 편이다.
  - 따라서 앞으로 시간 복잡도를 개선하는 세 가지 알고리즘을 배울 예정!
- There's a tradeoff between efficiency and simplicity
  - 효율성과 단순성은 안타깝게도 상충된다.
- The more efficient algoriths are much less simple, and generally take longer to understand
  - 그래서 효율적인 알고리즘은 활실히 더 어렵고, 더 길며, 코드가 길지 않더라도 이해하기 더 오래 걸린다.
  - 보통 사람들이 생각하는 방식과는 다르다.
  - 그래서 이해하는데 시간이 좀 더 걸리지만, 그럴만한 가치가 있다.

## Merge Sort 소개

### Merge Sort

- It's a combination of two things - merging and sorting!
  - 합병과 정렬의 조합이다.
  - 분한, 정렬, 합병이 일어나기 때문에 세 가지 조합이라고 볼 수도 있다.
- Exploits the fact that arrays of 0 or 1 element are always sorted
  - 0개, 1개 요소 배열이 이미 정렬되어 있다는 점을 활용한다.
- Works by decomposing an array into smaller arrays of 0 or 1 elements, then building up a newly sorted array
  - 배열을 더 작은 배열로 나누는 방식이다. 더 큰 배열을 나누고 0이나 1 요소 배열이 될 때까지 더 작은 하위 배열로 정렬한다.
  - 따라서 8개 요소 배열을 가져오면 8개의 단일 요소 배열이 될 때까지 분할하고 다시 병합시킨다.

### How does it work?

```
[8, 3, 5, 4, 7, 6, 1, 2] -> split
[8, 3, 5, 4] [7, 6, 1, 2] -> 아직 1개나 0개 요소 배열이 아님 -> split
[8, 3] [5, 4] [7, 6] [1, 2]
[8] [3] [5] [4] [7] [6] [1] [2]
[3, 8] [4, 5] [6, 7] [1, 2] -> 합병시키면서 정렬
[3, 4, 5, 8] [1, 2, 6, 7]
[1, 2, 3, 4, 5, 6, 6, 8]
```

- 정렬된 배열 두 개를 합치는 것은 정렬되지 않은 배열을 합치는 것보다 쉽다.
  - 따라서 기본적으로 어느 숫자가 더 작은지 비교해서 작은 것이 먼저 오도록 해야 한다.
  - 정렬된 배열 두 개를 합병시키는 방법을 이해한다면 나머지는 이해하기 쉽다.
- 시각적으로 어떻게 동작하는지 확인하기
  - [VISUALGO](https://visualgo.net/en/sorting)

## 배열 합병
### Merging Arrays
* 배열이 정렬되어 있다고 가정하고 정렬된 배열 두 개의 조합을 반환하기만 하면 된다.
```
merge([1, 10, 50], [2, 14, 99, 100])
return [1, 2, 10, 14, 50, 99, 100]
```

### Merging Arrays Pseudocode
* In order to implement merge sort, it's useful to first implement a function responsible for merging two sorted arrays.
  * 정렬된 두 배열 합병을 담당할 함수를 먼저 구현하는 것이 좋다
* Given two arrays which are sorted, this helper function should create a new array which is also sorted, and consists of all of the elements in the two input arrays
  * 