# JavaScript 자료구조&알고리즘

> 출처: [JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)

## 목차

- [13. 합병 정렬](#13-합병-정렬)
  - [Intermediate Sorting Algorithms](#intermediate-sorting-algorithms)
    - [Objectives](#Objectives)
    - [Why learn this?](#why-learn-this)
    - [Faster Sorts](#faster-sorts)
  - [Merge Sort 소개](#merge-sort-소개)
    - [Merge Sort](#merge-sort)
    - [How does it work?](#how-does-it-work)
    - [배열 합병(Merging Arrays)](#배열-합병merging-arrays)
    - [Merging Arrays](#merging-arrays)
    - [Merging Arrays Pseudocode](#mergesort-pseudocode)
    - [Big O of mergeSort](#big-o-of-mergesort)
- [14. 퀵 정렬](#14-퀵-정렬)
  - [How does it work?](#how-does-it-work)
  - [Pivot Helper](#pivot-helper)
  - [Picking a pivot](#picking-a-pivot)
  - [Pivot Pseudocode](#pivot-pseudocode)
  - [피벗 helper 함수 구형](#피벗-helper-함수-구형)
  - [Quicksort Pseudocode](#quicksort-pseudocode)
  - [퀵 정렬 스택 호출 소개](#퀵-정렬-스택-호출-소개)
  - [Big O of Quicksort](#big-o-of-quicksort)
- [15. 기수 정렬(Radix Sort)](#15-기수-정렬radix-sort)
  - [기수 정렬](#기수-정렬)
    - [기수 정렬 소개](#기수-정렬-소개)
    - [Radix Sort](#radix-sort)
    - [Radix Sort Helpers](#radix-sort-helpers)
    - [Radix Sort Pseudocode](#radix-sort-pseudocode)
    - [Radix Sort Implement](#radix-sort-implement)
    - [Big O of Radix Sort](#big-o-of-radix-sort)
- [16. 자료 구조 소개](#16-자료-구조-소개)
  - [자료 구조를 배워야 하는 이유](#자료-구조를-배워야-하는-이유)
    - [What do they do?](#what-do-they-do)
    - [Why so many?](#why-so-many)
    - [Why care?](#why-care)
  - [ES2015 클래스](#es2015-클래스)
    - [What is a class](#what-is-a-class)
    - [Instance Methods](#instance-methods)
    - [Class Methods](#class-methods)
    - [How we'll be using classes](#how-well-be-using-classes)
- [17. 단방향 연결 리스트(Singly Linked Lists)](#17-단방향-연결-리스트singly-linked-lists)

# 13. 합병 정렬

## Intermediate Sorting Algorithms

- 작동 방식에 집중하며, 코드의 각 행이 수행하는 작업을 다시 설명할 수 있는 능력에 집중해야 한다.
  - 처음부터 전부 만들어 내는 데는 집중하지 않아도 괜찮다.
- 위 기본 정렬 알고리즘 보다 빠르지만 직접 작성하기에는 직접적이지 않을 수 있다.
  - 이는 까다롭고, 연구자들이 오랫동안 시도하고 시험하여 만든 알고리즘이기 때문에 바로 이해하기 어려울 수 있다.

### Objectives

- Understand the limitations of the sorting algorithms we've learned so far
  - 지금까지 배운 알고리즘(버블/선택/삽입 정렬)의 한계를 이해한다.
- Implement merge/quick/radix sort
  - 합병 정렬, 퀵 정렬, 지수 정렬을 구현한다.

### Why learn this?

- The sorting algoriths we've learned so far don't scale well
  - 지금까지 배운 정렬 알고리즘은 큰 규모에 맞지 않는다.
  - 20개짜리 항목 배열과 같은 작은 규모에서는 꽤 잘 작동하지만 10만 개의 요소로 작업할 경우라면 잘 적용되지 않는다.
- Try out bubble sort on an array of 100000 elements, it will take quite some time!

  - 버블 정렬을 실제로 시도한다면, 규모를 줄여 10만개 요소로 작업할 경우라도 시간이 꽤 걸린다.

  ```javascript
  function bubbleSort(arr) {
    let noSwaps;
    for (let i = arr.length; i > 0; i--) {
      noSwaps = true;
      for (let j = 0; j < i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          let temp = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = temp;
          noSwaps = false;
        }
      }
      if (noSwaps) break;
    }

    return arr;
  }
  const data = Array.apply(null, { length: 100000 }).map(
    Function.call,
    Math.random
  );
  ```

### Faster Sorts

- There is a family of sorting algorithms that can improve time complexity from O(n^2) to O(n log n)
  - 앞으로 배울 빠른 알고리즘 집합은 시간 복잡도를 O(n^2)에서 O(n log n)으로 향상시킬 수 있다.
  - O(log n)과 O(n)만큼 좋지는 않지만 그래도 꽤 괜찮은 편이다.
  - 따라서 앞으로 시간 복잡도를 개선하는 세 가지 알고리즘을 배울 예정!
- There's a tradeoff between efficiency and simplicity
  - 효율성과 단순성은 안타깝게도 상충된다.
- The more efficient algoriths are much less simple, and generally take longer to understand
  - 그래서 효율적인 알고리즘은 활실히 더 어렵고, 더 길며, 코드가 길지 않더라도 이해하기 더 오래 걸린다.
  - 보통 사람들이 생각하는 방식과는 다르다.
  - 그래서 이해하는데 시간이 좀 더 걸리지만, 그럴만한 가치가 있다.

## Merge Sort 소개

### Merge Sort

- It's a combination of two things - merging and sorting!
  - 합병과 정렬의 조합이다.
  - 분한, 정렬, 합병이 일어나기 때문에 세 가지 조합이라고 볼 수도 있다.
- Exploits the fact that arrays of 0 or 1 element are always sorted
  - 0개, 1개 요소 배열이 이미 정렬되어 있다는 점을 활용한다.
- Works by decomposing an array into smaller arrays of 0 or 1 elements, then building up a newly sorted array
  - 배열을 더 작은 배열로 나누는 방식이다. 더 큰 배열을 나누고 0이나 1 요소 배열이 될 때까지 더 작은 하위 배열로 정렬한다.
  - 따라서 8개 요소 배열을 가져오면 8개의 단일 요소 배열이 될 때까지 분할하고 다시 병합시킨다.

### How does it work?

```
[8, 3, 5, 4, 7, 6, 1, 2] -> split
[8, 3, 5, 4] [7, 6, 1, 2] -> 아직 1개나 0개 요소 배열이 아님 -> split
[8, 3] [5, 4] [7, 6] [1, 2]
[8] [3] [5] [4] [7] [6] [1] [2]
[3, 8] [4, 5] [6, 7] [1, 2] -> 합병시키면서 정렬
[3, 4, 5, 8] [1, 2, 6, 7]
[1, 2, 3, 4, 5, 6, 6, 8]
```

- 정렬된 배열 두 개를 합치는 것은 정렬되지 않은 배열을 합치는 것보다 쉽다.
  - 따라서 기본적으로 어느 숫자가 더 작은지 비교해서 작은 것이 먼저 오도록 해야 한다.
  - 정렬된 배열 두 개를 합병시키는 방법을 이해한다면 나머지는 이해하기 쉽다.
- 시각적으로 어떻게 동작하는지 확인하기
  - [VISUALGO](https://visualgo.net/en/sorting)

### 배열 합병(Merging Arrays)

- 배열이 정렬되어 있다고 가정하고 정렬된 배열 두 개의 조합을 반환하기만 하면 된다.

```
merge([1, 10, 50], [2, 14, 99, 100])
return [1, 2, 10, 14, 50, 99, 100]
```

- In order to implement merge sort, it's useful to first implement a function responsible for merging two sorted arrays.
  - 정렬된 두 배열 합병을 담당할 함수를 먼저 구현하는 것이 좋다
- Given two arrays which are sorted, this helper function should create a new array which is also sorted, and consists of all of the elements in the two input arrays
  - 정렬된 두 배열이 주어지면 이 헬퍼 함수는 마찬가지로 정렬된 새 배열을 만든다.
  - 입력 배열 두 개에 있는 모든 요소를 포함하는 것이 중요하다.
  - 크기가 다를 때는 어떻게 해야 할까?
- This function should run in O(n + m) time and O(n + m) space and should not modify the parameters passed to it.
  - 실제 합병 정렬에서 합치는 두 배열이 주로 크기가 똑같거나 요소 하나 차이가 난다.
  - 하지만 어떠한 이유로 요소 천 개가 있는 배열을 백 만개 요소의 배열과 합병할 경우가 있다면 O(n + m)이 된다.

### Merging Arrays Pseudocode

- Create an empty array, take a look at the smallest values in each input array
  - 입력 두 개를 취하는 함수를 정의하여 마지막에 반환할 빈 배열을 만든다.
  - 각 입력 배열에서 가장 작은 값부터 시작한다.
- While there are still values we haven't looked at ...
  - If the value in the first array is smaller than the value in the second array, push te value in the first array into our results and move on to the next value in the first array
  - If the value in the first array is larget than the value in the second array, push the value in the second array into our results and move on to the next value in the second array
  - Once we exhaust on array, push in all remaining v alues from the other array
    - 배열 하나를 완료되면 다른 배열의 남은 값을 모두 넣는다.

```javascript
function mergeArrays(arr1, arr2) {
  let result = [];
  let i = 0;
  let j = 0;

  // result에 arr1, arr2 요소 합친 개수만큼 있으면 종료
  while (result.length < arr1.length + arr2.length) {
    if (arr1[i] <= arr2[j]) {
      // arr1[i]가 arr2[j]보다 작거나 같으면 arr1[i] 요소 삽입
      result.push(arr1[i]);
      i++;
      if (arr1.length === i) result = result.concat(arr2.slice(j));
    } else {
      result.push(arr2[j]);
      j++;
      if (arr2.length === j) result = result.concat(arr1.slice(i));
    }
  }

  return result;
}
```

- concat과 slice를 사용했는데 좋은 코드인지 잘 모르겠다..

### 배열 합병 구현

```javascript
function merge(arr1, arr2) {
  let results = [];
  let i = 0;
  let j = 0;
  // 두 배열 중 하나라도 끝 인덱스에 다른 작업을 해야 한다.(남은 배열의 요소들을 삽입하는 작업)
  while (i < arr1.length && j < arr2.length) {
    if (arr2[j] > arr1[i]) {
      results.push(arr1[i]);
      i++;
    } else {
      results.push(arr2[j]);
      j++;
    }
  }

  while (i < arr1.length) {
    results.push(arr1[i]);
    i++;
  }

  while (j < arr2.length) {
    results.push(arr2[j]);
    j++;
  }

  return results;
}
```

### mergeSort Pseudocode

- 대부분의 합병 절렬 구현 시 `재귀(Recursion)`을 사용한다.

- Break up the array into halves until you have arrays that are empty or have one element.
  - 요소를 하나 갖거나 빈 배열을 가질 때까지 배열을 반쪽들로 나눈다.
  - 하나의 배열을 반으로 나누려면 어떻게 해야 할까? -> Array.prototype.slice() 추천
  - 다 나눠진 배열들로 무엇을 할까?
- Once you have smaller sorted arrays, merge those arrays with other sorted arrays until you are back at the full length of the array.
  - 이렇게 작은 배열이 준비되면 작성해 놓았던 합병 함수를 사용해 전체 배열 길이로 돌아갈 때까지 다시 합친다.
- Once the array has been merged back togerther, return the merged (and sorted!) array
  - 배열을 다시 합쳤으면 가장 마지막에 합병된 배열을 반환한다.

```javascript
function merge(arr1, arr2) {
  let results = [];
  let i = 0;
  let j = 0;
  // 두 배열 중 하나라도 끝 인덱스에 다른 작업을 해야 한다.(남은 배열의 요소들을 삽입하는 작업)
  while (i < arr1.length && j < arr2.length) {
    if (arr2[j] > arr1[i]) {
      results.push(arr1[i]);
      i++;
    } else {
      results.push(arr2[j]);
      j++;
    }
  }

  while (i < arr1.length) {
    results.push(arr1[i]);
    i++;
  }

  while (j < arr2.length) {
    results.push(arr2[j]);
    j++;
  }

  return results;
}

function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  let mid = Math.floor(arr.length / 2);
  let left = mergeSort(arr.slice(0, mid));
  let right = mergeSort(arr.slice(mid));
  console.log(left, right);

  return merge(left, right);
}

mergeSort([10, 24, 76, 73, 72, 1, 9]);
// 계속 분할...
// [24] [76] - 3단계  <- 2단계 left에 [10]이 할당되고 right으로 가서 3단계로 내려감
// [10] [24, 76] - 2단계 -> [10, 24, 76] 1단계 left에 할당
// [73] [72] - 3단계
// [1] [9] - 3단계
// [72, 73] [1, 9] - 2단계 -> [1, 9, 72, 73] 1단계 right에 할당
// [10, 24, 76] [1, 9, 72, 73] -> 1단계 -> 마지막 merge(left, right)를 호출해서 반환
// [1, 9, 10, 24, 72, ,73, 76] 반환
```

### Big O of mergeSort

| Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| --------------------- | ------------------------ | ---------------------- | ---------------- |
| O(n log n)            | O(n log n)               | O(n log n)             | O(n)             |

- 입력값이 무엇이든 이미 정렬되어 있든, 거꾸로 되어 있든, 모두 무작위든 상관없이 계속 나누고 나눈 다음에 합치고 또 합친다.

#### n log n인 이유과 도출된 방법

```
// O(log n) decompositions * O(n) comparisons per decomposition
[8] [3] [5] [4] [7] [6] [1] [2]
[3, 8] [4, 5] [6, 7] [1, 2]
[3, 4, 5, 8] [1, 2, 6, 7]
[1, 2, 3, 4, 5, 6, 7, 8]
```

- 요소 여덟 개가 있는 배열로 시작한다면, 합병 과정을 거친 마지막에 다음과 같이 보인다.
- 배열에 항목 여덟 개가 있다면, 단일 요소 배열이 되려면 몇 번을 나누어야 할까?
  - 이 경우에는 세 번이다.
- 만약 32개의 요소가 있는 배열이 있다면
  - 나누어 16개 요소 2개(1) -> 8개 항목 4개(2) -> 4개 항목 8개(3) -> 2개 항목 16개(4) -> 1개 항목 32개(5)
  - 총 5번 나누어 진다.
- 위 나누어지는 과정을 빅오로 보면 log n이다.
- 그럼 n log n은 무엇일까? 어디서 나타난 것일까?
  - 각 분할마다, 합병할 때 O(n) 비교를 통해 합병한다.
  - n의 길이가 늘어난다면, 합병 정렬이 아닌 합병 알고리즘 자체는 O(n)의 시간 복잡도를 갖게 된다.
- 즉 분할은 O(log n)의 시간 복잡도를 가지는 반면, 분할마다 합병 자체는 O(n)의 시간 복잡도를 가진다.

# 14. 퀵 정렬

- Like merge sort, exploits the fact that arrays of 0 or 1 element are always sorted
  - 합병 정렬 같은 경우, 0개, 1개 요소 가진 배열은 항상 정렬되어 있다는 사실을 이용한다.
- Works by selecting one element (called the "pivot") and finding the index where the pivot should end up in the sorted array
  - 피벗 포인트라 부르는 단일 요소를 선택하여 수행한다.(\* 어떤 배열에서 어떤 요소를 선택하든 문제가 되지 않음)
  - 피벗이 정렬된 배열에서 끝나야 하는 인덱스를 찾는다.
  - 예를 들어, 중앙에 있는 요소를 선택했을 경우, 할 일은 해당 요소의 숫자보다 작은 숫자를 왼쪽으로 정렬이 아닌 옮기는 것이다. 그리고 그 숫자보다 큰 숫자를 오른쪽으로 정렬이 아닌 옮긴다.
  - 이 때, 그 숫자 하나는 올바른 위치이다. 그 숫자 하나만! 다른 숫자들이 오른쪽이나 왼쪽에 있지만 정렬되어 있는지는 모른다.
- Once the pivot is positioned approprivately, quick sort can be applied on either side of the pivot.
  - 그러면 이 과정을 왼쪽과 오른쪽에 반복한다.

### How does it work?

```
[5, 2, 1, 8, 4, 7, 6, 3] -> 1번 인덱스 5를 기준으로 작은 수는 왼쪽, 큰 수는 오른쪽
[3, 2, 1, 4, "5", 7, 6, 8] -> 5만 적절한 위치(4번 인덱스)에 있다. 이 과정을 왼쪽과 오른쪽에서 재귀적으로 반복
[1, 2, "3", 4, "5", 7, 6, 8] -> 3을 기준으로 적절한 위치에 두고 왼쪽은 요소가 2개 이상이므로 재귀 실행
["1", 2, "3", 4, "5", 7, 6, 8] -> 이제 5 기준 오른쪽에서 7을 기준으로 정렬
["1", 2, "3", 4, "5", 6, "7", 8] -> 요소가 하나 남은 것들은 재귀호출하지 않아도 되므로 정렬 완료.
           5 -> 1번
     3           7   -> 2번
1      4     6     8 -> 3번(왼쪽에서만)
   2
```

### Pivot Helper

- In order to implement merge sort, it's useful to first implement a function responsible arranging elements in an array on either side of a pivot
- Given an array, this helper function should designate an element as the pivot
- It should then reaarange elements in the array so that all values less than the pivot are moved to the left of the pivot, and all values greater than the pivot are moved to the right of the pivot
  - 배열이 주어지면 요소를 피벗 포인트로 지정하여 배열 속 요소를 재배치하는 함수를 작성한다.
- The order of elements on either side of the pivot doesn't matter!
  - 말 그대로 양쪽의 순서는 중요하지 않다.
- The helper should do this <b>in place</b>, that is, it should not create a new array
  - 새 배열을 만들면 안 되고, 피벗 인덱스를 반환해야 한다.
- When complete, the helper should return the index of the pivot
  - helper 함수는 제 자리에서 모두 수행하므로 새 배열을 만들지 않는다.

### Picking a pivot

- The runtime of quick sort depends in part on how one selects the pivot
  - 퀵 정렬의 실행 시간은 피벗 선택 위치에 따라 달라질 수 있다.
- Ideally, the pivot should be chosen so that it's roughly the median value in the data set you're sorting
  - 이상적으로는 데이터 집합의 중간값이 되도록 선택해야 한다.
  - 가능하다면 완벽하게 선택할 수 있는 경우, 데이터 정령의 중간값을 선택해서 왼쪽과 오른쪽이 같도록 하는 것이 좋지만
  - 데이터가 무엇인지, 순서가 어떻게 되어 있는지 모른다면 쉽지 않다. 그래서 다른 전략 선택.
- For simplicity, we'll always choose the pivot to be the first element (we'll talk about consequences of this later)
  - 편의상 항상 첫 번째 요소를 피벗으로 선택할 것이다.
  - 그렇게 하면 나중에 얘기할 빅오에 어떤 영향을 미친다.

#### Pivot Helper Example

```js
let arr = [5, 2, 1, 8, 4, 7, 6, 3];

pivot(arr); // 4;

arr;

// any one of these is an acceptable mutation:
// [2, 1, 4, 3, 5, 8, 7, 6]
// [1, 4, 3, 2, 5, 7, 6, 8]
// [3, 2, 1, 4, 5, 7, 6, 8]
// [4, 1, 2, 3, 5, 6, 8, 7]
// there are other acceptable mutations too!
```

### Pivot Pseudocode

- It will help to accept three arguments: an array, a start index, and an end index (these can default to 0 and the array length minus 1, respectively)
  - 피벗 또는 파티션이라 불리는 함수를 작성한다.
  - 이 함수는 배열, 시작인덱스(start index), 끝인덱스(end index)라는 세 개의 인수를 받는다.
  - 그리고 기본값으로 시작인덱스는 0, 끝인덱스는 배열 길이 - 1 이다.
- Grab the pivot from the start of the array
  - 다음 배열 시작 부분에서 피벗을 선택한다.(평의상임. 다른 피벗을 기준을 선택해도 됨)
- Store the current pivot index in a variable (this will keep track of where the pivot should end up)
  - 그런 다음 현재의 피벗 인덱스를 변수로 저장한다.
  - 이렇게 하여 마지막에 피벗을 바꿀 위치를 계속 확인한다.
- Loop through the array from the start until the end
  - 시작부터 끝까지 배열에 루프를 수행한다.
  - If the pivot is greater than the current element, increment the pivot index variable and then swap the current element with the element at the pivot index
    - 살펴보는 요소보다 피벗이 클 경우 피벗 인덱스 변수를 증가시킨 다음 현재 요소를 피벗 인덱스의 요소와 바꾼다.
- Swap the starting element (i.e. the pivot) with the pivot index
- Return the pivot index
  - 그리고 맨 마지막에는 시작했던 피벗과 피벗 인덱스를 바꾼 다음 피벗 인덱스를 반환한다.

### 피벗 helper 함수 구형

```js
function pivot(arr, start = 0, end = arr.lnegth - 1) {
  // ES5 버전의 스왑 함수
  // const swap = (arr, idx1, idx2) => {
  //   [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  // }

  function swap(arr, i, j) {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  let pivot = arr[start];
  let swapIdx = start; // 스왑 인덱스는 피벗이 맨 마지막에 어디로 옮길지 추적

  // 첫 번째 항목 뺴고 루프 수행
  for (let i = start + 1; i < arr.length; i++) {
    // 피벗 비교 (피벗이 해당 요소보다 클 경우 스왑!)
    if (pivot > arr[i]) {
      swapIdx++;
      swap(arr, swapIdx, i);
    }
  }
  swap(arr, start, swapIdx);

  return swapIdx;
}
// pivot([4, 8, 2, 1, 5, 7, 6, 3])
// 첫 번째 엘리먼트를 피벗으로 취하기 때문에 위치할 인덱스 3을 반환해야 한다.
// [4, 8, 2, 1, 5, 7, 6, 3] 첫 번쨰 루프
// [4, 2, 8, 1, 5, 7, 6, 3] 두 번쨰 루프, swapIdx = 1
// [4, 2, 1, 8, 5, 7, 6, 3] 세 번쨰 루프, swapIdx = 2
// [4, 2, 1, 3, 5, 7, 6, 8] 마지막 루프, swapIdx = 3
// 루프 끝나고 arr[swapIdx]와 arr[start] 스왑!
// [3, 2, 1, 4, 5, 7, 6, 8], swapIdx = 3
```

### Quicksort Pseudocode

- Call the pivot helper on the array
  - 전체 배열의 가장 앞에서 피벗 헬퍼를 호출한다.(인덱스를 반환하는 것이 중요)
  - 그리고 해당 피벗 포인트의 왼쪽과 오른쪽에서 다시 퀵 정렬을 호출
- When the helper returns to you the updated pivot index, recursively call the pivot helper on the subarray to the left of that index, and the subarray to the right of that index
  - 업데이트된 피벗 인덱스를 헬퍼가 반환하면 피벗 헬퍼를 재귀적으로 왼쪽과 오른쪽에 호출한다.
  - <b>중요한 점은 새로운 배열을 만들지 않는 것!</b> -> 모두 제자리(같은 배열)에서 일어난다.
  - 따라서 `base case`는 단순히 배열의 길이나 배열에 하나의 항목이 있는지 확인하는 것이 아니라 하위 배열에 항목 하나가 있는지 확인도록 작성해야 한다.
- Your base case occurs when you consider a subarray with less than 2 elements
  - 즉, 하위배열에 2개 미만의 요소가 있을 때 수행된다.

```js
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 하위 배열이 하나의 요소 길이에 도달했을 때를 base case로 둬야하는데
  // 이 때, 왼쪽과 오른쪽이 같다면 한 요소를 살펴보고 있다는 것이므로 left가 right보다 작을 때만 실행하도록 설정
  console.log(left, right);
  if (left < right) {
    // 가장 처음 진행할 때 전체 배열을 호출한 다음,
    // quickSort 재귀함수가 결국 이곳의 하위 배열을 다시 시작하기 때문에 하위 배열은 시작포인트, 끝포인트가 다른다.
    let pivotIndex = pivot(arr, left, right); // 피벗 인덱스, 배열에서 피벗을 호출하는 것과 같음
    // left
    console.log("pivot", pivotIndex);
    quickSort(arr, left, pivotIndex - 1);
    // right
    quickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

quickSort([4, 8, 2, 1, 5, 7, 6, 3]);
// [4, 8, 2, 1, 5, 7, 6, 3]
// [3, 2, 1, 4, 6, 9, 5]
//           4
//  3, 2, 1     6, 9, 5
//        3        6
//  2, 1        5     9
//     2
//  1
```

### 퀵 정렬 스택 호출 소개

```js
quickSort([4, 6, 9, 1, 2, 5]);

// 실행 순서
// quickSort([4, 6, 9, 1, 2, 5], 0, 5)
// pivot([4, 6, 9, 1, 2, 5], 0, 5) -> return 2(pivotIndex)
// 왼쪽부터 시작
// quickSort([2, 1, 4, 6, 9, 5], 0, 1)
// pivot([2, 1, 4, 6, 9, 5], 0, 1) -> return 1(pivotIndex)
// quickSort([1, 2, 4, 6, 9, 5], 0, 0) -> return 지금 arr
// quickSort([1, 2, 4, 6, 9, 5], 1, 1) -> return 지금 arr
// 이제부터 오른쪽
// quickSort([1, 2, 4, 6, 9, 5], 3, 5)
// pivot([1, 2, 4, 5, 6, 9], 3, 5) -> return 4(pivotIndex)
// quickSort([1, 2, 4, 5, 6, 9], 3, 3) -> return 지금 arr
// quickSort([1, 2, 4, 5, 6, 9], 5, 5) -> return 지금 arr
// 마지막 제일 위에 있는 quickSort 함수 호출에 대해서 return arr;

// pivot 빼고 Call Stack 형태

// quickSort([1, 2, 4, 6, 9, 5], 2, 1) -> return(2)
// quickSort([1, 2, 4, 6, 9, 5], 0, 0) -> return(1)
// quickSort([2, 1, 4, 6, 9, 5], 0, 1) -> return(3)
// quickSort([4, 6, 9, 1, 2, 5], 0, 5)

// quickSort([1, 2, 4, 5, 6, 9], 5, 5) -> return(2)
// quickSort([1, 2, 4, 5, 6, 9], 3, 3) -> return(1)
// quickSort([1, 2, 4, 5, 6, 9], 3, 3) -> return(3)
// quickSort([2, 1, 4, 6, 9, 5], 3, 5) -> return(4)
```

### Big O of Quicksort

| Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| --------------------- | ------------------------ | ---------------------- | ---------------- |
| O(n log n)            | O(n log n)               | O(n^2)                 | O(log n)         |

#### Best Case

```
[8, 5, 6, 1, 3, 7, 2, 4, 12, 13, 14, 11, 9, 15, 10]
                      8                               O(lon n) decompositions
[4, 5, 6, 1, 3, 7, 2]   [12, 13, 14, 11 , 9, 15, 10]    ||
          4                         12                  ||       /\
[2, 1, 3]   [6, 7, 5]   [10, 11, 9]    [14, 15, 13]     ||       ||
    2           6            10             14          \/       ||
 1     3     5     7     9       11     13      15            O(n) comparisons per decomposition
```

- 합병 정렬처럼, n이 늘어마녀 밑이 2인 log n의 분해가 수행되는 패턴을 보인다.
  - 32개 요소가 있으면 5번 분해, 64개 요소가 있다면 여섯 번 분해해야 한다.
  - 즉, log n의 비율로 늘어난다.
- 각각 분해하는 단계마다 O(n)번의 비교를 수행해야 한다.

#### Worse Case

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
-> 첫 번째 요소인 1에서 마지막 항목까지 비교, 나뉘는 것 없음
-> 두 번쨰 요소인 2에서 마지막 항목까지 비교, 나뉘는 것 없음
-> 즉, n번 나누고 n번 비교한다. O(n * n)
```

- 데이터가 이미 정렬되어 있을 경우 문제가 된다.

# 15. 기수 정렬(Radix Sort)

## 기수 정렬

### 기수 정렬 소개

- 비교 알고리즘이 아닌 정렬 알고리즘 유형이 있는데 데이터의 특별한 속성을 이용한다.
  - 정수 정렬 알고리즘이라는 정렬 그룹이 있는데 정수가 특별 속성에 해당
  - 직접적으로 비교하는 것이 아니다.
- 직접 비교하지 않는다는 말의 의미는 실제로 상대수사보다 큰지 작은지 비교를 하지 않고 다른 방식으로 데이터를 정렬하게 된다.

### Radix Sort

- Radix sort is a special sorting algorithm that works on lists of numbers
  - 비교를 수행하지 않는 특별한 정렬 알고리즘이고, 숫자로 작동한다.
  - 보통 사용할 때는 이진수를 이용한다.
- It never makes comparisons between elements!
  - 두 요소를 가지고 무엇이 더 크고 작은지 비교하지 않는다.
- It exploits the fact that information about the size of a number is encoded in ther number of digits.
  - 그 대신, 숫자 크기에 대한 정보를 자릿수로 인코딩한다는 사실을 이용한다.
- More digits means a biiger number!
  - 이 말의 의미는 자릿수가 더 큰 수, 예를 들어 네 자리 수가 있다면 두 자리 수보다 더 크다는 것!
  - **두 수가 무엇인지는 중요하지 않다!**
- 비교 정렬에 비해 아주 빠르게 정렬할 수 있다.

### Radix Sort Helpers

- In order to implement radix sort, it's helpful to build a few helper functions first:

  - getDigit(num, place) - returns the digit in num at the given place value

    - 첫 번쨰로 할 일: 자릿수 알아내기(getDigit)

    ```js
    function getDigit(num, i) {
      return Math.floor(Math.abs(num) / Math.pow(10, i)) % 10;
    }

    getDigit(12345, 0); // 5
    getDigit(12345, 1); // 4
    getDigit(12345, 2); // 3
    getDigit(12345, 3); // 2
    getDigit(12345, 4); // 1
    getDigit(12345, 5); // 0
    ```

  - digitCount(num) - returns the number of digis in num
    - 두 번째 할 일: 전체 배열 안에서 자릿수가 가장 많은 수를 알아내는데 자릿수 계산(digitCount)를 사용
    ```js
    function digitCount(num) {
      if (num === 0) return 1; // 0에 로그 계산(log10)을 수행하면 -Infinity를 얻는다.
      return Math.floor(Math.log10(Math.abs(num))) + 1;
    }
    ```
  - mostDitgits(nums) - Given an array of numbers, returns the number of digits in the largest numbers in the list

    - 세 번째 할 일: 수 목록을 가져와서 가장 자릿수가 많은 수가 무엇인지, 자릿수 계산을 통해 알려준다.

    ```js
    function mostDigits(arr) {
      let maxDigits = 0;
      for (let i = 0; i < arr.length; i++) {
        maxDigits = Math.max(maxDigits, digitCount(arr[i]));
      }
      return maxDigits;
    }

    mostDigits([1234, 56, 7]); // 4
    mostDigits([1, 1, 11111, 1]); // 5
    mostDigits([12, 13, 45, 78]); // 2
    ```

  - 재귀나 복잡한 로직을 짤 필요없이 루프를 수행하여 나눈 다음 버킷에 집어넣고, 다시 묶은다음 n번 반복하면 된다.
    - n은 이 때 최대 자릿수!

### Radix Sort Pseudocode

- Define a function that accepts list of numbers(수 목록을 받는 함수 정의)
- Figure out how manu digits the largest number has(가장 큰 수가 몇 자리인지 알아내야 한다.)
- Loop from k = 0 up to this largest number of digits(0부터 가장 큰 자릿수까지 루프)
- For each iteration of the loop:
  - Create buckets for each digit (0 to 9)
    - 진행할 때마다, 각 자릿수에 버킷을 만든다.(버킷: 빈 배열)
  - place each number in the corresponding bucket based on its kth digit
    - 그런 다음 루프를 수행할 때마다 각각의 수를 올바른 버킷에 넣는다. 이 때 kth를 따른다.
    - kth 자릿수: 루프 k가 무엇이든 0에서 시작하며 각 수를 올바른 위치, 올바른 버킷 슬롯에 0 자리를 사용하여 분류하고 다음으로는 첫째 짜리, 둘쨰 자리를 이용하는 것

### Radix Sort Implement

```js
function getDigits(num, i) {
  return Math.floor(Math.abs(num) / Math.pow(10, i)) % 10;
}

function digitCount(num) {
  return Math.floor(Math.log10(Math.abs(num))) + 1;
}

function mostDigits(nums) {
  let maxDigits = 0;
  for (let i = 0; i < nums.length; i++) {
    maxDigits = Math.max(maxDigits, digitCount(nums[i]));
  }

  return maxDigits;
}

function radixSort(nums) {
  let maxDigitCount = mostDigits(nums);

  for (let k = 0; k < maxDigitCount; k++) {
    let digitBuckets = Array.from({ length: 10 }, () => []); // 2차원 배열

    for (let i = 0; i < nums.length; i++) {
      let digit = getDigits(nums[i], k);
      digitBuckets[digit].push(nums[i]);
    }
    nums = [].concat(...digitBuckets); // 전개 연산자(spread operator)
  }

  return nums;
}

radixSort([23, 345, 5467, 12, 2345, 9852]);
```

### Big O of Radix Sort

| Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| --------------------- | ------------------------ | ---------------------- | ---------------- |
| O(nk)                 | O(nk)                    | O(nk)                  | O(n + k)         |

- 최상, 평군, 최악의 시간 복잡도: O(nk)
  - n은 정렬할 항목 수나 정수의 수(length of array)이고, k는 이러한 수의 길이(number of digits)이다.
  - 따라서 아주아주아주아주아주아주아주 자릿수가 길다면 이 점을 고려하는 것이 중요하다.
    - 무시할 수 있는 상수가 아니다. -> 2n, 3n 같은 느낌이 아니다!

# 16. 자료 구조 소개

## 자료 구조를 배워야 하는 이유

### What do they do?

- Data structures are collections of values, the relationships among them, and the functions or operations that can be applied to the data.
  - 그들 모두가 공통적으로 가지고 있는 특징은 **값들의 모음**이라는 것이다.
  - 데이터를 저장할 뿐 아니라 각각의 데이터들 간의 관계를 설정하는 특정한 방식에 의해 데이터를 삽입하기도 한다.
    - **특정한 패턴 또는 관계가 존재한다.**
  - Array 경우, 그 안에 많은 값들이 있으며, 그 값들 사이의 관계(순서) 역시 포함하고 있다.

### Why so many?

- Different data structures excel at different things. Some are highly specialized, while others (like arrays) are more generally used.
  - 특정 유형의 문제에 있어서 특정한 자료 구조가 효율적이라는 사실에 기인한다.
  - 따라서 일부 자료 구조는 매우 특화되어 있는 반면 배열, 객체와 같은 일부 자료 구조들은 일반적이다.
  - 그러나, PB(Red and Black) 트리, 비방향 그래프, 혹은 그와 유사한 자료 구조로 작업해야 할 경우에 이들 자료 구조가 일반 자료 구조들과 다르게 제공되지 않기 때문에 프로그래밍 언어로 직접 구현해야 한다.
    - 그리고 많은 자료구조들 중 하나를 언제 사용할 수 있을지 알고 있어야 한다.

### Why care?

- The more time you spend as a developer, the more likely you'll need to use one of these data structures
  - 개발자로서 많은 시간을 보낼 수록 이러한 고급 자료 구조 사용을 필요로 할 가능성이 그만큼 더 많아진다.
  - 배열만 가지고는 한계가 있기 때문에 더 이상 선형적이지 않고 더 복잡한 데이터를 다루며, 데이터를 저장하기 위한 다른 방법을 배워야 한다.
- Working with map/location data?
  - `Use a graph!`
- Need an ordered list with fast inserts/removals at the beginning and end?
  - 배열의 경우 시작점에 있어 삽입하거나 제거하는 것은 적절하지 않다.
  - `Use a linked list!`
- Web scraping nested HTML?
  - 네스티드(Nested - 구조 내부에 또 다른 구조가 포함되는) HTML을 걷어내는 웹 작업에는?
  - `Use a tree!`
- Need to write a scheduler(작업 우선 순위 결정 모듈)?
  - `Use a binary heap!` (or `Queues`)

## ES2015 클래스

### Objectives

- Explain what a class is (클래스가 무엇인지 살펴보기)
- Understand how JavaScript implements the **idea** of classes
  - 자바스크립트에서 클래스 개념을 어떻게 구현하는지 이해하기
- Define terms like abstraction, encapsulation and polymorphism
  - 추상화, 캡슐화 및 다형성 같은 용어 정의
- Use ES2015 classes to implement data structures
  - ES2015 클래스들을 통해 자료 구조들을 구현하기

### What is a class?

- A blueprint for creating objects with pre-defined properties and methods
  - 사전에 정의된 속성 및 메소들을 이용해 객체를 생성하기 위한 청사진
  - 기본적으로 자바스크립트는 진정한 객체 지향인 적은 없고, 단지 프로토타입 기반 상속자 혹은 프로토타이핑이라 불리는 무엇인가를 이용하는 것이다.
  - 수 많은 자료 구조들을 클래스로 구현해야 하기 때문에 알아야 한다.

### Instance Methods

```js
class Student {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.tardies = 0;
  }

  fullName() {
    return `Your full name is ${this.firstName} ${this.lastName}`;
  }
  markLate() {
    this.tardies++;
    if (this.tardies >= 3) return "YOU ARE EXPELLED!!!!!";
    return `${this.firstName} ${this.lastName} has been late ${this.tardies}`;
  }
}

let firstStudent = new Student("Colt", "Steele");
firstStudent.fullName();
```

### Class Methods

```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  static distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;

    return Math.hypot(dx, dy);
  }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);

Point.distance(p1, p2); // 7.0710...
```

### How we'll be using classes

```js
class DataStructure() {
  constructor() {
    // what default properties should it have?
  }
  someInstanceMethod() {
    // what should each object created from this class be able to do?
  }
}
```

- We will be using the **constructor** and **instance methods** quite a bit!
- We will **almost never** be using **static** methods

# 17. 단방향 연결 리스트(Singly Linked Lists)

### Objectives

- Define what a Singly Linked List is(단방향 연결 리스트가 무엇인지 정의)
- Compare and constrast Linked Lists with Arrays(연결 리스트와 배열을 비교하고 대조)
- Implement insertion, removal and traversal methods on Singly Linked Lists
  - 연결 리스트 클래스를 정의하고, 데이터의 삽입, 추출, 검색, 횡단(순서대로 따라가기), 제거 등을 위한 다수 메서드 구현

## Linked List

### What is a linked list?

- A data structure that contains a head, tail and length property.
- Linked Lists consist of nodes, and each node has a value and a pointer to another node or null
- 배열처럼 순서에 따라 문자열, 숫자 등 무엇이든 원하는 다수의 데이터를 저장하는 자료구조이다.
- 커다란 차이점
  - 배열의 경우, 각 데이터 엘리먼트들은 위치가 지정되고, 번호에 의해 인덱스가 부여된다.
  - 연결 리스트의 경우, 다음 데이터 엘리먼트를 가리키는 **인덱스 없이** 그냥 다수의 데이터 엘리먼트들로 구성된다.
    - 그리고 각각의 엘리먼트를 "노드"라고 부른다.
    - 따라서 연결 리스트들은 다수의 노드들로 구성되고, 각각의 노드는 문자열 혹은 숫자와 같은 하나의 데이터 엘리먼트를 저장한다.
    - 각 노드들은 다음 노드를 가리키는 정보 역시 저장하고 있어야 하며, 더 이상 다음 노드가 없을 경우 아무것도 없음을 의미하는 `null`을 저장하게 된다.
  - 연결 리스트의 세 가지 속성
    - `헤드`: 연결 리스트의 시작 노드를 가리킨다.
    - `테일`: 연결 리스트의 마지막 노드를 가리킨다. 중간에 있는 노드들은 일일히 추적하지 않는다.
    - `길이`: 작업을 용이하게 하기 위해서 길이라는 `속성`을 계속 유지한다.

### Singly Linked Lists Diagram

```
  HEAD    Length: 4     TAIL
    4 ---> 6 ---> 8 ---> 2 --->
      next   next   next   null
```

- 인덱스가 없는 것에 주목!
  - 이것이 `0`번째이고, 첫 번째, 두 번째 그리고 세번째 라는 식으로 이야기할 수 없다!
- 이 리스트에서 무엇인가를 접근하고 싶다면 첫 번째 노드부터 시작해야 한다.
- 연결 리스트는 단지 다음 노드들을 가리키고 있는 수많은 노드들이라고 보면 된다.

### Comparisons with Arrays

- **Lists**
  - Do not have indexes!
    - 각 항목과 일치하는 번호를 가지고 있지 않고, 단순히 "첫 노드"라는 의미하는 변수인 `헤드 포인터`를 가지고 있다.
  - Connected via nodes with a next pointer
  - Random access is not allowed
    - 각 노드는 `next` 포인터를 통해 연결되어 있으며, 이는 임의 접근이 허용되지 않는다는 것을 의미한다.
    - **임의 접근 허용X**: 열 번째 항목이 필요한 경우 바로 그 값을 얻을 수 없다는 것을 의미
    - 배열과 달리 **새로운 항목을 추가하거나 기존 항목을 제거할 경우 연결 리스트를 사용하면 매우 편리하다.**
- **Arrays**
  - Indexed in order!
  - Insertion and deletion can be expensive
  - Can quickly be accessed at a specific index
    - 처음이나 중간에 항목을 추가하면 뒤 인덱스들을 다시 지정해야 하는 것을 감수해야 하지만, 특정 인덱스 접근이 빠르다. 

### 코드 스타터와 push 메서드

```js
// piece of data(node) - val or value
// reference to next node(다음 노드에 대한 참조 정보) - next

class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

var first = new Node("Hi");
first.next = new Node("there");
first.next.next = new Node("how");
first.next.next.next = new Node("are");
first.next.next.next.next = new Node("you");
```